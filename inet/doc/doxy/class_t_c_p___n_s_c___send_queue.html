<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>INET Framework for OMNeT++/OMNEST: TCP_NSC_SendQueue Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>TCP_NSC_SendQueue Class Reference</h1><!-- doxytag: class="TCP_NSC_SendQueue" -->
<p><code>#include &lt;<a class="el" href="_t_c_p___n_s_c___queues_8h_source.html">TCP_NSC_Queues.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TCP_NSC_SendQueue:</div>
<div class="dynsection">
 <div class="center">
  <img src="class_t_c_p___n_s_c___send_queue.gif" usemap="#TCP_NSC_SendQueue_map" alt=""/>
  <map id="TCP_NSC_SendQueue_map" name="TCP_NSC_SendQueue_map">
<area href="class_t_c_p___n_s_c___virtual_data_send_queue.html" alt="TCP_NSC_VirtualDataSendQueue" shape="rect" coords="0,56,206,80"/>
</map>
 </div>
</div>

<p><a href="class_t_c_p___n_s_c___send_queue-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p___n_s_c___send_queue.html#a34c576d60ffca8986c04a84da4bc4b5d">TCP_NSC_SendQueue</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p___n_s_c___send_queue.html#a3a4ee927496ef28d180ad59f2e531229">~TCP_NSC_SendQueue</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p___n_s_c___send_queue.html#a3725b0016361e65cbe60d003f85bbf3c">setConnection</a> (<a class="el" href="class_t_c_p___n_s_c___connection.html">TCP_NSC_Connection</a> *connP)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p___n_s_c___send_queue.html#ae362f60112c3ef36af12ea632c859fdd">enqueueAppData</a> (cPacket *msgP)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p___n_s_c___send_queue.html#a2f70bf1b33917ae3002631cc41bf5d7f">getNscMsg</a> (void *bufferP, int bufferLengthP)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p___n_s_c___send_queue.html#abf531ecfc125a8c5389f32a6c5c8a6a2">dequeueNscMsg</a> (int msgLengthP)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="bsdint_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p___n_s_c___send_queue.html#a6691a8ec9659d9457b76653ee839acb1">getBytesAvailable</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_t_c_p_segment.html">TCPSegment</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p___n_s_c___send_queue.html#a1af3799e52fba7caeaf301fd90ee73b5">createSegmentWithBytes</a> (const void *tcpDataP, int tcpLengthP)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p___n_s_c___send_queue.html#a9be7d952a33aa091becc8df68b567a21">discardUpTo</a> (uint32 seqNumP)=0</td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_c_p___n_s_c___connection.html">TCP_NSC_Connection</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_c_p___n_s_c___send_queue.html#aceca143e6619c019035f626bb184b2e8">connM</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Abstract base class for <a class="el" href="class_t_c_p___n_s_c.html">TCP_NSC</a> send queues. In fact a single object represents both the send queue and the retransmission queue (no need to separate them). The <a class="el" href="class_t_c_p_connection.html">TCPConnection</a> object knows which data in the queue have already been transmitted ("retransmission
 queue") and which not ("send queue"). This class is not interested in where's the boundary.</p>
<p>There is another particularity about this class: as a retransmission queue, it stores bytes and not segments. <a class="el" href="class_t_c_p.html">TCP</a> is a bytestream oriented protocol (sequence numbers refer to bytes and not to TPDUs as e.g. in ISO TP4), and the protocol doesn't rely on retransmitted segments having the same segment boundaries as the original segments. Some implementations store segments on the retransmission queue, and others store only the data bytes; RFCs explicitly allow both. (See e.g. RFC1122 p90, section 4.2.2.15, "IMPLEMENTATION" note).</p>
<p>To simulate a <a class="el" href="class_t_c_p.html">TCP</a> that retains segment boundaries in retransmissions, the appropriate <a class="el" href="class_t_c_p_algorithm.html">TCPAlgorithm</a> class should remember where the segment boundaries were at the original transmission, and it should form identical segments when retransmitting. The <a class="el" href="class_t_c_p___n_s_c___send_queue.html#a1af3799e52fba7caeaf301fd90ee73b5">createSegmentWithBytes()</a> send queue method makes this possible.</p>
<p>This class is polymorphic because depending on where and how you use the <a class="el" href="class_t_c_p.html">TCP</a> model you might have different ideas about "sending data" on a simulated connection.</p>
<p>You might want to:</p>
<ul>
<li>transmit a real bytes, especially if the application which uses <a class="el" href="class_t_c_p.html">TCP</a> is a ported version of a real socket application.</li>
</ul>
<ul>
<li>simulate a "dummy" connection, that is, simulated <a class="el" href="class_t_c_p.html">TCP</a> segments contain do not contain any real data, only the number of bytes they represent. You'll want to do this when the app is there solely as a traffic generator (e.g. simulated file transfer or telnet session), but actual data is unimportant.</li>
</ul>
<ul>
<li>transmit a sequence of cMessage objects, and you want exactly the same cMessage sequence to be reproduced on the receiver side. Here every cMessage maps to a sequence number range in the <a class="el" href="class_t_c_p.html">TCP</a> stream, and the object is passed up to the application on the receiving side when its last byte has arrived on the simulated connection.</li>
</ul>
<p>Different TCP_NSCSendQueue subclasses can be written to accomodate different needs.</p>
<p>This class goes hand-in-hand with TCP_NSCReceiveQueue.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>TCP_NSCReceiveQueue </dd></dl>

<p>Definition at line <a class="el" href="_t_c_p___n_s_c___queues_8h_source.html#l00082">82</a> of file <a class="el" href="_t_c_p___n_s_c___queues_8h_source.html">TCP_NSC_Queues.h</a>.</p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a34c576d60ffca8986c04a84da4bc4b5d"></a><!-- doxytag: member="TCP_NSC_SendQueue::TCP_NSC_SendQueue" ref="a34c576d60ffca8986c04a84da4bc4b5d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TCP_NSC_SendQueue::TCP_NSC_SendQueue </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Ctor. </p>

<p>Definition at line <a class="el" href="_t_c_p___n_s_c___queues_8h_source.html#l00088">88</a> of file <a class="el" href="_t_c_p___n_s_c___queues_8h_source.html">TCP_NSC_Queues.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00088"></a>00088 : <a class="code" href="class_t_c_p___n_s_c___send_queue.html#aceca143e6619c019035f626bb184b2e8">connM</a>(NULL) {}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a3a4ee927496ef28d180ad59f2e531229"></a><!-- doxytag: member="TCP_NSC_SendQueue::~TCP_NSC_SendQueue" ref="a3a4ee927496ef28d180ad59f2e531229" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual TCP_NSC_SendQueue::~TCP_NSC_SendQueue </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Virtual dtor. </p>

<p>Definition at line <a class="el" href="_t_c_p___n_s_c___queues_8h_source.html#l00093">93</a> of file <a class="el" href="_t_c_p___n_s_c___queues_8h_source.html">TCP_NSC_Queues.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00093"></a>00093 {}
</pre></div></p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a1af3799e52fba7caeaf301fd90ee73b5"></a><!-- doxytag: member="TCP_NSC_SendQueue::createSegmentWithBytes" ref="a1af3799e52fba7caeaf301fd90ee73b5" args="(const void *tcpDataP, int tcpLengthP)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_t_c_p_segment.html">TCPSegment</a>* TCP_NSC_SendQueue::createSegmentWithBytes </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>tcpDataP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>tcpLengthP</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called when the <a class="el" href="class_t_c_p.html">TCP</a> wants to send or retransmit data, it constructs a <a class="el" href="class_t_c_p.html">TCP</a> segment which contains the data from the requested sequence number range. The actually returned segment may contain less then maxNumBytes bytes if the subclass wants to reproduce the original segment boundaries when retransmitting.</p>
<p>called from inside of send_callback() called before called the send() to <a class="el" href="class_i_p.html">IP</a> layer </p>

<p>Implemented in <a class="el" href="class_t_c_p___n_s_c___virtual_data_send_queue.html#ade3466c721a3e09de9b4d98281e2d66c">TCP_NSC_VirtualDataSendQueue</a>.</p>

</div>
</div>
<a class="anchor" id="abf531ecfc125a8c5389f32a6c5c8a6a2"></a><!-- doxytag: member="TCP_NSC_SendQueue::dequeueNscMsg" ref="abf531ecfc125a8c5389f32a6c5c8a6a2" args="(int msgLengthP)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void TCP_NSC_SendQueue::dequeueNscMsg </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>msgLengthP</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function should remove msgLengthP bytes from NSCqueue</p>
<p>But the NSC sometimes reread from this datapart (when data destroyed in <a class="el" href="class_i_p.html">IP</a> Layer) inside of <a class="el" href="class_t_c_p___n_s_c___send_queue.html#a1af3799e52fba7caeaf301fd90ee73b5">createSegmentWithBytes()</a> function.</p>
<p>called with return value of socket-&gt;send_data() if larger than 0 </p>

<p>Implemented in <a class="el" href="class_t_c_p___n_s_c___virtual_data_send_queue.html#a93f5616db396c508a9728c894d0f6ea5">TCP_NSC_VirtualDataSendQueue</a>.</p>

</div>
</div>
<a class="anchor" id="a9be7d952a33aa091becc8df68b567a21"></a><!-- doxytag: member="TCP_NSC_SendQueue::discardUpTo" ref="a9be7d952a33aa091becc8df68b567a21" args="(uint32 seqNumP)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void TCP_NSC_SendQueue::discardUpTo </td>
          <td>(</td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>seqNumP</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Tells the queue that bytes up to (but NOT including) seqNum have been transmitted and ACKed, so they can be removed from the queue. </p>

<p>Implemented in <a class="el" href="class_t_c_p___n_s_c___virtual_data_send_queue.html#aa64f1a2b8edacb94a89b0578344d3a6e">TCP_NSC_VirtualDataSendQueue</a>.</p>

</div>
</div>
<a class="anchor" id="ae362f60112c3ef36af12ea632c859fdd"></a><!-- doxytag: member="TCP_NSC_SendQueue::enqueueAppData" ref="ae362f60112c3ef36af12ea632c859fdd" args="(cPacket *msgP)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void TCP_NSC_SendQueue::enqueueAppData </td>
          <td>(</td>
          <td class="paramtype">cPacket *&nbsp;</td>
          <td class="paramname"> <em>msgP</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called on SEND app command, it inserts in the queue the data the user wants to send. Implementations of this abstract class will decide what this means: copying actual bytes, just increasing the "last byte queued" variable, or storing cMessage object(s). The msg object should not be referenced after this point (sendQueue may delete it.) </p>

<p>Implemented in <a class="el" href="class_t_c_p___n_s_c___virtual_data_send_queue.html#af6826305371ce41c3b88e84fe1eff824">TCP_NSC_VirtualDataSendQueue</a>.</p>

</div>
</div>
<a class="anchor" id="a6691a8ec9659d9457b76653ee839acb1"></a><!-- doxytag: member="TCP_NSC_SendQueue::getBytesAvailable" ref="a6691a8ec9659d9457b76653ee839acb1" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="bsdint_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> TCP_NSC_SendQueue::getBytesAvailable </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Utility function: returns how many bytes are available in the queue. </p>

<p>Implemented in <a class="el" href="class_t_c_p___n_s_c___virtual_data_send_queue.html#a1b06b4850403fac42b8dcc583a98a927">TCP_NSC_VirtualDataSendQueue</a>.</p>

</div>
</div>
<a class="anchor" id="a2f70bf1b33917ae3002631cc41bf5d7f"></a><!-- doxytag: member="TCP_NSC_SendQueue::getNscMsg" ref="a2f70bf1b33917ae3002631cc41bf5d7f" args="(void *bufferP, int bufferLengthP)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int TCP_NSC_SendQueue::getNscMsg </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>bufferP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bufferLengthP</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy data to the buffer for send to NSC. returns lengh of copied data. create msg for socket-&gt;send_data()</p>
<p>called before called socket-&gt;send_data() </p>

<p>Implemented in <a class="el" href="class_t_c_p___n_s_c___virtual_data_send_queue.html#ade85fa7f8dc5455aefd2c929900f28dd">TCP_NSC_VirtualDataSendQueue</a>.</p>

</div>
</div>
<a class="anchor" id="a3725b0016361e65cbe60d003f85bbf3c"></a><!-- doxytag: member="TCP_NSC_SendQueue::setConnection" ref="a3725b0016361e65cbe60d003f85bbf3c" args="(TCP_NSC_Connection *connP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void TCP_NSC_SendQueue::setConnection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_c_p___n_s_c___connection.html">TCP_NSC_Connection</a> *&nbsp;</td>
          <td class="paramname"> <em>connP</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>set connection queue, and initialise queue variables. </p>

<p>Reimplemented in <a class="el" href="class_t_c_p___n_s_c___virtual_data_send_queue.html#af3c96f1ea129b3e71978725efdf05590">TCP_NSC_VirtualDataSendQueue</a>.</p>

<p>Definition at line <a class="el" href="_t_c_p___n_s_c___queues_8h_source.html#l00098">98</a> of file <a class="el" href="_t_c_p___n_s_c___queues_8h_source.html">TCP_NSC_Queues.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00098"></a>00098 {<a class="code" href="class_t_c_p___n_s_c___send_queue.html#aceca143e6619c019035f626bb184b2e8">connM</a> = connP; }
</pre></div></p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="aceca143e6619c019035f626bb184b2e8"></a><!-- doxytag: member="TCP_NSC_SendQueue::connM" ref="aceca143e6619c019035f626bb184b2e8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_c_p___n_s_c___connection.html">TCP_NSC_Connection</a>* <a class="el" href="class_t_c_p___n_s_c___send_queue.html#aceca143e6619c019035f626bb184b2e8">TCP_NSC_SendQueue::connM</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_t_c_p___n_s_c___queues_8h_source.html#l00153">153</a> of file <a class="el" href="_t_c_p___n_s_c___queues_8h_source.html">TCP_NSC_Queues.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_t_c_p___n_s_c___queues_8h_source.html">TCP_NSC_Queues.h</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Tue Mar 23 17:08:37 2010 for INET Framework for OMNeT++/OMNEST by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
