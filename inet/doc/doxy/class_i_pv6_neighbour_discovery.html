<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>INET Framework for OMNeT++/OMNEST: IPv6NeighbourDiscovery Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>IPv6NeighbourDiscovery Class Reference</h1><!-- doxytag: class="IPv6NeighbourDiscovery" -->
<p><code>#include &lt;<a class="el" href="_i_pv6_neighbour_discovery_8h_source.html">IPv6NeighbourDiscovery.h</a>&gt;</code></p>

<p><a href="class_i_pv6_neighbour_discovery-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_pv6_neighbour_discovery_1_1_adv_if_entry.html">AdvIfEntry</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_pv6_neighbour_discovery_1_1_d_a_d_entry.html">DADEntry</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_pv6_neighbour_discovery_1_1_r_d_entry.html">RDEntry</a></td></tr>
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; cMessage * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a0e2372b38f3787dd836bcee6b77eb268">MsgPtrVector</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_i_pv6_neighbour_cache_1_1_key.html">IPv6NeighbourCache::Key</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a747705ed3b49881e2d144e2d9f0c8044">Key</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html">IPv6NeighbourCache::Neighbour</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a13e99f7e1505dd01abbf03066e61384c">Neighbour</a></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a108dde1213dc58b6575583eed36cb92b">IPv6NeighbourDiscovery</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#ae7aa7f945013733ec4aebbc290afcb42">~IPv6NeighbourDiscovery</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_m_a_c_address.html">MACAddress</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a567588762bff7af739e72916df55aebc">resolveNeighbour</a> (const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;nextHop, int interfaceId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#abcd9999f935e23b593499f8d23a970bf">reachabilityConfirmed</a> (const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;neighbour, int interfaceId)</td></tr>
<tr><td colspan="2"><h2>Protected Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::set&lt; cMessage * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#af7b0af85c2810acc01d715305818f59b">RATimerList</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::set&lt; <a class="el" href="struct_i_pv6_neighbour_discovery_1_1_d_a_d_entry.html">DADEntry</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a516186e680ba4eaf87de697019421987">DADList</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::set&lt; <a class="el" href="struct_i_pv6_neighbour_discovery_1_1_r_d_entry.html">RDEntry</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a99d6acdeeccceb22d5b199a46c1a0e78">RDList</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::set&lt; <a class="el" href="struct_i_pv6_neighbour_discovery_1_1_adv_if_entry.html">AdvIfEntry</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a74d1e81840eb6742f1f595691e43ac29">AdvIfList</a></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a878f457b650d3fbdf047dd220f8f2d88">numInitStages</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a6855729184a9f8c2e0072f6773f5e96c">initialize</a> (int stage)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#ad90a981569779940aaffe6df55b6285b">handleMessage</a> (cMessage *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a7662f293fab21a873bb22edab70de5ce">processNDMessage</a> (<a class="el" href="class_i_c_m_pv6_message.html">ICMPv6Message</a> *msg, <a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *ctrlInfo)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a9c9fcb239e93ed948efb3a946379a3d2">finish</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#ade69131623bc5b13205ced3ff54a16d3">processIPv6Datagram</a> (<a class="el" href="class_i_pv6_datagram.html">IPv6Datagram</a> *datagram)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
<a class="el" href="struct_i_pv6_neighbour_discovery_1_1_adv_if_entry.html">IPv6NeighbourDiscovery::AdvIfEntry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a44d5adf445298a56e275377d70d620ef">fetchAdvIfEntry</a> (<a class="el" href="class_interface_entry.html">InterfaceEntry</a> *ie)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
<a class="el" href="struct_i_pv6_neighbour_discovery_1_1_r_d_entry.html">IPv6NeighbourDiscovery::RDEntry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#ab83db378f6596fd37ab6657b13707aa4">fetchRDEntry</a> (<a class="el" href="class_interface_entry.html">InterfaceEntry</a> *ie)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_i_pv6_address.html">IPv6Address</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a4bddad274cd8eb1472d37ddcd559c629">determineNextHop</a> (const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;destAddr, int &amp;outIfID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a9f14cc2bfe0cce622308be4388b3b397">initiateNeighbourUnreachabilityDetection</a> (<a class="el" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html">Neighbour</a> *neighbour)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a623b4069795d46d2b421d5aee4f1eb59">processNUDTimeout</a> (cMessage *timeoutMsg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_i_pv6_address.html">IPv6Address</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a9f6c83de24b3e270c3843cc213b5250a">selectDefaultRouter</a> (int &amp;outIfID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a0e59b5c2995f7bdec6b6a67e60a1e675">timeoutPrefixEntry</a> (const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;destPrefix, int prefixLength)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a303391440ad2004ff69cfc5e4cf7504a">timeoutDefaultRouter</a> (const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;addr, int interfaceID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a6afff1bf1db0e7b69f3f6782a87b5b82">initiateAddressResolution</a> (const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;dgSrcAddr, <a class="el" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html">Neighbour</a> *nce)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a61e880bea24c63e2661d2722077ac172">processARTimeout</a> (cMessage *arTimeoutMsg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a888724269369dc1aa87aa73586216b8c">dropQueuedPacketsAwaitingAR</a> (<a class="el" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html">Neighbour</a> *nce)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a58642b1dc383266b43abc6d6e4a74e5e">sendPacketToIPv6Module</a> (cMessage *msg, const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;destAddr, const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;srcAddr, int interfaceId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a6cc2bafedafa13f79df2410b6617ff4b">sendQueuedPacketsToIPv6Module</a> (<a class="el" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html">Neighbour</a> *nce)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#aab8e413cb12b66797d5e497f9fe6fddd">initiateDAD</a> (const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;tentativeAddr, <a class="el" href="class_interface_entry.html">InterfaceEntry</a> *ie)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a13117cd0ac035e0a0fd198d872b209c3">processDADTimeout</a> (cMessage *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a5438ceb3077ec49d9b393136a9a5e768">assignLinkLocalAddress</a> (cMessage *timerMsg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_i_pv6_router_solicitation.html">IPv6RouterSolicitation</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a75431d6a5076b17ae0630f2fc4aa441a">createAndSendRSPacket</a> (<a class="el" href="class_interface_entry.html">InterfaceEntry</a> *ie)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a53cb1f954b65272ad826f3daaec29136">initiateRouterDiscovery</a> (cMessage *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a01e12e84e38baf2539a8335f8f01abc6">cancelRouterDiscovery</a> (<a class="el" href="class_interface_entry.html">InterfaceEntry</a> *ie)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a860a64e4fbb311fef343ec7044c0a10b">processRDTimeout</a> (cMessage *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#ac6f2316e1a19d2816bab83e96d11ef57">processRSPacket</a> (<a class="el" href="class_i_pv6_router_solicitation.html">IPv6RouterSolicitation</a> *rs, <a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *rsCtrlInfo)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a09f8b6d13b8546d9c3d735589df9e37f">validateRSPacket</a> (<a class="el" href="class_i_pv6_router_solicitation.html">IPv6RouterSolicitation</a> *rs, <a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *rsCtrlInfo)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_i_pv6_router_advertisement.html">IPv6RouterAdvertisement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a50d09a125fd3477828643875b72573ec">createAndSendRAPacket</a> (const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;destAddr, <a class="el" href="class_interface_entry.html">InterfaceEntry</a> *ie)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a4482770f35807ddc238a9259e85752e3">processRAPacket</a> (<a class="el" href="class_i_pv6_router_advertisement.html">IPv6RouterAdvertisement</a> *ra, <a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *raCtrlInfo)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a41da6658d387e46e3e656d4704bf908f">processRAForRouterUpdates</a> (<a class="el" href="class_i_pv6_router_advertisement.html">IPv6RouterAdvertisement</a> *ra, <a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *raCtrlInfo)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a5acf0814f6ca500c38d87763c0a5aef7">processRAPrefixInfo</a> (<a class="el" href="class_i_pv6_router_advertisement.html">IPv6RouterAdvertisement</a> *ra, <a class="el" href="class_interface_entry.html">InterfaceEntry</a> *ie)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#ae187033477823763f0fc0063353821f6">processRAPrefixInfoForAddrAutoConf</a> (<a class="el" href="class_i_pv6_n_d_prefix_information.html">IPv6NDPrefixInformation</a> &amp;prefixInfo, <a class="el" href="class_interface_entry.html">InterfaceEntry</a> *ie)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a6e0f7e782e7b912a683c653b30e7b957">createRATimer</a> (<a class="el" href="class_interface_entry.html">InterfaceEntry</a> *ie)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#acd79bbeb030e0105e39d63cab1cee297">resetRATimer</a> (<a class="el" href="class_interface_entry.html">InterfaceEntry</a> *ie)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a7ab6b1fc3d01da2bc31d772a31013e08">sendPeriodicRA</a> (cMessage *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a32ed95da45989efe4509946492299d34">sendSolicitedRA</a> (cMessage *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a902261563ea0bd130700a148a062781c">validateRAPacket</a> (<a class="el" href="class_i_pv6_router_advertisement.html">IPv6RouterAdvertisement</a> *ra, <a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *raCtrlInfo)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_i_pv6_neighbour_solicitation.html">IPv6NeighbourSolicitation</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#aedad2b550812f9be54ab691296e5876d">createAndSendNSPacket</a> (const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;nsTargetAddr, const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;dgDestAddr, const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;dgSrcAddr, <a class="el" href="class_interface_entry.html">InterfaceEntry</a> *ie)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a8d7676502f17ed01eb095afadab7bb33">processNSPacket</a> (<a class="el" href="class_i_pv6_neighbour_solicitation.html">IPv6NeighbourSolicitation</a> *ns, <a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *naCtrlInfo)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a72d9ee3401361c560c47f5172c05c1a4">validateNSPacket</a> (<a class="el" href="class_i_pv6_neighbour_solicitation.html">IPv6NeighbourSolicitation</a> *ns, <a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *nsCtrlInfo)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a1d21eff02fed770d1bf56dbb995c3db9">processNSForTentativeAddress</a> (<a class="el" href="class_i_pv6_neighbour_solicitation.html">IPv6NeighbourSolicitation</a> *ns, <a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *ctrlInfo)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#abccb93f2300252252370c5cfab5017c6">processNSForNonTentativeAddress</a> (<a class="el" href="class_i_pv6_neighbour_solicitation.html">IPv6NeighbourSolicitation</a> *ns, <a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *ctrlInfo, <a class="el" href="class_interface_entry.html">InterfaceEntry</a> *ie)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a8106a5866c58a9c6372c741a15ce943b">processNSWithSpecifiedSrcAddr</a> (<a class="el" href="class_i_pv6_neighbour_solicitation.html">IPv6NeighbourSolicitation</a> *ns, <a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *ctrlInfo, <a class="el" href="class_interface_entry.html">InterfaceEntry</a> *ie)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#ac2a5f2e2cbd6845ecd10038fce448ead">sendSolicitedNA</a> (<a class="el" href="class_i_pv6_neighbour_solicitation.html">IPv6NeighbourSolicitation</a> *ns, <a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *nsCtrlInfo, <a class="el" href="class_interface_entry.html">InterfaceEntry</a> *ie)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a30bc9cd2bec93e40e238fe91b573ca9f">sendUnsolicitedNA</a> (<a class="el" href="class_interface_entry.html">InterfaceEntry</a> *ie)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a348ba5dd9e93f4640d465a74b8a73d53">processNAPacket</a> (<a class="el" href="class_i_pv6_neighbour_advertisement.html">IPv6NeighbourAdvertisement</a> *na, <a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *naCtrlInfo)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a8f18a6e238820911ee6253f12b766fad">validateNAPacket</a> (<a class="el" href="class_i_pv6_neighbour_advertisement.html">IPv6NeighbourAdvertisement</a> *na, <a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *naCtrlInfo)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a093219842e9055dc413f8f6d401001ee">processNAForIncompleteNCEState</a> (<a class="el" href="class_i_pv6_neighbour_advertisement.html">IPv6NeighbourAdvertisement</a> *na, <a class="el" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html">IPv6NeighbourCache::Neighbour</a> *nce)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a58a8a7aaf00643c4eb0044cc1380413b">processNAForOtherNCEStates</a> (<a class="el" href="class_i_pv6_neighbour_advertisement.html">IPv6NeighbourAdvertisement</a> *na, <a class="el" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html">IPv6NeighbourCache::Neighbour</a> *nce)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_i_pv6_redirect.html">IPv6Redirect</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a96fb67a2da25bbcd4b18a21a1d597fa6">createAndSendRedirectPacket</a> (<a class="el" href="class_interface_entry.html">InterfaceEntry</a> *ie)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#ab95f9c30abcda08c3b762d191df4a3ae">processRedirectPacket</a> (<a class="el" href="class_i_pv6_redirect.html">IPv6Redirect</a> *redirect, <a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *ctrlInfo)</td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cQueue&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a8cebccf199f96d0903c4663b203199ca">pendingQueue</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_interface_table.html">IInterfaceTable</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a4b4f35b761b93c397e2a5a36c1e08d38">ift</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_routing_table6.html">RoutingTable6</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a0f6a26512cd490f5a09e9bd7ec3bf61f">rt6</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_c_m_pv6.html">ICMPv6</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a78cfa038ef771566c18a2eec28fd740b">icmpv6</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_pv6_neighbour_cache.html">IPv6NeighbourCache</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">neighbourCache</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_pv6_neighbour_discovery.html#af7b0af85c2810acc01d715305818f59b">RATimerList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#ad8d41d97624aa9ba4878adea476018d0">raTimerList</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_pv6_neighbour_discovery.html#a516186e680ba4eaf87de697019421987">DADList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a750d70366700481befd66c567d420a7e">dadList</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_pv6_neighbour_discovery.html#a99d6acdeeccceb22d5b199a46c1a0e78">RDList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a7f075a086f580756337ef6f59223727c">rdList</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_pv6_neighbour_discovery.html#a74d1e81840eb6742f1f595691e43ac29">AdvIfList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv6_neighbour_discovery.html#a868ef2afa69950bd536b1fb5cd10569a">advIfList</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Copyright (C) 2005 Andras Varga Copyright (C) 2005 Wei Yang, Ng</p>
<p>This program is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p>
<p>You should have received a copy of the GNU Lesser General Public License along with this program; if not, see &lt;<a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;. Implements RFC 2461 Neighbor Discovery for <a class="el" href="class_i_pv6.html">IPv6</a>. </p>

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8h_source.html#l00044">44</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8h_source.html">IPv6NeighbourDiscovery.h</a>.</p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a74d1e81840eb6742f1f595691e43ac29"></a><!-- doxytag: member="IPv6NeighbourDiscovery::AdvIfList" ref="a74d1e81840eb6742f1f595691e43ac29" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::set&lt;<a class="el" href="struct_i_pv6_neighbour_discovery_1_1_adv_if_entry.html">AdvIfEntry</a>*&gt; <a class="el" href="class_i_pv6_neighbour_discovery.html#a74d1e81840eb6742f1f595691e43ac29">IPv6NeighbourDiscovery::AdvIfList</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8h_source.html#l00121">121</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8h_source.html">IPv6NeighbourDiscovery.h</a>.</p>

</div>
</div>
<a class="anchor" id="a516186e680ba4eaf87de697019421987"></a><!-- doxytag: member="IPv6NeighbourDiscovery::DADList" ref="a516186e680ba4eaf87de697019421987" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::set&lt;<a class="el" href="struct_i_pv6_neighbour_discovery_1_1_d_a_d_entry.html">DADEntry</a>*&gt; <a class="el" href="class_i_pv6_neighbour_discovery.html#a516186e680ba4eaf87de697019421987">IPv6NeighbourDiscovery::DADList</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8h_source.html#l00104">104</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8h_source.html">IPv6NeighbourDiscovery.h</a>.</p>

</div>
</div>
<a class="anchor" id="a747705ed3b49881e2d144e2d9f0c8044"></a><!-- doxytag: member="IPv6NeighbourDiscovery::Key" ref="a747705ed3b49881e2d144e2d9f0c8044" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_i_pv6_neighbour_cache_1_1_key.html">IPv6NeighbourCache::Key</a> <a class="el" href="struct_i_pv6_neighbour_cache_1_1_key.html">IPv6NeighbourDiscovery::Key</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8h_source.html#l00048">48</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8h_source.html">IPv6NeighbourDiscovery.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0e2372b38f3787dd836bcee6b77eb268"></a><!-- doxytag: member="IPv6NeighbourDiscovery::MsgPtrVector" ref="a0e2372b38f3787dd836bcee6b77eb268" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;cMessage*&gt; <a class="el" href="class_i_pv6_neighbour_discovery.html#a0e2372b38f3787dd836bcee6b77eb268">IPv6NeighbourDiscovery::MsgPtrVector</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8h_source.html#l00047">47</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8h_source.html">IPv6NeighbourDiscovery.h</a>.</p>

</div>
</div>
<a class="anchor" id="a13e99f7e1505dd01abbf03066e61384c"></a><!-- doxytag: member="IPv6NeighbourDiscovery::Neighbour" ref="a13e99f7e1505dd01abbf03066e61384c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html">IPv6NeighbourCache::Neighbour</a> <a class="el" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html">IPv6NeighbourDiscovery::Neighbour</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8h_source.html#l00049">49</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8h_source.html">IPv6NeighbourDiscovery.h</a>.</p>

</div>
</div>
<a class="anchor" id="af7b0af85c2810acc01d715305818f59b"></a><!-- doxytag: member="IPv6NeighbourDiscovery::RATimerList" ref="af7b0af85c2810acc01d715305818f59b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::set&lt;cMessage*&gt; <a class="el" href="class_i_pv6_neighbour_discovery.html#af7b0af85c2810acc01d715305818f59b">IPv6NeighbourDiscovery::RATimerList</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8h_source.html#l00094">94</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8h_source.html">IPv6NeighbourDiscovery.h</a>.</p>

</div>
</div>
<a class="anchor" id="a99d6acdeeccceb22d5b199a46c1a0e78"></a><!-- doxytag: member="IPv6NeighbourDiscovery::RDList" ref="a99d6acdeeccceb22d5b199a46c1a0e78" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::set&lt;<a class="el" href="struct_i_pv6_neighbour_discovery_1_1_r_d_entry.html">RDEntry</a>*&gt; <a class="el" href="class_i_pv6_neighbour_discovery.html#a99d6acdeeccceb22d5b199a46c1a0e78">IPv6NeighbourDiscovery::RDList</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8h_source.html#l00112">112</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8h_source.html">IPv6NeighbourDiscovery.h</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a108dde1213dc58b6575583eed36cb92b"></a><!-- doxytag: member="IPv6NeighbourDiscovery::IPv6NeighbourDiscovery" ref="a108dde1213dc58b6575583eed36cb92b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IPv6NeighbourDiscovery::IPv6NeighbourDiscovery </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00034">34</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00035"></a>00035 {
<a name="l00036"></a>00036 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ae7aa7f945013733ec4aebbc290afcb42"></a><!-- doxytag: member="IPv6NeighbourDiscovery::~IPv6NeighbourDiscovery" ref="ae7aa7f945013733ec4aebbc290afcb42" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IPv6NeighbourDiscovery::~IPv6NeighbourDiscovery </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00038">38</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00039"></a>00039 {
<a name="l00040"></a>00040     <span class="comment">// FIXME delete the following data structures, cancelAndDelete timers in them etc.</span>
<a name="l00041"></a>00041     <span class="comment">// Deleting the data structures my become unnecessary if the lists store the</span>
<a name="l00042"></a>00042     <span class="comment">// structs themselves and not pointers.</span>
<a name="l00043"></a>00043     <span class="comment">//   RATimerList raTimerList;</span>
<a name="l00044"></a>00044     <span class="comment">//   DADList dadList;</span>
<a name="l00045"></a>00045     <span class="comment">//   RDList rdList;</span>
<a name="l00046"></a>00046     <span class="comment">//   AdvIfList advIfList;</span>
<a name="l00047"></a>00047 }
</pre></div></p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a5438ceb3077ec49d9b393136a9a5e768"></a><!-- doxytag: member="IPv6NeighbourDiscovery::assignLinkLocalAddress" ref="a5438ceb3077ec49d9b393136a9a5e768" args="(cMessage *timerMsg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPv6NeighbourDiscovery::assignLinkLocalAddress </td>
          <td>(</td>
          <td class="paramtype">cMessage *&nbsp;</td>
          <td class="paramname"> <em>timerMsg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>as it is not possbile to explicitly define RFC 2462. ND is the next best place to do this.</p>
<p>RFC 2462-IPv6 Stateless Address Autoconfiguration: Section 1 The autoconfiguration process specified in this document applies only to hosts and not routers. Since host autoconfiguration uses information advertised by routers, routers will need to be configured by some other means. However, it is expected that routers will generate link-local addresses using the mechanism described in this document. In addition, routers are expected to successfully pass the Duplicate Address Detection procedure described in this document on all addresses prior to assigning them to an interface. </p>

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00730">730</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00081">handleMessage()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00731"></a>00731 {
<a name="l00732"></a>00732     <span class="comment">//Node has booted up. Start assigning a link-local address for each</span>
<a name="l00733"></a>00733     <span class="comment">//interface in this node.</span>
<a name="l00734"></a>00734     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; <a class="code" href="class_i_pv6_neighbour_discovery.html#a4b4f35b761b93c397e2a5a36c1e08d38">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a2b0ce46cd92da6f64fc363410dc71904">getNumInterfaces</a>(); i++)
<a name="l00735"></a>00735     {
<a name="l00736"></a>00736         <a class="code" href="class_interface_entry.html">InterfaceEntry</a> *ie = <a class="code" href="class_i_pv6_neighbour_discovery.html#a4b4f35b761b93c397e2a5a36c1e08d38">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a19ce4ca3b47b52b8e2b67c25806c4b49">getInterface</a>(i);
<a name="l00737"></a>00737 
<a name="l00738"></a>00738         <span class="comment">//Skip the loopback interface.</span>
<a name="l00739"></a>00739         <span class="keywordflow">if</span> (ie-&gt;<a class="code" href="class_interface_entry.html#a0ee93e88273f61390d1293dae55004d1">isLoopback</a>()) <span class="keywordflow">continue</span>;
<a name="l00740"></a>00740 
<a name="l00741"></a>00741         <a class="code" href="class_i_pv6_address.html">IPv6Address</a> linkLocalAddr = ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a3b9fa2d8e186014cf9c758e45b5a56df">getLinkLocalAddress</a>();
<a name="l00742"></a>00742         <span class="keywordflow">if</span> (linkLocalAddr.<a class="code" href="class_i_pv6_address.html#af526cffcc3a4aa5bb96d307de6e8d448">isUnspecified</a>())
<a name="l00743"></a>00743         {
<a name="l00744"></a>00744             <span class="comment">//if no link local address exists for this interface, we assign one to it.</span>
<a name="l00745"></a>00745                 <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;No link local address exists. Forming one&quot;</span> &lt;&lt; endl;
<a name="l00746"></a>00746             linkLocalAddr = <a class="code" href="class_i_pv6_address.html">IPv6Address</a>().<a class="code" href="class_i_pv6_address.html#aa8a3ef9e930a6703ea9cbde5a3ecaaca">formLinkLocalAddress</a>(ie-&gt;<a class="code" href="class_interface_entry.html#a1196c8e3f1a10a26778296af4c14a4bb">getInterfaceToken</a>());
<a name="l00747"></a>00747             ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a715b339dc41612149940ed0607af1535">assignAddress</a>(linkLocalAddr, <span class="keyword">true</span>, 0, 0);
<a name="l00748"></a>00748         }
<a name="l00749"></a>00749 
<a name="l00750"></a>00750         <span class="comment">//Before we can use this address, we MUST initiate DAD first.</span>
<a name="l00751"></a>00751         <a class="code" href="class_i_pv6_neighbour_discovery.html#aab8e413cb12b66797d5e497f9fe6fddd">initiateDAD</a>(linkLocalAddr, ie);
<a name="l00752"></a>00752     }
<a name="l00753"></a>00753     <span class="keyword">delete</span> timerMsg;
<a name="l00754"></a>00754 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a01e12e84e38baf2539a8335f8f01abc6"></a><!-- doxytag: member="IPv6NeighbourDiscovery::cancelRouterDiscovery" ref="a01e12e84e38baf2539a8335f8f01abc6" args="(InterfaceEntry *ie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPv6NeighbourDiscovery::cancelRouterDiscovery </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&nbsp;</td>
          <td class="paramname"> <em>ie</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>RFC 2461: Section 6.3.7 4th paragraph Once the host sends a Router Solicitation, and receives a valid Router Advertisement with a non-zero Router Lifetime, the host MUST desist from sending additional solicitations on that interface,</p>
<p>Cancel Router Discovery on the Interface where a RA was received with the given Interface Entry. </p>

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00889">889</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01116">processRAPacket()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00890"></a>00890 {
<a name="l00891"></a>00891     <span class="comment">//Next we retrieve the rdEntry with the Interface Entry.</span>
<a name="l00892"></a>00892     RDEntry *rdEntry = <a class="code" href="class_i_pv6_neighbour_discovery.html#ab83db378f6596fd37ab6657b13707aa4">fetchRDEntry</a>(ie);
<a name="l00893"></a>00893     <span class="keywordflow">if</span> (rdEntry != NULL)
<a name="l00894"></a>00894     {
<a name="l00895"></a>00895         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;rdEntry is not NULL, RD cancelled!&quot;</span> &lt;&lt; endl;
<a name="l00896"></a>00896         cancelEvent(rdEntry-&gt;timeoutMsg);
<a name="l00897"></a>00897         <a class="code" href="class_i_pv6_neighbour_discovery.html#a7f075a086f580756337ef6f59223727c">rdList</a>.erase(rdEntry);
<a name="l00898"></a>00898         <span class="keyword">delete</span> rdEntry;
<a name="l00899"></a>00899     }
<a name="l00900"></a>00900     <span class="keywordflow">else</span>
<a name="l00901"></a>00901         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;rdEntry is NULL, not cancelling RD!&quot;</span> &lt;&lt; endl;
<a name="l00902"></a>00902 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aedad2b550812f9be54ab691296e5876d"></a><!-- doxytag: member="IPv6NeighbourDiscovery::createAndSendNSPacket" ref="aedad2b550812f9be54ab691296e5876d" args="(const IPv6Address &amp;nsTargetAddr, const IPv6Address &amp;dgDestAddr, const IPv6Address &amp;dgSrcAddr, InterfaceEntry *ie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_pv6_neighbour_solicitation.html">IPv6NeighbourSolicitation</a> * IPv6NeighbourDiscovery::createAndSendNSPacket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>nsTargetAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dgDestAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dgSrcAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&nbsp;</td>
          <td class="paramname"> <em>ie</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01566">1566</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00593">initiateAddressResolution()</a>, <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00756">initiateDAD()</a>, <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00646">processARTimeout()</a>, <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00783">processDADTimeout()</a>, and <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00449">processNUDTimeout()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01569"></a>01569 {
<a name="l01570"></a>01570     <a class="code" href="class_m_a_c_address.html">MACAddress</a> myMacAddr = ie-&gt;<a class="code" href="class_interface_entry.html#af8004a12e9aac171699ff1f7f08ee4c4">getMacAddress</a>();
<a name="l01571"></a>01571 
<a name="l01572"></a>01572     <span class="comment">//Construct a Neighbour Solicitation message</span>
<a name="l01573"></a>01573     <a class="code" href="class_i_pv6_neighbour_solicitation.html">IPv6NeighbourSolicitation</a> *ns = <span class="keyword">new</span> <a class="code" href="class_i_pv6_neighbour_solicitation.html">IPv6NeighbourSolicitation</a>(<span class="stringliteral">&quot;NSpacket&quot;</span>);
<a name="l01574"></a>01574     ns-&gt;<a class="code" href="class_i_c_m_pv6_message.html#a0d30a321ffafbc6af65fcafac9165a14">setType</a>(<a class="code" href="_i_c_m_pv6_message__m_8h.html#a007402fd73fa0142d3b888578b1280f8affcf80b9ec52fe2943c51544b9a3f5ce">ICMPv6_NEIGHBOUR_SOL</a>);
<a name="l01575"></a>01575 
<a name="l01576"></a>01576     <span class="comment">//Neighbour Solicitation Specific Information</span>
<a name="l01577"></a>01577     ns-&gt;<a class="code" href="class_i_pv6_neighbour_solicitation.html#ae7df5ea2fe82b146a2e98875a9eb1b59">setTargetAddress</a>(nsTargetAddr);
<a name="l01578"></a>01578 
<a name="l01579"></a>01579     <span class="comment">/*If the solicitation is being sent to a solicited-node multicast</span>
<a name="l01580"></a>01580 <span class="comment">    address, the sender MUST include its link-layer address (if it has</span>
<a name="l01581"></a>01581 <span class="comment">    one) as a Source Link-Layer Address option.*/</span>
<a name="l01582"></a>01582     <span class="keywordflow">if</span> (dgDestAddr.<a class="code" href="class_i_pv6_address.html#a4d9102b52fcf98d1945c75a098bc678a">matches</a>(<a class="code" href="class_i_pv6_address.html">IPv6Address</a>(<span class="stringliteral">&quot;FF02::1:FF00:0&quot;</span>),104) &amp;&amp; <span class="comment">// FIXME what&apos;s this? make constant...</span>
<a name="l01583"></a>01583         !dgSrcAddr.<a class="code" href="class_i_pv6_address.html#af526cffcc3a4aa5bb96d307de6e8d448">isUnspecified</a>())
<a name="l01584"></a>01584         ns-&gt;<a class="code" href="class_i_pv6_neighbour_solicitation.html#a29d46c0498c045342b1ade643485ace4">setSourceLinkLayerAddress</a>(myMacAddr);
<a name="l01585"></a>01585 
<a name="l01586"></a>01586     <a class="code" href="class_i_pv6_neighbour_discovery.html#a58642b1dc383266b43abc6d6e4a74e5e">sendPacketToIPv6Module</a>(ns, dgDestAddr, dgSrcAddr, ie-&gt;<a class="code" href="class_interface_entry.html#adc901fa42c37ce16b5c0785da81106ce">getInterfaceId</a>());
<a name="l01587"></a>01587 
<a name="l01588"></a>01588     <span class="keywordflow">return</span> ns;
<a name="l01589"></a>01589 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a50d09a125fd3477828643875b72573ec"></a><!-- doxytag: member="IPv6NeighbourDiscovery::createAndSendRAPacket" ref="a50d09a125fd3477828643875b72573ec" args="(const IPv6Address &amp;destAddr, InterfaceEntry *ie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_pv6_router_advertisement.html">IPv6RouterAdvertisement</a> * IPv6NeighbourDiscovery::createAndSendRAPacket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>destAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&nbsp;</td>
          <td class="paramname"> <em>ie</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01044">1044</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01480">sendPeriodicRA()</a>, and <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01519">sendSolicitedRA()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01046"></a>01046 {
<a name="l01047"></a>01047     <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Create and send RA invoked!\n&quot;</span>;
<a name="l01048"></a>01048     <span class="comment">//Must use link-local addr. See: RFC2461 Section 6.1.2</span>
<a name="l01049"></a>01049     <a class="code" href="class_i_pv6_address.html">IPv6Address</a> sourceAddr = ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a3b9fa2d8e186014cf9c758e45b5a56df">getLinkLocalAddress</a>();
<a name="l01050"></a>01050 
<a name="l01051"></a>01051     <span class="comment">//This operation includes all options, regardless whether it is solicited or unsolicited.</span>
<a name="l01052"></a>01052     <span class="keywordflow">if</span> (ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a3e629909076b47fa0886f83fbb7af09a">getAdvSendAdvertisements</a>()) <span class="comment">//if this is an advertising interface</span>
<a name="l01053"></a>01053     {
<a name="l01054"></a>01054         <span class="comment">//Construct a Router Advertisment message</span>
<a name="l01055"></a>01055         <a class="code" href="class_i_pv6_router_advertisement.html">IPv6RouterAdvertisement</a> *ra = <span class="keyword">new</span> <a class="code" href="class_i_pv6_router_advertisement.html">IPv6RouterAdvertisement</a>(<span class="stringliteral">&quot;RApacket&quot;</span>);
<a name="l01056"></a>01056         ra-&gt;<a class="code" href="class_i_c_m_pv6_message.html#a0d30a321ffafbc6af65fcafac9165a14">setType</a>(<a class="code" href="_i_c_m_pv6_message__m_8h.html#a007402fd73fa0142d3b888578b1280f8a174c9cf27d2d2203dad02feefb9b0281">ICMPv6_ROUTER_AD</a>);
<a name="l01057"></a>01057 
<a name="l01058"></a>01058         <span class="comment">//RFC 2461: Section 6.2.3 Router Advertisment Message Content</span>
<a name="l01059"></a>01059         <span class="comment">/*A router sends periodic as well as solicited Router Advertisements out</span>
<a name="l01060"></a>01060 <span class="comment">        its advertising interfaces.  Outgoing Router Advertisements are filled</span>
<a name="l01061"></a>01061 <span class="comment">        with the following values consistent with the message format given in</span>
<a name="l01062"></a>01062 <span class="comment">        Section 4.2:*/</span>
<a name="l01063"></a>01063 
<a name="l01064"></a>01064         <span class="comment">//- In the Router Lifetime field: the interface&apos;s configured AdvDefaultLifetime.</span>
<a name="l01065"></a>01065         ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a39678dc04c24a484eeb5b3a9f91aea4a">setRouterLifetime</a>(SIMTIME_DBL(ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a746f7532e0326a7d38c0b97811027a0f">getAdvDefaultLifetime</a>()));
<a name="l01066"></a>01066 
<a name="l01067"></a>01067         <span class="comment">//- In the M and O flags: the interface&apos;s configured AdvManagedFlag and</span>
<a name="l01068"></a>01068         <span class="comment">//AdvOtherConfigFlag, respectively.  See [ADDRCONF].</span>
<a name="l01069"></a>01069         ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#adf52056f68e2055290b2f678d6b31bc8">setManagedAddrConfFlag</a>(ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#acfc46f745ef81823d100eb3a7963a7df">getAdvManagedFlag</a>());
<a name="l01070"></a>01070         ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#ab93a8be65953973cd6069d13aec96a0d">setOtherStatefulConfFlag</a>(ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a23b961a46f005c62250e29b4aa8565b9">getAdvOtherConfigFlag</a>());
<a name="l01071"></a>01071 
<a name="l01072"></a>01072         <span class="comment">//- In the Cur Hop Limit field: the interface&apos;s configured CurHopLimit.</span>
<a name="l01073"></a>01073         ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a690d16d4ba2c5e6da777e622ed1931a2">setCurHopLimit</a>(ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a699fda5180c5b917e2263d2c9deb134c">getAdvCurHopLimit</a>());
<a name="l01074"></a>01074 
<a name="l01075"></a>01075         <span class="comment">//- In the Reachable Time field: the interface&apos;s configured AdvReachableTime.</span>
<a name="l01076"></a>01076         ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a0261460d90e4cef93a11e8cb8c291fff">setReachableTime</a>(ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a77d36585d5bdead9eef1e6d8234c3b9f">getAdvReachableTime</a>());
<a name="l01077"></a>01077 
<a name="l01078"></a>01078         <span class="comment">//- In the Retrans Timer field: the interface&apos;s configured AdvRetransTimer.</span>
<a name="l01079"></a>01079         ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a73bd2bd3a22da52c5cd402bc7cde633a">setRetransTimer</a>(ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a2ee4d58abfaeece4ac3280bb775384bd">getAdvRetransTimer</a>());
<a name="l01080"></a>01080 
<a name="l01081"></a>01081         <span class="comment">//- In the options:</span>
<a name="l01082"></a>01082         <span class="comment">/*o Source Link-Layer Address option: link-layer address of the sending</span>
<a name="l01083"></a>01083 <span class="comment">            interface.  (Assumption: We always send this)*/</span>
<a name="l01084"></a>01084         ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#afa5cca482035adcba5c7753268b58aed">setSourceLinkLayerAddress</a>(ie-&gt;<a class="code" href="class_interface_entry.html#af8004a12e9aac171699ff1f7f08ee4c4">getMacAddress</a>());
<a name="l01085"></a>01085         ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a989958494a623baccd85bb50dc85f1b3">setMTU</a>(ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#aa87caa67ed723589df2b9537bd379555">getAdvLinkMTU</a>());
<a name="l01086"></a>01086 
<a name="l01087"></a>01087         <span class="comment">//Add all Advertising Prefixes to the RA</span>
<a name="l01088"></a>01088         <span class="keywordtype">int</span> numAdvPrefixes = ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a1d84187cfbe9e91f7af79927c813f61c">getNumAdvPrefixes</a>();
<a name="l01089"></a>01089         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Number of Adv Prefixes: &quot;</span> &lt;&lt; numAdvPrefixes &lt;&lt; endl;
<a name="l01090"></a>01090         ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#ac53dcafff08880c29972a9e97cc190a1">setPrefixInformationArraySize</a>(numAdvPrefixes);
<a name="l01091"></a>01091         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numAdvPrefixes; i++)
<a name="l01092"></a>01092         {
<a name="l01093"></a>01093             <a class="code" href="struct_i_pv6_interface_data_1_1_adv_prefix.html">IPv6InterfaceData::AdvPrefix</a> advPrefix = ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a90da8f012bd443c75e6e742bcf6f7d38">getAdvPrefix</a>(i);
<a name="l01094"></a>01094             <a class="code" href="class_i_pv6_n_d_prefix_information.html">IPv6NDPrefixInformation</a> prefixInfo;
<a name="l01095"></a>01095             prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#a893113243b4b0e77907820eee3cf88e2">setPrefix</a>(advPrefix.<a class="code" href="struct_i_pv6_interface_data_1_1_adv_prefix.html#a8dbd979f7860762721b55d4793629258">prefix</a>);
<a name="l01096"></a>01096             prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#a4d76e035c7e2c841a01df0b98dd86500">setPrefixLength</a>(advPrefix.<a class="code" href="struct_i_pv6_interface_data_1_1_adv_prefix.html#a8e68016dcc5cb215199e7f61402f854b">prefixLength</a>);
<a name="l01097"></a>01097 
<a name="l01098"></a>01098             <span class="comment">//- In the &quot;on-link&quot; flag: the entry&apos;s AdvOnLinkFlag.</span>
<a name="l01099"></a>01099             prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#aa80e788d0e61e52b008e4f283d4a6fe6">setOnlinkFlag</a>(advPrefix.<a class="code" href="struct_i_pv6_interface_data_1_1_adv_prefix.html#a9c2fa49f3db59393e76c08e022c4e12c">advOnLinkFlag</a>);
<a name="l01100"></a>01100             <span class="comment">//- In the Valid Lifetime field: the entry&apos;s AdvValidLifetime.</span>
<a name="l01101"></a>01101             prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#a696a7ab600d90af60d406fdad76ffd62">setValidLifetime</a>(SIMTIME_DBL(advPrefix.<a class="code" href="struct_i_pv6_interface_data_1_1_adv_prefix.html#a8a0703cb25c21fb9db5e7a4408e40680">advValidLifetime</a>));
<a name="l01102"></a>01102             <span class="comment">//- In the &quot;Autonomous address configuration&quot; flag: the entry&apos;s</span>
<a name="l01103"></a>01103             <span class="comment">//AdvAutonomousFlag.</span>
<a name="l01104"></a>01104             prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#a5247c9a5baf068373af1fb9b50962de2">setAutoAddressConfFlag</a>(advPrefix.<a class="code" href="struct_i_pv6_interface_data_1_1_adv_prefix.html#ac593127a85f0ced6a4f8d9c0aee2184d">advAutonomousFlag</a>);
<a name="l01105"></a>01105             <span class="comment">//- In the Preferred Lifetime field: the entry&apos;s AdvPreferredLifetime.</span>
<a name="l01106"></a>01106             prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#ac8080f673ec16809812d35641f41d2ce">setPreferredLifetime</a>(SIMTIME_DBL(advPrefix.<a class="code" href="struct_i_pv6_interface_data_1_1_adv_prefix.html#a0df07072856386db3465443deffacd6f">advPreferredLifetime</a>));
<a name="l01107"></a>01107             <span class="comment">//Now we pop the prefix info into the RA.</span>
<a name="l01108"></a>01108             ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a5b27daa3e1f7131ce8bd378737a8edcb">setPrefixInformation</a>(i, prefixInfo);
<a name="l01109"></a>01109         }
<a name="l01110"></a>01110         <a class="code" href="class_i_pv6_neighbour_discovery.html#a58642b1dc383266b43abc6d6e4a74e5e">sendPacketToIPv6Module</a>(ra, destAddr, sourceAddr, ie-&gt;<a class="code" href="class_interface_entry.html#adc901fa42c37ce16b5c0785da81106ce">getInterfaceId</a>());
<a name="l01111"></a>01111         <span class="keywordflow">return</span> ra;
<a name="l01112"></a>01112     }
<a name="l01113"></a>01113     <span class="keywordflow">return</span> NULL; <span class="comment">//XXX is this OK?</span>
<a name="l01114"></a>01114 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a96fb67a2da25bbcd4b18a21a1d597fa6"></a><!-- doxytag: member="IPv6NeighbourDiscovery::createAndSendRedirectPacket" ref="a96fb67a2da25bbcd4b18a21a1d597fa6" args="(InterfaceEntry *ie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_pv6_redirect.html">IPv6Redirect</a> * IPv6NeighbourDiscovery::createAndSendRedirectPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&nbsp;</td>
          <td class="paramname"> <em>ie</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l02125">2125</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02126"></a>02126 {
<a name="l02127"></a>02127     <span class="comment">//Construct a Redirect message</span>
<a name="l02128"></a>02128     <a class="code" href="class_i_pv6_redirect.html">IPv6Redirect</a> *redirect = <span class="keyword">new</span> <a class="code" href="class_i_pv6_redirect.html">IPv6Redirect</a>(<span class="stringliteral">&quot;redirectMsg&quot;</span>);
<a name="l02129"></a>02129     redirect-&gt;<a class="code" href="class_i_c_m_pv6_message.html#a0d30a321ffafbc6af65fcafac9165a14">setType</a>(<a class="code" href="_i_c_m_pv6_message__m_8h.html#a007402fd73fa0142d3b888578b1280f8ac60a8328fb5c35a24712bcb9476f0203">ICMPv6_REDIRECT</a>);
<a name="l02130"></a>02130 
<a name="l02131"></a>02131     <span class="comment">//Redirect Message Specific Information</span>
<a name="l02132"></a>02132     <span class="comment">//redirect-&gt;setTargetAddress();</span>
<a name="l02133"></a>02133     <span class="comment">//redirect-&gt;setDestinationAddress();</span>
<a name="l02134"></a>02134 
<a name="l02135"></a>02135     <span class="comment">//Possible Option</span>
<a name="l02136"></a>02136     <span class="comment">//redirect-&gt;setTargetLinkLayerAddress();</span>
<a name="l02137"></a>02137 
<a name="l02138"></a>02138     <span class="keywordflow">return</span> redirect;
<a name="l02139"></a>02139 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a75431d6a5076b17ae0630f2fc4aa441a"></a><!-- doxytag: member="IPv6NeighbourDiscovery::createAndSendRSPacket" ref="a75431d6a5076b17ae0630f2fc4aa441a" args="(InterfaceEntry *ie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_pv6_router_solicitation.html">IPv6RouterSolicitation</a> * IPv6NeighbourDiscovery::createAndSendRSPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&nbsp;</td>
          <td class="paramname"> <em>ie</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00828">828</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00854">initiateRouterDiscovery()</a>, and <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00904">processRDTimeout()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00829"></a>00829 {
<a name="l00830"></a>00830     ASSERT(ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a3e629909076b47fa0886f83fbb7af09a">getAdvSendAdvertisements</a>() == <span class="keyword">false</span>);
<a name="l00831"></a>00831     <span class="comment">//RFC 2461: Section 6.3.7 Sending Router Solicitations</span>
<a name="l00832"></a>00832     <span class="comment">//A host sends Router Solicitations to the All-Routers multicast address. The</span>
<a name="l00833"></a>00833     <span class="comment">//IP source address is set to either one of the interface&apos;s unicast addresses</span>
<a name="l00834"></a>00834     <span class="comment">//or the unspecified address.</span>
<a name="l00835"></a>00835     <a class="code" href="class_i_pv6_address.html">IPv6Address</a> myIPv6Address = ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a56f3fe4007e3df66dc88edd008f059b9">getPreferredAddress</a>();
<a name="l00836"></a>00836     <span class="keywordflow">if</span> (myIPv6Address.isUnspecified())
<a name="l00837"></a>00837         myIPv6Address = ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a3b9fa2d8e186014cf9c758e45b5a56df">getLinkLocalAddress</a>();<span class="comment">//so we use the link local address instead</span>
<a name="l00838"></a>00838     <span class="keywordflow">if</span> (ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a90fa17dc7efaa7170176e853cf32dfed">isTentativeAddress</a>(myIPv6Address))
<a name="l00839"></a>00839         myIPv6Address = <a class="code" href="class_i_pv6_address.html#a0c1e137cb3b1470ec6b8d9a95e03dbe5">IPv6Address::UNSPECIFIED_ADDRESS</a>;<span class="comment">//set my IPv6 address to unspecified.</span>
<a name="l00840"></a>00840     <a class="code" href="class_i_pv6_address.html">IPv6Address</a> destAddr = <a class="code" href="class_i_pv6_address.html#a3550339d4b3388eb3891c4744dca2aa1">IPv6Address::ALL_ROUTERS_2</a>;<span class="comment">//all_routers multicast</span>
<a name="l00841"></a>00841     <a class="code" href="class_i_pv6_router_solicitation.html">IPv6RouterSolicitation</a> *rs = <span class="keyword">new</span> <a class="code" href="class_i_pv6_router_solicitation.html">IPv6RouterSolicitation</a>(<span class="stringliteral">&quot;RSpacket&quot;</span>);
<a name="l00842"></a>00842     rs-&gt;<a class="code" href="class_i_c_m_pv6_message.html#a0d30a321ffafbc6af65fcafac9165a14">setType</a>(<a class="code" href="_i_c_m_pv6_message__m_8h.html#a007402fd73fa0142d3b888578b1280f8af937f0d524ed38f43ca7e122fe415294">ICMPv6_ROUTER_SOL</a>);
<a name="l00843"></a>00843 
<a name="l00844"></a>00844     <span class="comment">//The Source Link-Layer Address option SHOULD be set to the host&apos;s link-layer</span>
<a name="l00845"></a>00845     <span class="comment">//address, if the IP source address is not the unspecified address.</span>
<a name="l00846"></a>00846     <span class="keywordflow">if</span> (!myIPv6Address.isUnspecified())
<a name="l00847"></a>00847         rs-&gt;<a class="code" href="class_i_pv6_router_solicitation.html#a53efefd655588f25b5a50f304e2404c1">setSourceLinkLayerAddress</a>(ie-&gt;<a class="code" href="class_interface_entry.html#af8004a12e9aac171699ff1f7f08ee4c4">getMacAddress</a>());
<a name="l00848"></a>00848 
<a name="l00849"></a>00849     <span class="comment">//Construct a Router Solicitation message</span>
<a name="l00850"></a>00850     <a class="code" href="class_i_pv6_neighbour_discovery.html#a58642b1dc383266b43abc6d6e4a74e5e">sendPacketToIPv6Module</a>(rs, destAddr, myIPv6Address, ie-&gt;<a class="code" href="class_interface_entry.html#adc901fa42c37ce16b5c0785da81106ce">getInterfaceId</a>());
<a name="l00851"></a>00851     <span class="keywordflow">return</span> rs;
<a name="l00852"></a>00852 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a6e0f7e782e7b912a683c653b30e7b957"></a><!-- doxytag: member="IPv6NeighbourDiscovery::createRATimer" ref="a6e0f7e782e7b912a683c653b30e7b957" args="(InterfaceEntry *ie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPv6NeighbourDiscovery::createRATimer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&nbsp;</td>
          <td class="paramname"> <em>ie</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a timer for the given interface entry that sends periodic Router Advertisements </p>

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01440">1440</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00049">initialize()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01441"></a>01441 {
<a name="l01442"></a>01442     cMessage *msg = <span class="keyword">new</span> cMessage(<span class="stringliteral">&quot;sendPeriodicRA&quot;</span>, <a class="code" href="_i_pv6_neighbour_discovery_8cc.html#a810fd09c143fca097e7f2569c9f9b89c">MK_SEND_PERIODIC_RTRADV</a>);
<a name="l01443"></a>01443     msg-&gt;setContextPointer(ie);
<a name="l01444"></a>01444     AdvIfEntry *advIfEntry = <span class="keyword">new</span> AdvIfEntry();
<a name="l01445"></a>01445     advIfEntry-&gt;interfaceId = ie-&gt;<a class="code" href="class_interface_entry.html#adc901fa42c37ce16b5c0785da81106ce">getInterfaceId</a>();
<a name="l01446"></a>01446     advIfEntry-&gt;numRASent = 0;
<a name="l01447"></a>01447     simtime_t interval = uniform(ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a85b20115f117fb1038b72abf4ff27c51">getMinRtrAdvInterval</a>(), ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a05d2457e8285b73350353863e796954b">getMaxRtrAdvInterval</a>());
<a name="l01448"></a>01448     advIfEntry-&gt;raTimeoutMsg = msg;
<a name="l01449"></a>01449 
<a name="l01450"></a>01450     simtime_t nextScheduledTime = simTime() + interval;
<a name="l01451"></a>01451     advIfEntry-&gt;nextScheduledRATime = nextScheduledTime;
<a name="l01452"></a>01452     <a class="code" href="class_i_pv6_neighbour_discovery.html#a868ef2afa69950bd536b1fb5cd10569a">advIfList</a>.insert(advIfEntry);
<a name="l01453"></a>01453     <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Interval: &quot;</span> &lt;&lt; interval &lt;&lt; endl;
<a name="l01454"></a>01454     <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Next scheduled time: &quot;</span> &lt;&lt; nextScheduledTime &lt;&lt; endl;
<a name="l01455"></a>01455     <span class="comment">//now we schedule the msg for whatever time that was derived</span>
<a name="l01456"></a>01456     scheduleAt(nextScheduledTime, msg);
<a name="l01457"></a>01457 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a4bddad274cd8eb1472d37ddcd559c629"></a><!-- doxytag: member="IPv6NeighbourDiscovery::determineNextHop" ref="a4bddad274cd8eb1472d37ddcd559c629" args="(const IPv6Address &amp;destAddr, int &amp;outIfID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_pv6_address.html">IPv6Address</a> IPv6NeighbourDiscovery::determineNextHop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>destAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>outIfID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function accepts the datagram's destination address and attempts to determine the destination's next hop address and interface ID by: (1) looking up the destination cache, (2)looking up the routing table, or (3) selecting a default router. It then updates the destination cache. If no default router can be selected than we assume the destination address to be onlink and simply return any available interface. </p>

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00381">381</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00185">processIPv6Datagram()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00383"></a>00383 {
<a name="l00384"></a>00384     <a class="code" href="class_i_pv6_address.html">IPv6Address</a> nextHopAddr;
<a name="l00385"></a>00385 
<a name="l00386"></a>00386     <span class="comment">//RFC 2461 Section 5.2</span>
<a name="l00387"></a>00387     <span class="comment">//Next-hop determination for a given unicast destination operates as follows.</span>
<a name="l00388"></a>00388 
<a name="l00389"></a>00389     <span class="comment">//The sender performs a longest prefix match against the Prefix List to</span>
<a name="l00390"></a>00390     <span class="comment">//determine whether the packet&apos;s destination is on- or off-link.</span>
<a name="l00391"></a>00391     <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Find out if supplied dest addr is on-link or off-link.\n&quot;</span>;
<a name="l00392"></a>00392     <span class="keyword">const</span> <a class="code" href="class_i_pv6_route.html">IPv6Route</a> *route = <a class="code" href="class_i_pv6_neighbour_discovery.html#a0f6a26512cd490f5a09e9bd7ec3bf61f">rt6</a>-&gt;<a class="code" href="class_routing_table6.html#aa3ba1d17dc59f3e5d77ead359dd3a999">doLongestPrefixMatch</a>(destAddr);
<a name="l00393"></a>00393 
<a name="l00394"></a>00394     <span class="keywordflow">if</span> (route != NULL)
<a name="l00395"></a>00395     {
<a name="l00396"></a>00396         <span class="comment">//If the destination is on-link, the next-hop address is the same as the</span>
<a name="l00397"></a>00397         <span class="comment">//packet&apos;s destination address.</span>
<a name="l00398"></a>00398         <span class="keywordflow">if</span> (route-&gt;<a class="code" href="class_i_pv6_route.html#abdc06722ce1f1af7236ee2c37fcfa132">getNextHop</a>().<a class="code" href="class_i_pv6_address.html#af526cffcc3a4aa5bb96d307de6e8d448">isUnspecified</a>())
<a name="l00399"></a>00399         {
<a name="l00400"></a>00400             <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Dest is on-link, next-hop addr is same as dest addr.\n&quot;</span>;
<a name="l00401"></a>00401             outIfID = route-&gt;<a class="code" href="class_i_pv6_route.html#adbdd6910c92deca3571fa8e5cd27baf8">getInterfaceId</a>();
<a name="l00402"></a>00402             nextHopAddr = destAddr;
<a name="l00403"></a>00403         }
<a name="l00404"></a>00404         <span class="keywordflow">else</span>
<a name="l00405"></a>00405         {
<a name="l00406"></a>00406             <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;A next-hop address was found with the route, dest is off-link\n&quot;</span>;
<a name="l00407"></a>00407             <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Assume next-hop address as the selected default router.\n&quot;</span>;
<a name="l00408"></a>00408             outIfID = route-&gt;<a class="code" href="class_i_pv6_route.html#adbdd6910c92deca3571fa8e5cd27baf8">getInterfaceId</a>();
<a name="l00409"></a>00409             nextHopAddr = route-&gt;<a class="code" href="class_i_pv6_route.html#abdc06722ce1f1af7236ee2c37fcfa132">getNextHop</a>();
<a name="l00410"></a>00410         }
<a name="l00411"></a>00411     }
<a name="l00412"></a>00412     <span class="keywordflow">else</span>
<a name="l00413"></a>00413     {
<a name="l00414"></a>00414         <span class="comment">//Otherwise, the sender selects a router from the Default Router List</span>
<a name="l00415"></a>00415         <span class="comment">//(following the rules described in Section 6.3.6).</span>
<a name="l00416"></a>00416 
<a name="l00417"></a>00417         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;No routes were found, Dest addr is off-link.\n&quot;</span>;
<a name="l00418"></a>00418         nextHopAddr = <a class="code" href="class_i_pv6_neighbour_discovery.html#a9f6c83de24b3e270c3843cc213b5250a">selectDefaultRouter</a>(outIfID);
<a name="l00419"></a>00419 
<a name="l00420"></a>00420         <span class="keywordflow">if</span> (outIfID == -1) <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;No Default Routers were found.&quot;</span>;
<a name="l00421"></a>00421         <span class="keywordflow">else</span> <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Default router found.\n&quot;</span>;
<a name="l00422"></a>00422     }
<a name="l00423"></a>00423 
<a name="l00424"></a>00424     <span class="comment">/*the results of next-hop determination computations are saved in the Destination</span>
<a name="l00425"></a>00425 <span class="comment">    Cache (which also contains updates learned from Redirect messages).*/</span>
<a name="l00426"></a>00426     <a class="code" href="class_i_pv6_neighbour_discovery.html#a0f6a26512cd490f5a09e9bd7ec3bf61f">rt6</a>-&gt;<a class="code" href="class_routing_table6.html#a0b95d2a43a904e2cae8521bebe8b3335">updateDestCache</a>(destAddr, nextHopAddr, outIfID);
<a name="l00427"></a>00427     <span class="keywordflow">return</span> nextHopAddr;
<a name="l00428"></a>00428 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a888724269369dc1aa87aa73586216b8c"></a><!-- doxytag: member="IPv6NeighbourDiscovery::dropQueuedPacketsAwaitingAR" ref="a888724269369dc1aa87aa73586216b8c" args="(Neighbour *nce)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPv6NeighbourDiscovery::dropQueuedPacketsAwaitingAR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html">Neighbour</a> *&nbsp;</td>
          <td class="paramname"> <em>nce</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Drops specific queued packets for a specific NCE AR-timeout. TODO: Not implemented yet! </p>

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00670">670</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00646">processARTimeout()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00671"></a>00671 {
<a name="l00672"></a>00672     <span class="keyword">const</span> <a class="code" href="class_i_pv6_neighbour_discovery.html#a747705ed3b49881e2d144e2d9f0c8044">Key</a> *nceKey = nce-&gt;nceKey;
<a name="l00673"></a>00673     <span class="comment">//RFC 2461: Section 7.2.2</span>
<a name="l00674"></a>00674     <span class="comment">/*If no Neighbor Advertisement is received after MAX_MULTICAST_SOLICIT</span>
<a name="l00675"></a>00675 <span class="comment">    solicitations, address resolution has failed. The sender MUST return ICMP</span>
<a name="l00676"></a>00676 <span class="comment">    destination unreachable indications with code 3 (Address Unreachable) for</span>
<a name="l00677"></a>00677 <span class="comment">    each packet queued awaiting address resolution.*/</span>
<a name="l00678"></a>00678     <a class="code" href="class_i_pv6_neighbour_discovery.html#a0e2372b38f3787dd836bcee6b77eb268">MsgPtrVector</a> pendingPackets = nce-&gt;pendingPackets;
<a name="l00679"></a>00679     <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Pending Packets empty:&quot;</span> &lt;&lt; pendingPackets.empty() &lt;&lt; endl;
<a name="l00680"></a>00680     <span class="keywordflow">while</span> (!pendingPackets.empty())
<a name="l00681"></a>00681     {
<a name="l00682"></a>00682         MsgPtrVector::iterator i = pendingPackets.begin();
<a name="l00683"></a>00683         cMessage *msg = (*i);
<a name="l00684"></a>00684         <a class="code" href="class_i_pv6_datagram.html">IPv6Datagram</a> *ipv6Msg = (<a class="code" href="class_i_pv6_datagram.html">IPv6Datagram</a> *)msg;
<a name="l00685"></a>00685         <span class="comment">//Assume msg is the packet itself. I need the datagram&apos;s source addr.</span>
<a name="l00686"></a>00686         <span class="comment">//The datagram&apos;s src addr will be the destination of the unreachable msg.</span>
<a name="l00687"></a>00687         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Sending ICMP unreachable destination.&quot;</span> &lt;&lt; endl;
<a name="l00688"></a>00688         pendingPackets.erase(i);
<a name="l00689"></a>00689         <a class="code" href="class_i_pv6_neighbour_discovery.html#a8cebccf199f96d0903c4663b203199ca">pendingQueue</a>.remove(msg);
<a name="l00690"></a>00690         <a class="code" href="class_i_pv6_neighbour_discovery.html#a78cfa038ef771566c18a2eec28fd740b">icmpv6</a>-&gt;<a class="code" href="class_i_c_m_pv6.html#a3968b2c9964bb40a3d14b3fda9fdbba5">sendErrorMessage</a>(ipv6Msg, <a class="code" href="_i_c_m_pv6_message__m_8h.html#a007402fd73fa0142d3b888578b1280f8a41a9a5f4838bc4483b77b0fdcd13f72b">ICMPv6_DESTINATION_UNREACHABLE</a>, <a class="code" href="_i_c_m_pv6_message__m_8h.html#a0de5d721e9e426e7acecf6830de1331fa91cfe5d64331066d0fe0df66b9fa9442">ADDRESS_UNREACHABLE</a>);
<a name="l00691"></a>00691     }
<a name="l00692"></a>00692 
<a name="l00693"></a>00693     <span class="comment">//RFC 2461: Section 7.3.3</span>
<a name="l00694"></a>00694     <span class="comment">/*If address resolution fails, the entry SHOULD be deleted, so that subsequent</span>
<a name="l00695"></a>00695 <span class="comment">    traffic to that neighbor invokes the next-hop determination procedure again.*/</span>
<a name="l00696"></a>00696     <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Removing neighbour cache entry&quot;</span> &lt;&lt; endl;
<a name="l00697"></a>00697     <a class="code" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">neighbourCache</a>.<a class="code" href="class_i_pv6_neighbour_cache.html#a877bc367ca422baabc22199c5036df83">remove</a>(nceKey-&gt;address, nceKey-&gt;interfaceID);
<a name="l00698"></a>00698 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a44d5adf445298a56e275377d70d620ef"></a><!-- doxytag: member="IPv6NeighbourDiscovery::fetchAdvIfEntry" ref="a44d5adf445298a56e275377d70d620ef" args="(InterfaceEntry *ie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_i_pv6_neighbour_discovery_1_1_adv_if_entry.html">IPv6NeighbourDiscovery::AdvIfEntry</a> * IPv6NeighbourDiscovery::fetchAdvIfEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&nbsp;</td>
          <td class="paramname"> <em>ie</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00260">260</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00935">processRSPacket()</a>, and <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01480">sendPeriodicRA()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00261"></a>00261 {
<a name="l00262"></a>00262    <span class="keywordflow">for</span> (AdvIfList::iterator it=<a class="code" href="class_i_pv6_neighbour_discovery.html#a868ef2afa69950bd536b1fb5cd10569a">advIfList</a>.begin(); it!=<a class="code" href="class_i_pv6_neighbour_discovery.html#a868ef2afa69950bd536b1fb5cd10569a">advIfList</a>.end(); it++)
<a name="l00263"></a>00263    {
<a name="l00264"></a>00264        AdvIfEntry *advIfEntry = (*it);
<a name="l00265"></a>00265        <span class="keywordflow">if</span> (advIfEntry-&gt;interfaceId == ie-&gt;<a class="code" href="class_interface_entry.html#adc901fa42c37ce16b5c0785da81106ce">getInterfaceId</a>())
<a name="l00266"></a>00266        {
<a name="l00267"></a>00267            <span class="keywordflow">return</span> advIfEntry;
<a name="l00268"></a>00268        }
<a name="l00269"></a>00269    }
<a name="l00270"></a>00270    <span class="keywordflow">return</span> NULL;
<a name="l00271"></a>00271 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ab83db378f6596fd37ab6657b13707aa4"></a><!-- doxytag: member="IPv6NeighbourDiscovery::fetchRDEntry" ref="ab83db378f6596fd37ab6657b13707aa4" args="(InterfaceEntry *ie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_i_pv6_neighbour_discovery_1_1_r_d_entry.html">IPv6NeighbourDiscovery::RDEntry</a> * IPv6NeighbourDiscovery::fetchRDEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&nbsp;</td>
          <td class="paramname"> <em>ie</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00273">273</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00889">cancelRouterDiscovery()</a>, and <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00904">processRDTimeout()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00274"></a>00274 {
<a name="l00275"></a>00275    <span class="keywordflow">for</span> (RDList::iterator it=<a class="code" href="class_i_pv6_neighbour_discovery.html#a7f075a086f580756337ef6f59223727c">rdList</a>.begin(); it!=<a class="code" href="class_i_pv6_neighbour_discovery.html#a7f075a086f580756337ef6f59223727c">rdList</a>.end(); it++)
<a name="l00276"></a>00276    {
<a name="l00277"></a>00277        RDEntry *rdEntry = (*it);
<a name="l00278"></a>00278        <span class="keywordflow">if</span> (rdEntry-&gt;interfaceId == ie-&gt;<a class="code" href="class_interface_entry.html#adc901fa42c37ce16b5c0785da81106ce">getInterfaceId</a>())
<a name="l00279"></a>00279        {
<a name="l00280"></a>00280            <span class="keywordflow">return</span> rdEntry;
<a name="l00281"></a>00281        }
<a name="l00282"></a>00282    }
<a name="l00283"></a>00283    <span class="keywordflow">return</span> NULL;
<a name="l00284"></a>00284 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a9c9fcb239e93ed948efb3a946379a3d2"></a><!-- doxytag: member="IPv6NeighbourDiscovery::finish" ref="a9c9fcb239e93ed948efb3a946379a3d2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPv6NeighbourDiscovery::finish </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00181">181</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00182"></a>00182 {
<a name="l00183"></a>00183 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad90a981569779940aaffe6df55b6285b"></a><!-- doxytag: member="IPv6NeighbourDiscovery::handleMessage" ref="ad90a981569779940aaffe6df55b6285b" args="(cMessage *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPv6NeighbourDiscovery::handleMessage </td>
          <td>(</td>
          <td class="paramtype">cMessage *&nbsp;</td>
          <td class="paramname"> <em>msg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00081">81</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00082"></a>00082 {
<a name="l00083"></a>00083     <span class="keywordflow">if</span> (msg-&gt;isSelfMessage())
<a name="l00084"></a>00084     {
<a name="l00085"></a>00085         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Self message received!\n&quot;</span>;
<a name="l00086"></a>00086         <span class="keywordflow">if</span> (msg-&gt;getKind()==<a class="code" href="_i_pv6_neighbour_discovery_8cc.html#a810fd09c143fca097e7f2569c9f9b89c">MK_SEND_PERIODIC_RTRADV</a>)
<a name="l00087"></a>00087         {
<a name="l00088"></a>00088             <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Sending periodic RA\n&quot;</span>;
<a name="l00089"></a>00089             <a class="code" href="class_i_pv6_neighbour_discovery.html#a7ab6b1fc3d01da2bc31d772a31013e08">sendPeriodicRA</a>(msg);
<a name="l00090"></a>00090         }
<a name="l00091"></a>00091         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (msg-&gt;getKind()==<a class="code" href="_i_pv6_neighbour_discovery_8cc.html#ab76c2fe672ed307b0a91f9efa35a7548">MK_SEND_SOL_RTRADV</a>)
<a name="l00092"></a>00092         {
<a name="l00093"></a>00093             <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Sending solicited RA\n&quot;</span>;
<a name="l00094"></a>00094             <a class="code" href="class_i_pv6_neighbour_discovery.html#a32ed95da45989efe4509946492299d34">sendSolicitedRA</a>(msg);
<a name="l00095"></a>00095         }
<a name="l00096"></a>00096         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (msg-&gt;getKind()==<a class="code" href="_i_pv6_neighbour_discovery_8cc.html#aed4b9313083f229d6a498c6c337f931e">MK_ASSIGN_LINKLOCAL_ADDRESS</a>)
<a name="l00097"></a>00097         {
<a name="l00098"></a>00098             <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Assigning Link Local Address\n&quot;</span>;
<a name="l00099"></a>00099             <a class="code" href="class_i_pv6_neighbour_discovery.html#a5438ceb3077ec49d9b393136a9a5e768">assignLinkLocalAddress</a>(msg);
<a name="l00100"></a>00100         }
<a name="l00101"></a>00101         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (msg-&gt;getKind()==<a class="code" href="_i_pv6_neighbour_discovery_8cc.html#a81f972006a357c3ddda2dfcfd7469015">MK_DAD_TIMEOUT</a>)
<a name="l00102"></a>00102         {
<a name="l00103"></a>00103             <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;DAD Timeout message received\n&quot;</span>;
<a name="l00104"></a>00104             <a class="code" href="class_i_pv6_neighbour_discovery.html#a13117cd0ac035e0a0fd198d872b209c3">processDADTimeout</a>(msg);
<a name="l00105"></a>00105         }
<a name="l00106"></a>00106         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (msg-&gt;getKind()==<a class="code" href="_i_pv6_neighbour_discovery_8cc.html#a9f894036bf61bbc51aa7a8560db5a30e">MK_RD_TIMEOUT</a>)
<a name="l00107"></a>00107         {
<a name="l00108"></a>00108             <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Router Discovery message received\n&quot;</span>;
<a name="l00109"></a>00109             <a class="code" href="class_i_pv6_neighbour_discovery.html#a860a64e4fbb311fef343ec7044c0a10b">processRDTimeout</a>(msg);
<a name="l00110"></a>00110         }
<a name="l00111"></a>00111         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (msg-&gt;getKind()==<a class="code" href="_i_pv6_neighbour_discovery_8cc.html#aadba1232289c7af8c42ae503b367f409">MK_INITIATE_RTRDIS</a>)
<a name="l00112"></a>00112         {
<a name="l00113"></a>00113             <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;initiate router discovery.\n&quot;</span>;
<a name="l00114"></a>00114             <a class="code" href="class_i_pv6_neighbour_discovery.html#a53cb1f954b65272ad826f3daaec29136">initiateRouterDiscovery</a>(msg);
<a name="l00115"></a>00115         }
<a name="l00116"></a>00116         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (msg-&gt;getKind()==<a class="code" href="_i_pv6_neighbour_discovery_8cc.html#a817ccecd04135b6f9307b110598e476e">MK_NUD_TIMEOUT</a>)
<a name="l00117"></a>00117         {
<a name="l00118"></a>00118             <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;NUD Timeout message received\n&quot;</span>;
<a name="l00119"></a>00119             <a class="code" href="class_i_pv6_neighbour_discovery.html#a623b4069795d46d2b421d5aee4f1eb59">processNUDTimeout</a>(msg);
<a name="l00120"></a>00120         }
<a name="l00121"></a>00121         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (msg-&gt;getKind()==<a class="code" href="_i_pv6_neighbour_discovery_8cc.html#a3599ccb8ab8108c0d27c47561d6f93e3">MK_AR_TIMEOUT</a>)
<a name="l00122"></a>00122         {
<a name="l00123"></a>00123             <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Address Resolution Timeout message received\n&quot;</span>;
<a name="l00124"></a>00124             <a class="code" href="class_i_pv6_neighbour_discovery.html#a61e880bea24c63e2661d2722077ac172">processARTimeout</a>(msg);
<a name="l00125"></a>00125         }
<a name="l00126"></a>00126         <span class="keywordflow">else</span>
<a name="l00127"></a>00127             error(<span class="stringliteral">&quot;Unrecognized Timer&quot;</span>);<span class="comment">//stops sim w/ error msg.</span>
<a name="l00128"></a>00128     }
<a name="l00129"></a>00129     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dynamic_cast&lt;ICMPv6Message *&gt;(msg))
<a name="l00130"></a>00130     {
<a name="l00131"></a>00131         <span class="comment">//This information will serve as input parameters to various processors.</span>
<a name="l00132"></a>00132         <a class="code" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *ctrlInfo
<a name="l00133"></a>00133             = check_and_cast&lt;<a class="code" href="class_i_pv6_control_info.html">IPv6ControlInfo</a>*&gt;(msg-&gt;removeControlInfo());
<a name="l00134"></a>00134         <a class="code" href="class_i_c_m_pv6_message.html">ICMPv6Message</a> *ndMsg = (<a class="code" href="class_i_c_m_pv6_message.html">ICMPv6Message</a> *)msg;
<a name="l00135"></a>00135         <a class="code" href="class_i_pv6_neighbour_discovery.html#a7662f293fab21a873bb22edab70de5ce">processNDMessage</a>(ndMsg, ctrlInfo);
<a name="l00136"></a>00136     }
<a name="l00137"></a>00137     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dynamic_cast&lt;IPv6Datagram *&gt;(msg))<span class="comment">// not ND message</span>
<a name="l00138"></a>00138     {
<a name="l00139"></a>00139         <a class="code" href="class_i_pv6_datagram.html">IPv6Datagram</a> *datagram = (<a class="code" href="class_i_pv6_datagram.html">IPv6Datagram</a> *)msg;
<a name="l00140"></a>00140         <a class="code" href="class_i_pv6_neighbour_discovery.html#ade69131623bc5b13205ced3ff54a16d3">processIPv6Datagram</a>(datagram);
<a name="l00141"></a>00141     }
<a name="l00142"></a>00142     <span class="keywordflow">else</span>
<a name="l00143"></a>00143         error(<span class="stringliteral">&quot;Unknown message type received.\n&quot;</span>);
<a name="l00144"></a>00144 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a6855729184a9f8c2e0072f6773f5e96c"></a><!-- doxytag: member="IPv6NeighbourDiscovery::initialize" ref="a6855729184a9f8c2e0072f6773f5e96c" args="(int stage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPv6NeighbourDiscovery::initialize </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>stage</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00049">49</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00050"></a>00050 {
<a name="l00051"></a>00051     <span class="comment">// We have to wait until the 3rd stage (stage 2) with scheduling messages,</span>
<a name="l00052"></a>00052     <span class="comment">// because interface registration and IPv6 configuration takes places</span>
<a name="l00053"></a>00053     <span class="comment">// in the first two stages.</span>
<a name="l00054"></a>00054     <span class="keywordflow">if</span> (stage==3)
<a name="l00055"></a>00055     {
<a name="l00056"></a>00056         <a class="code" href="class_i_pv6_neighbour_discovery.html#a4b4f35b761b93c397e2a5a36c1e08d38">ift</a> = <a class="code" href="class_interface_table_access.html">InterfaceTableAccess</a>().get();
<a name="l00057"></a>00057         <a class="code" href="class_i_pv6_neighbour_discovery.html#a0f6a26512cd490f5a09e9bd7ec3bf61f">rt6</a> = <a class="code" href="class_routing_table6_access.html">RoutingTable6Access</a>().get();
<a name="l00058"></a>00058         <a class="code" href="class_i_pv6_neighbour_discovery.html#a78cfa038ef771566c18a2eec28fd740b">icmpv6</a> = <a class="code" href="class_i_c_m_pv6_access.html">ICMPv6Access</a>().get();
<a name="l00059"></a>00059         <a class="code" href="class_i_pv6_neighbour_discovery.html#a8cebccf199f96d0903c4663b203199ca">pendingQueue</a>.setName(<span class="stringliteral">&quot;pendingQueue&quot;</span>);
<a name="l00060"></a>00060 
<a name="l00061"></a>00061         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; <a class="code" href="class_i_pv6_neighbour_discovery.html#a4b4f35b761b93c397e2a5a36c1e08d38">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a2b0ce46cd92da6f64fc363410dc71904">getNumInterfaces</a>(); i++)
<a name="l00062"></a>00062         {
<a name="l00063"></a>00063             <a class="code" href="class_interface_entry.html">InterfaceEntry</a> *ie = <a class="code" href="class_i_pv6_neighbour_discovery.html#a4b4f35b761b93c397e2a5a36c1e08d38">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a19ce4ca3b47b52b8e2b67c25806c4b49">getInterface</a>(i);
<a name="l00064"></a>00064 
<a name="l00065"></a>00065             <span class="keywordflow">if</span> (ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a3e629909076b47fa0886f83fbb7af09a">getAdvSendAdvertisements</a>() &amp;&amp; !(ie-&gt;<a class="code" href="class_interface_entry.html#a0ee93e88273f61390d1293dae55004d1">isLoopback</a>()))
<a name="l00066"></a>00066             {
<a name="l00067"></a>00067                 <a class="code" href="class_i_pv6_neighbour_discovery.html#a6e0f7e782e7b912a683c653b30e7b957">createRATimer</a>(ie);
<a name="l00068"></a>00068             }
<a name="l00069"></a>00069         }
<a name="l00070"></a>00070         <span class="comment">//This simulates random node bootup time. Link local address assignment</span>
<a name="l00071"></a>00071         <span class="comment">//takes place during this time.</span>
<a name="l00072"></a>00072         cMessage *msg = <span class="keyword">new</span> cMessage(<span class="stringliteral">&quot;assignLinkLocalAddr&quot;</span>, <a class="code" href="_i_pv6_neighbour_discovery_8cc.html#aed4b9313083f229d6a498c6c337f931e">MK_ASSIGN_LINKLOCAL_ADDRESS</a>);
<a name="l00073"></a>00073         <span class="comment">//We want routers to boot up faster!</span>
<a name="l00074"></a>00074         <span class="keywordflow">if</span> (<a class="code" href="class_i_pv6_neighbour_discovery.html#a0f6a26512cd490f5a09e9bd7ec3bf61f">rt6</a>-&gt;<a class="code" href="class_routing_table6.html#a79a742fa2d94543412e183ebe0e83d3a">isRouter</a>())
<a name="l00075"></a>00075             scheduleAt(uniform(0,0.3), msg);<span class="comment">//Random Router bootup time</span>
<a name="l00076"></a>00076         <span class="keywordflow">else</span>
<a name="l00077"></a>00077             scheduleAt(uniform(0.4,1), msg);<span class="comment">//Random Host bootup time</span>
<a name="l00078"></a>00078     }
<a name="l00079"></a>00079 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a6afff1bf1db0e7b69f3f6782a87b5b82"></a><!-- doxytag: member="IPv6NeighbourDiscovery::initiateAddressResolution" ref="a6afff1bf1db0e7b69f3f6782a87b5b82" args="(const IPv6Address &amp;dgSrcAddr, Neighbour *nce)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPv6NeighbourDiscovery::initiateAddressResolution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dgSrcAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html">Neighbour</a> *&nbsp;</td>
          <td class="paramname"> <em>nce</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method attempts to resolve the given neighbour's link-layer address. The source address of the packet prompting address resolution is also given in order to decide the source address of the NS to be sent. nceKey stores 2 pieces of information (Neighbour address and Interface ID) which is needed for addr resolution and access to the corresponding nce. </p>

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00593">593</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00185">processIPv6Datagram()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00595"></a>00595 {
<a name="l00596"></a>00596     <span class="keyword">const</span> <a class="code" href="class_i_pv6_neighbour_discovery.html#a747705ed3b49881e2d144e2d9f0c8044">Key</a> *nceKey = nce-&gt;nceKey;
<a name="l00597"></a>00597     <a class="code" href="class_interface_entry.html">InterfaceEntry</a> *ie = <a class="code" href="class_i_pv6_neighbour_discovery.html#a4b4f35b761b93c397e2a5a36c1e08d38">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a92764d620c345b7261de20e9ee5247d7">getInterfaceById</a>(nceKey-&gt;interfaceID);
<a name="l00598"></a>00598     <a class="code" href="class_i_pv6_address.html">IPv6Address</a> neighbourAddr = nceKey-&gt;address;
<a name="l00599"></a>00599     <span class="keywordtype">int</span> ifID = nceKey-&gt;interfaceID;
<a name="l00600"></a>00600 
<a name="l00601"></a>00601     <span class="comment">//RFC2461: Section 7.2.2</span>
<a name="l00602"></a>00602     <span class="comment">//When a node has a unicast packet to send to a neighbor, but does not</span>
<a name="l00603"></a>00603     <span class="comment">//know the neighbor&apos;s link-layer address, it performs address</span>
<a name="l00604"></a>00604     <span class="comment">//resolution.  For multicast-capable interfaces this entails creating a</span>
<a name="l00605"></a>00605     <span class="comment">//Neighbor Cache entry in the INCOMPLETE state(already created if not done yet)</span>
<a name="l00606"></a>00606     <span class="comment">//WEI-If entry already exists, we still have to ensure that its state is INCOMPLETE.</span>
<a name="l00607"></a>00607     nce-&gt;reachabilityState = <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1ac2cfd6c9d21c7d34d2f6f53d6cfe6638">IPv6NeighbourCache::INCOMPLETE</a>;
<a name="l00608"></a>00608 
<a name="l00609"></a>00609     <span class="comment">//and transmitting a Neighbor Solicitation message targeted at the</span>
<a name="l00610"></a>00610     <span class="comment">//neighbor.  The solicitation is sent to the solicited-node multicast</span>
<a name="l00611"></a>00611     <span class="comment">//address &quot;corresponding to&quot;(or &quot;derived from&quot;) the target address.</span>
<a name="l00612"></a>00612     <span class="comment">//(in this case, the target address is the address we are trying to resolve)</span>
<a name="l00613"></a>00613     <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Preparing to send NS to solicited-node multicast group\n&quot;</span>;
<a name="l00614"></a>00614     <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;on the next hop interface\n&quot;</span>;
<a name="l00615"></a>00615     <a class="code" href="class_i_pv6_address.html">IPv6Address</a> nsDestAddr = neighbourAddr.<a class="code" href="class_i_pv6_address.html#ab135c68c866eb93e17b4a8b070abf750">formSolicitedNodeMulticastAddress</a>();<span class="comment">//for NS datagram</span>
<a name="l00616"></a>00616     <a class="code" href="class_i_pv6_address.html">IPv6Address</a> nsTargetAddr = neighbourAddr;<span class="comment">//for the field within the NS</span>
<a name="l00617"></a>00617     <a class="code" href="class_i_pv6_address.html">IPv6Address</a> nsSrcAddr;
<a name="l00618"></a>00618 
<a name="l00619"></a>00619     <span class="comment">/*If the source address of the packet prompting the solicitation is the</span>
<a name="l00620"></a>00620 <span class="comment">    same as one of the addresses assigned to the outgoing interface,*/</span>
<a name="l00621"></a>00621     <span class="keywordflow">if</span> (ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#af4856e5c4da3563e03fbc388db63ba8a">hasAddress</a>(dgSrcAddr))
<a name="l00622"></a>00622         <span class="comment">/*that address SHOULD be placed in the IP Source Address of the outgoing</span>
<a name="l00623"></a>00623 <span class="comment">        solicitation.*/</span>
<a name="l00624"></a>00624         nsSrcAddr = dgSrcAddr;
<a name="l00625"></a>00625     <span class="keywordflow">else</span>
<a name="l00626"></a>00626         <span class="comment">/*Otherwise, any one of the addresses assigned to the interface</span>
<a name="l00627"></a>00627 <span class="comment">        should be used.*/</span>
<a name="l00628"></a>00628         nsSrcAddr = ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a56f3fe4007e3df66dc88edd008f059b9">getPreferredAddress</a>();
<a name="l00629"></a>00629     ASSERT(ifID != -1);
<a name="l00630"></a>00630     <span class="comment">//Sending NS on specified interface.</span>
<a name="l00631"></a>00631     <a class="code" href="class_i_pv6_neighbour_discovery.html#aedad2b550812f9be54ab691296e5876d">createAndSendNSPacket</a>(nsTargetAddr, nsDestAddr, nsSrcAddr, ie);
<a name="l00632"></a>00632     nce-&gt;numOfARNSSent = 1;
<a name="l00633"></a>00633     nce-&gt;nsSrcAddr = nsSrcAddr;
<a name="l00634"></a>00634 
<a name="l00635"></a>00635     <span class="comment">/*While awaiting a response, the sender SHOULD retransmit Neighbor Solicitation</span>
<a name="l00636"></a>00636 <span class="comment">    messages approximately every RetransTimer milliseconds, even in the absence</span>
<a name="l00637"></a>00637 <span class="comment">    of additional traffic to the neighbor. Retransmissions MUST be rate-limited</span>
<a name="l00638"></a>00638 <span class="comment">    to at most one solicitation per neighbor every RetransTimer milliseconds.*/</span>
<a name="l00639"></a>00639     cMessage *msg = <span class="keyword">new</span> cMessage(<span class="stringliteral">&quot;arTimeout&quot;</span>, <a class="code" href="_i_pv6_neighbour_discovery_8cc.html#a3599ccb8ab8108c0d27c47561d6f93e3">MK_AR_TIMEOUT</a>);<span class="comment">//AR msg timer</span>
<a name="l00640"></a>00640     nce-&gt;arTimer = msg;
<a name="l00641"></a>00641     msg-&gt;setContextPointer(nce);
<a name="l00642"></a>00642     scheduleAt(simTime()+ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a089952430501d3e7a4f82481caf8be61">_getRetransTimer</a>(), msg);
<a name="l00643"></a>00643 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aab8e413cb12b66797d5e497f9fe6fddd"></a><!-- doxytag: member="IPv6NeighbourDiscovery::initiateDAD" ref="aab8e413cb12b66797d5e497f9fe6fddd" args="(const IPv6Address &amp;tentativeAddr, InterfaceEntry *ie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPv6NeighbourDiscovery::initiateDAD </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tentativeAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&nbsp;</td>
          <td class="paramname"> <em>ie</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initiating DAD means to send off a Neighbour Solicitation with its target address set as this node's tentative link-local address. </p>

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00756">756</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00730">assignLinkLocalAddress()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00758"></a>00758 {
<a name="l00759"></a>00759     DADEntry *dadEntry = <span class="keyword">new</span> DADEntry();
<a name="l00760"></a>00760     dadEntry-&gt;interfaceId = ie-&gt;<a class="code" href="class_interface_entry.html#adc901fa42c37ce16b5c0785da81106ce">getInterfaceId</a>();
<a name="l00761"></a>00761     dadEntry-&gt;address = tentativeAddr;
<a name="l00762"></a>00762     dadEntry-&gt;numNSSent = 0;
<a name="l00763"></a>00763     <a class="code" href="class_i_pv6_neighbour_discovery.html#a750d70366700481befd66c567d420a7e">dadList</a>.insert(dadEntry);
<a name="l00764"></a>00764     <span class="comment">/*</span>
<a name="l00765"></a>00765 <span class="comment">    RFC2462: Section 5.4.2</span>
<a name="l00766"></a>00766 <span class="comment">    To check an address, a node sends DupAddrDetectTransmits Neighbor</span>
<a name="l00767"></a>00767 <span class="comment">    Solicitations, each separated by RetransTimer milliseconds. The</span>
<a name="l00768"></a>00768 <span class="comment">    solicitation&apos;s Target Address is set to the address being checked,</span>
<a name="l00769"></a>00769 <span class="comment">    the IP source is set to the unspecified address and the IP</span>
<a name="l00770"></a>00770 <span class="comment">    destination is set to the solicited-node multicast address of the</span>
<a name="l00771"></a>00771 <span class="comment">    target address.*/</span>
<a name="l00772"></a>00772     <a class="code" href="class_i_pv6_address.html">IPv6Address</a> destAddr = tentativeAddr.<a class="code" href="class_i_pv6_address.html#ab135c68c866eb93e17b4a8b070abf750">formSolicitedNodeMulticastAddress</a>();
<a name="l00773"></a>00773     <span class="comment">//Send a NS</span>
<a name="l00774"></a>00774     <a class="code" href="class_i_pv6_neighbour_discovery.html#aedad2b550812f9be54ab691296e5876d">createAndSendNSPacket</a>(tentativeAddr, destAddr,
<a name="l00775"></a>00775         <a class="code" href="class_i_pv6_address.html#a0c1e137cb3b1470ec6b8d9a95e03dbe5">IPv6Address::UNSPECIFIED_ADDRESS</a>, ie);
<a name="l00776"></a>00776     dadEntry-&gt;numNSSent++;
<a name="l00777"></a>00777 
<a name="l00778"></a>00778     cMessage *msg = <span class="keyword">new</span> cMessage(<span class="stringliteral">&quot;dadTimeout&quot;</span>, <a class="code" href="_i_pv6_neighbour_discovery_8cc.html#a81f972006a357c3ddda2dfcfd7469015">MK_DAD_TIMEOUT</a>);
<a name="l00779"></a>00779     msg-&gt;setContextPointer(dadEntry);
<a name="l00780"></a>00780     scheduleAt(simTime()+ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#adac5ea11fce0cf45232ba3e4cd620368">getRetransTimer</a>(), msg);
<a name="l00781"></a>00781 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a9f14cc2bfe0cce622308be4388b3b397"></a><!-- doxytag: member="IPv6NeighbourDiscovery::initiateNeighbourUnreachabilityDetection" ref="a9f14cc2bfe0cce622308be4388b3b397" args="(Neighbour *neighbour)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPv6NeighbourDiscovery::initiateNeighbourUnreachabilityDetection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html">Neighbour</a> *&nbsp;</td>
          <td class="paramname"> <em>neighbour</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00430">430</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00185">processIPv6Datagram()</a>, and <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00286">resolveNeighbour()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00432"></a>00432 {
<a name="l00433"></a>00433     ASSERT(nce-&gt;reachabilityState==<a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a115199155dd43585124db1d8f471025b">IPv6NeighbourCache::STALE</a>);
<a name="l00434"></a>00434     <span class="keyword">const</span> <a class="code" href="class_i_pv6_neighbour_discovery.html#a747705ed3b49881e2d144e2d9f0c8044">Key</a> *nceKey = nce-&gt;nceKey;
<a name="l00435"></a>00435     <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Initiating Neighbour Unreachability Detection&quot;</span>;
<a name="l00436"></a>00436     <a class="code" href="class_interface_entry.html">InterfaceEntry</a> *ie = <a class="code" href="class_i_pv6_neighbour_discovery.html#a4b4f35b761b93c397e2a5a36c1e08d38">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a92764d620c345b7261de20e9ee5247d7">getInterfaceById</a>(nceKey-&gt;interfaceID);
<a name="l00437"></a>00437     <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Setting NCE state to DELAY.\n&quot;</span>;
<a name="l00438"></a>00438     <span class="comment">/*The first time a node sends a packet to a neighbor whose entry is</span>
<a name="l00439"></a>00439 <span class="comment">    STALE, the sender changes the state to DELAY*/</span>
<a name="l00440"></a>00440     nce-&gt;reachabilityState = <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a815cc3dd5d8b220495a69641b00f5bdb">IPv6NeighbourCache::DELAY</a>;
<a name="l00441"></a>00441 
<a name="l00442"></a>00442     <span class="comment">/*and sets a timer to expire in DELAY_FIRST_PROBE_TIME seconds.*/</span>
<a name="l00443"></a>00443     cMessage *msg = <span class="keyword">new</span> cMessage(<span class="stringliteral">&quot;NUDTimeout&quot;</span>, <a class="code" href="_i_pv6_neighbour_discovery_8cc.html#a817ccecd04135b6f9307b110598e476e">MK_NUD_TIMEOUT</a>);
<a name="l00444"></a>00444     msg-&gt;setContextPointer(nce);
<a name="l00445"></a>00445     nce-&gt;nudTimeoutEvent = msg;
<a name="l00446"></a>00446     scheduleAt(simTime()+ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#ae2912d96f0836d18a8d5e869692c0189">_getDelayFirstProbeTime</a>(), msg);
<a name="l00447"></a>00447 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a53cb1f954b65272ad826f3daaec29136"></a><!-- doxytag: member="IPv6NeighbourDiscovery::initiateRouterDiscovery" ref="a53cb1f954b65272ad826f3daaec29136" args="(cMessage *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPv6NeighbourDiscovery::initiateRouterDiscovery </td>
          <td>(</td>
          <td class="paramtype">cMessage *&nbsp;</td>
          <td class="paramname"> <em>msg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00854">854</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00081">handleMessage()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00855"></a>00855 {
<a name="l00856"></a>00856     <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Initiating Router Discovery&quot;</span> &lt;&lt; endl;
<a name="l00857"></a>00857     <a class="code" href="class_interface_entry.html">InterfaceEntry</a> *ie = (<a class="code" href="class_interface_entry.html">InterfaceEntry</a> *)msg-&gt;getContextPointer();
<a name="l00858"></a>00858     <span class="keyword">delete</span> msg;
<a name="l00859"></a>00859     <span class="comment">//RFC2461: Section 6.3.7</span>
<a name="l00860"></a>00860     <span class="comment">/*When an interface becomes enabled, a host may be unwilling to wait for the</span>
<a name="l00861"></a>00861 <span class="comment">    next unsolicited Router Advertisement to locate default routers or learn</span>
<a name="l00862"></a>00862 <span class="comment">    prefixes.  To obtain Router Advertisements quickly, a host SHOULD transmit up</span>
<a name="l00863"></a>00863 <span class="comment">    to MAX_RTR_SOLICITATIONS Router Solicitation messages each separated by at</span>
<a name="l00864"></a>00864 <span class="comment">    least RTR_SOLICITATION_INTERVAL seconds.(FIXME:Therefore this should be invoked</span>
<a name="l00865"></a>00865 <span class="comment">    at the beginning of the simulation-WEI)*/</span>
<a name="l00866"></a>00866     RDEntry *rdEntry = <span class="keyword">new</span> RDEntry();
<a name="l00867"></a>00867     rdEntry-&gt;interfaceId = ie-&gt;<a class="code" href="class_interface_entry.html#adc901fa42c37ce16b5c0785da81106ce">getInterfaceId</a>();
<a name="l00868"></a>00868     rdEntry-&gt;numRSSent = 0;
<a name="l00869"></a>00869     <a class="code" href="class_i_pv6_neighbour_discovery.html#a75431d6a5076b17ae0630f2fc4aa441a">createAndSendRSPacket</a>(ie);
<a name="l00870"></a>00870     rdEntry-&gt;numRSSent++;
<a name="l00871"></a>00871 
<a name="l00872"></a>00872     <span class="comment">//Create and schedule a message for retransmission to this module</span>
<a name="l00873"></a>00873     cMessage *rdTimeoutMsg = <span class="keyword">new</span> cMessage(<span class="stringliteral">&quot;processRDTimeout&quot;</span>, <a class="code" href="_i_pv6_neighbour_discovery_8cc.html#a9f894036bf61bbc51aa7a8560db5a30e">MK_RD_TIMEOUT</a>);
<a name="l00874"></a>00874     rdTimeoutMsg-&gt;setContextPointer(ie);
<a name="l00875"></a>00875     rdEntry-&gt;timeoutMsg = rdTimeoutMsg;
<a name="l00876"></a>00876     <a class="code" href="class_i_pv6_neighbour_discovery.html#a7f075a086f580756337ef6f59223727c">rdList</a>.insert(rdEntry);
<a name="l00877"></a>00877     <span class="comment">/*Before a host sends an initial solicitation, it SHOULD delay the</span>
<a name="l00878"></a>00878 <span class="comment">    transmission for a random amount of time between 0 and</span>
<a name="l00879"></a>00879 <span class="comment">    MAX_RTR_SOLICITATION_DELAY.  This serves to alleviate congestion when</span>
<a name="l00880"></a>00880 <span class="comment">    many hosts start up on a link at the same time, such as might happen</span>
<a name="l00881"></a>00881 <span class="comment">    after recovery from a power failure.  If a host has already performed</span>
<a name="l00882"></a>00882 <span class="comment">    a random delay since the interface became (re)enabled (e.g., as part</span>
<a name="l00883"></a>00883 <span class="comment">    of Duplicate Address Detection [ADDRCONF]) there is no need to delay</span>
<a name="l00884"></a>00884 <span class="comment">    again before sending the first Router Solicitation message.*/</span>
<a name="l00885"></a>00885     <span class="comment">//simtime_t rndInterval = uniform(0, ie-&gt;ipv6Data()-&gt;_getMaxRtrSolicitationDelay());</span>
<a name="l00886"></a>00886     scheduleAt(simTime()+ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#adf35c471f2a5fb67e59838754318a88e">_getRtrSolicitationInterval</a>(), rdTimeoutMsg);
<a name="l00887"></a>00887 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a878f457b650d3fbdf047dd220f8f2d88"></a><!-- doxytag: member="IPv6NeighbourDiscovery::numInitStages" ref="a878f457b650d3fbdf047dd220f8f2d88" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int IPv6NeighbourDiscovery::numInitStages </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8h_source.html#l00134">134</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8h_source.html">IPv6NeighbourDiscovery.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00134"></a>00134 {<span class="keywordflow">return</span> 4;}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a61e880bea24c63e2661d2722077ac172"></a><!-- doxytag: member="IPv6NeighbourDiscovery::processARTimeout" ref="a61e880bea24c63e2661d2722077ac172" args="(cMessage *arTimeoutMsg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPv6NeighbourDiscovery::processARTimeout </td>
          <td>(</td>
          <td class="paramtype">cMessage *&nbsp;</td>
          <td class="paramname"> <em>arTimeoutMsg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resends a NS packet to the address intended for address resolution. TODO: Not implemented yet! </p>

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00646">646</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00081">handleMessage()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00647"></a>00647 {
<a name="l00648"></a>00648     <span class="comment">//AR timeouts are cancelled when a valid solicited NA is received.</span>
<a name="l00649"></a>00649     <a class="code" href="class_i_pv6_neighbour_discovery.html#a13e99f7e1505dd01abbf03066e61384c">Neighbour</a> *nce = (<a class="code" href="class_i_pv6_neighbour_discovery.html#a13e99f7e1505dd01abbf03066e61384c">Neighbour</a> *)arTimeoutMsg-&gt;getContextPointer();
<a name="l00650"></a>00650     <span class="keyword">const</span> <a class="code" href="class_i_pv6_neighbour_discovery.html#a747705ed3b49881e2d144e2d9f0c8044">Key</a> *nceKey = nce-&gt;nceKey;
<a name="l00651"></a>00651     <a class="code" href="class_i_pv6_address.html">IPv6Address</a> nsTargetAddr = nceKey-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_key.html#af3baf750992d5cad3bb0938cbaf95257">address</a>;
<a name="l00652"></a>00652     <a class="code" href="class_interface_entry.html">InterfaceEntry</a> *ie = <a class="code" href="class_i_pv6_neighbour_discovery.html#a4b4f35b761b93c397e2a5a36c1e08d38">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a92764d620c345b7261de20e9ee5247d7">getInterfaceById</a>(nceKey-&gt;interfaceID);
<a name="l00653"></a>00653     <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Num Of NS Sent:&quot;</span> &lt;&lt; nce-&gt;numOfARNSSent &lt;&lt; endl;
<a name="l00654"></a>00654     <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Max Multicast Solicitation:&quot;</span> &lt;&lt; ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#ab51df9712e16cb8bd1b0e12c58def7fe">_getMaxMulticastSolicit</a>() &lt;&lt; endl;
<a name="l00655"></a>00655     <span class="keywordflow">if</span> (nce-&gt;numOfARNSSent &lt; ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#ab51df9712e16cb8bd1b0e12c58def7fe">_getMaxMulticastSolicit</a>())
<a name="l00656"></a>00656     {
<a name="l00657"></a>00657         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Sending another Address Resolution NS message&quot;</span> &lt;&lt; endl;
<a name="l00658"></a>00658         <a class="code" href="class_i_pv6_address.html">IPv6Address</a> nsDestAddr = nsTargetAddr.<a class="code" href="class_i_pv6_address.html#ab135c68c866eb93e17b4a8b070abf750">formSolicitedNodeMulticastAddress</a>();
<a name="l00659"></a>00659         <a class="code" href="class_i_pv6_neighbour_discovery.html#aedad2b550812f9be54ab691296e5876d">createAndSendNSPacket</a>(nsTargetAddr, nsDestAddr, nce-&gt;nsSrcAddr, ie);
<a name="l00660"></a>00660         nce-&gt;numOfARNSSent++;
<a name="l00661"></a>00661         scheduleAt(simTime()+ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a089952430501d3e7a4f82481caf8be61">_getRetransTimer</a>(), arTimeoutMsg);
<a name="l00662"></a>00662         <span class="keywordflow">return</span>;
<a name="l00663"></a>00663     }
<a name="l00664"></a>00664     <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Address Resolution has failed.&quot;</span> &lt;&lt; endl;
<a name="l00665"></a>00665     <a class="code" href="class_i_pv6_neighbour_discovery.html#a888724269369dc1aa87aa73586216b8c">dropQueuedPacketsAwaitingAR</a>(nce);
<a name="l00666"></a>00666     <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Deleting AR timeout msg\n&quot;</span>;
<a name="l00667"></a>00667     <span class="keyword">delete</span> arTimeoutMsg;
<a name="l00668"></a>00668 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a13117cd0ac035e0a0fd198d872b209c3"></a><!-- doxytag: member="IPv6NeighbourDiscovery::processDADTimeout" ref="a13117cd0ac035e0a0fd198d872b209c3" args="(cMessage *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPv6NeighbourDiscovery::processDADTimeout </td>
          <td>(</td>
          <td class="paramtype">cMessage *&nbsp;</td>
          <td class="paramname"> <em>msg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sends a scheduled DAD NS packet. If number of sends is equals or more than dupAddrDetectTransmits, then permantly assign target link local address as permanent address for given interface entry. </p>

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00783">783</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00081">handleMessage()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00784"></a>00784 {
<a name="l00785"></a>00785     DADEntry *dadEntry = (DADEntry *)msg-&gt;getContextPointer();
<a name="l00786"></a>00786     <a class="code" href="class_interface_entry.html">InterfaceEntry</a> *ie = (<a class="code" href="class_interface_entry.html">InterfaceEntry</a> *)<a class="code" href="class_i_pv6_neighbour_discovery.html#a4b4f35b761b93c397e2a5a36c1e08d38">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a92764d620c345b7261de20e9ee5247d7">getInterfaceById</a>(dadEntry-&gt;interfaceId);
<a name="l00787"></a>00787     <a class="code" href="class_i_pv6_address.html">IPv6Address</a> tentativeAddr = dadEntry-&gt;address;
<a name="l00788"></a>00788     <span class="comment">//Here, we need to check how many DAD messages for the interface entry were</span>
<a name="l00789"></a>00789     <span class="comment">//sent vs. DupAddrDetectTransmits</span>
<a name="l00790"></a>00790     <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;numOfDADMessagesSent is: &quot;</span> &lt;&lt; dadEntry-&gt;numNSSent &lt;&lt; endl;
<a name="l00791"></a>00791     <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;dupAddrDetectTrans is: &quot;</span> &lt;&lt; ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#af03b9246192fb2b01aaf7ff71f199429">dupAddrDetectTransmits</a>() &lt;&lt; endl;
<a name="l00792"></a>00792     <span class="keywordflow">if</span> (dadEntry-&gt;numNSSent &lt; ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#af03b9246192fb2b01aaf7ff71f199429">dupAddrDetectTransmits</a>())
<a name="l00793"></a>00793     {
<a name="l00794"></a>00794         bubble(<span class="stringliteral">&quot;Sending another DAD NS message.&quot;</span>);
<a name="l00795"></a>00795         <a class="code" href="class_i_pv6_address.html">IPv6Address</a> destAddr = tentativeAddr.<a class="code" href="class_i_pv6_address.html#ab135c68c866eb93e17b4a8b070abf750">formSolicitedNodeMulticastAddress</a>();
<a name="l00796"></a>00796         <a class="code" href="class_i_pv6_neighbour_discovery.html#aedad2b550812f9be54ab691296e5876d">createAndSendNSPacket</a>(dadEntry-&gt;address, destAddr, <a class="code" href="class_i_pv6_address.html#a0c1e137cb3b1470ec6b8d9a95e03dbe5">IPv6Address::UNSPECIFIED_ADDRESS</a>, ie);
<a name="l00797"></a>00797         dadEntry-&gt;numNSSent++;
<a name="l00798"></a>00798         <span class="comment">//Reuse the received msg</span>
<a name="l00799"></a>00799         scheduleAt(simTime()+ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#adac5ea11fce0cf45232ba3e4cd620368">getRetransTimer</a>(), msg);
<a name="l00800"></a>00800     }
<a name="l00801"></a>00801     <span class="keywordflow">else</span>
<a name="l00802"></a>00802     {
<a name="l00803"></a>00803         bubble(<span class="stringliteral">&quot;Max number of DAD messages for interface sent. Address is unique.&quot;</span>);
<a name="l00804"></a>00804         ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#aa80a8f0b2706a8622bab6b3ff61959ff">permanentlyAssign</a>(tentativeAddr);
<a name="l00805"></a>00805         <a class="code" href="class_i_pv6_neighbour_discovery.html#a750d70366700481befd66c567d420a7e">dadList</a>.erase(dadEntry);
<a name="l00806"></a>00806         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;delete dadEntry and msg\n&quot;</span>;
<a name="l00807"></a>00807         <span class="keyword">delete</span> dadEntry;
<a name="l00808"></a>00808         <span class="keyword">delete</span> msg;
<a name="l00809"></a>00809         <span class="comment">/*RFC 2461: Section 6.3.7 2nd Paragraph</span>
<a name="l00810"></a>00810 <span class="comment">        Before a host sends an initial solicitation, it SHOULD delay the</span>
<a name="l00811"></a>00811 <span class="comment">        transmission for a random amount of time between 0 and</span>
<a name="l00812"></a>00812 <span class="comment">        MAX_RTR_SOLICITATION_DELAY.  This serves to alleviate congestion when</span>
<a name="l00813"></a>00813 <span class="comment">        many hosts start up on a link at the same time, such as might happen</span>
<a name="l00814"></a>00814 <span class="comment">        after recovery from a power failure.*/</span>
<a name="l00815"></a>00815         <span class="comment">//TODO: Placing these operations here means fast router solicitation is</span>
<a name="l00816"></a>00816         <span class="comment">//not adopted. Will relocate.</span>
<a name="l00817"></a>00817         <span class="keywordflow">if</span> (ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a3e629909076b47fa0886f83fbb7af09a">getAdvSendAdvertisements</a>() == <span class="keyword">false</span>)
<a name="l00818"></a>00818         {
<a name="l00819"></a>00819             <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;creating router discovery message timer\n&quot;</span>;
<a name="l00820"></a>00820             cMessage *rtrDisMsg = <span class="keyword">new</span> cMessage(<span class="stringliteral">&quot;initiateRTRDIS&quot;</span>,<a class="code" href="_i_pv6_neighbour_discovery_8cc.html#aadba1232289c7af8c42ae503b367f409">MK_INITIATE_RTRDIS</a>);
<a name="l00821"></a>00821             rtrDisMsg-&gt;setContextPointer(ie);
<a name="l00822"></a>00822             simtime_t interval = uniform(0, ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a517877f2a3d3d2ce80f08931a3b640ca">_getMaxRtrSolicitationDelay</a>()); <span class="comment">// random delay</span>
<a name="l00823"></a>00823             scheduleAt(simTime()+interval, rtrDisMsg);
<a name="l00824"></a>00824         }
<a name="l00825"></a>00825     }
<a name="l00826"></a>00826 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ade69131623bc5b13205ced3ff54a16d3"></a><!-- doxytag: member="IPv6NeighbourDiscovery::processIPv6Datagram" ref="ade69131623bc5b13205ced3ff54a16d3" args="(IPv6Datagram *datagram)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPv6NeighbourDiscovery::processIPv6Datagram </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_datagram.html">IPv6Datagram</a> *&nbsp;</td>
          <td class="paramname"> <em>datagram</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00185">185</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00081">handleMessage()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00186"></a>00186 {
<a name="l00187"></a>00187     <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Packet &quot;</span> &lt;&lt; msg &lt;&lt; <span class="stringliteral">&quot; arrived from IPv6 module.\n&quot;</span>;
<a name="l00188"></a>00188 
<a name="l00189"></a>00189     <span class="keywordtype">int</span> nextHopIfID;
<a name="l00190"></a>00190     <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Determining Next Hop&quot;</span> &lt;&lt; endl;
<a name="l00191"></a>00191     <a class="code" href="class_i_pv6_address.html">IPv6Address</a> nextHopAddr = <a class="code" href="class_i_pv6_neighbour_discovery.html#a4bddad274cd8eb1472d37ddcd559c629">determineNextHop</a>(msg-&gt;getDestAddress(), nextHopIfID);
<a name="l00192"></a>00192     <span class="keywordflow">if</span> (nextHopIfID == -1)
<a name="l00193"></a>00193     {
<a name="l00194"></a>00194         <span class="comment">//draft-ietf-ipv6-2461bis-04 has omitted on-link assumption.</span>
<a name="l00195"></a>00195         <span class="comment">//draft-ietf-v6ops-onlinkassumption-03 explains why.</span>
<a name="l00196"></a>00196         <a class="code" href="class_i_pv6_neighbour_discovery.html#a78cfa038ef771566c18a2eec28fd740b">icmpv6</a>-&gt;<a class="code" href="class_i_c_m_pv6.html#a3968b2c9964bb40a3d14b3fda9fdbba5">sendErrorMessage</a>(msg, <a class="code" href="_i_c_m_pv6_message__m_8h.html#a007402fd73fa0142d3b888578b1280f8a41a9a5f4838bc4483b77b0fdcd13f72b">ICMPv6_DESTINATION_UNREACHABLE</a>, <a class="code" href="_i_c_m_pv6_message__m_8h.html#a0de5d721e9e426e7acecf6830de1331fab458cf17d1a4b7018719211a9ed053fd">NO_ROUTE_TO_DEST</a>);
<a name="l00197"></a>00197         <span class="keywordflow">return</span>;
<a name="l00198"></a>00198     }
<a name="l00199"></a>00199     <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Next Hop Address is: &quot;</span> &lt;&lt; nextHopAddr &lt;&lt; <span class="stringliteral">&quot; on interface: &quot;</span> &lt;&lt; nextHopIfID &lt;&lt; endl;
<a name="l00200"></a>00200 
<a name="l00201"></a>00201     <span class="comment">//RFC2461: Section 5.2 Conceptual Sending Algorithm</span>
<a name="l00202"></a>00202     <span class="comment">//Once the IP address of the next-hop node is known, the sender examines the</span>
<a name="l00203"></a>00203     <span class="comment">//Neighbor Cache for link-layer information about that neighbor.</span>
<a name="l00204"></a>00204     <a class="code" href="class_i_pv6_neighbour_discovery.html#a13e99f7e1505dd01abbf03066e61384c">Neighbour</a> *nce = <a class="code" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">neighbourCache</a>.<a class="code" href="class_i_pv6_neighbour_cache.html#af88ebc30d5f18f0a628ead79f1fc3cb9">lookup</a>(nextHopAddr, nextHopIfID);
<a name="l00205"></a>00205 
<a name="l00206"></a>00206     <span class="keywordflow">if</span> (nce==NULL)
<a name="l00207"></a>00207     {
<a name="l00208"></a>00208         <span class="comment">//If no entry exists,</span>
<a name="l00209"></a>00209         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;No Entry exists in the Neighbour Cache.\n&quot;</span>;
<a name="l00210"></a>00210 
<a name="l00211"></a>00211         <span class="comment">//the sender creates one, sets its state to INCOMPLETE,</span>
<a name="l00212"></a>00212         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Creating an INCOMPLETE entry in the neighbour cache.\n&quot;</span>;
<a name="l00213"></a>00213         nce = <a class="code" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">neighbourCache</a>.<a class="code" href="class_i_pv6_neighbour_cache.html#ab0751209af2b66c4171f92ba6ed7eee1">addNeighbour</a>(nextHopAddr, nextHopIfID);
<a name="l00214"></a>00214 
<a name="l00215"></a>00215         <span class="comment">//initiates Address Resolution,</span>
<a name="l00216"></a>00216         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Initiating Address Resolution for:&quot;</span> &lt;&lt; nextHopAddr
<a name="l00217"></a>00217            &lt;&lt; <span class="stringliteral">&quot; on Interface:&quot;</span> &lt;&lt; nextHopIfID &lt;&lt; endl;
<a name="l00218"></a>00218         <a class="code" href="class_i_pv6_neighbour_discovery.html#a6afff1bf1db0e7b69f3f6782a87b5b82">initiateAddressResolution</a>(msg-&gt;getSrcAddress(), nce);
<a name="l00219"></a>00219 
<a name="l00220"></a>00220         <span class="comment">//and then queues the data packet pending completion of address resolution.</span>
<a name="l00221"></a>00221         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Add packet to entry&apos;s queue until Address Resolution is complete.\n&quot;</span>;
<a name="l00222"></a>00222         nce-&gt;pendingPackets.push_back(msg);
<a name="l00223"></a>00223         <a class="code" href="class_i_pv6_neighbour_discovery.html#a8cebccf199f96d0903c4663b203199ca">pendingQueue</a>.insert(msg);
<a name="l00224"></a>00224     }
<a name="l00225"></a>00225     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nce-&gt;reachabilityState == <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1ac2cfd6c9d21c7d34d2f6f53d6cfe6638">IPv6NeighbourCache::INCOMPLETE</a>)
<a name="l00226"></a>00226     {
<a name="l00227"></a>00227         EV &lt;&lt; <span class="stringliteral">&quot;Reachability State is INCOMPLETE.Address Resolution already initiated.\n&quot;</span>;
<a name="l00228"></a>00228         bubble(<span class="stringliteral">&quot;Packet added to queue until Address Resolution is complete.&quot;</span>);
<a name="l00229"></a>00229         nce-&gt;pendingPackets.push_back(msg);
<a name="l00230"></a>00230         <a class="code" href="class_i_pv6_neighbour_discovery.html#a8cebccf199f96d0903c4663b203199ca">pendingQueue</a>.insert(msg);
<a name="l00231"></a>00231     }
<a name="l00232"></a>00232     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nce-&gt;macAddress.isUnspecified())
<a name="l00233"></a>00233     {
<a name="l00234"></a>00234         EV &lt;&lt; <span class="stringliteral">&quot;NCE&apos;s MAC address is unspecified.\n&quot;</span>;
<a name="l00235"></a>00235         EV &lt;&lt; <span class="stringliteral">&quot;Initiate Address Resolution and add packet to queue.\n&quot;</span>;
<a name="l00236"></a>00236         <a class="code" href="class_i_pv6_neighbour_discovery.html#a6afff1bf1db0e7b69f3f6782a87b5b82">initiateAddressResolution</a>(msg-&gt;getSrcAddress(), nce);
<a name="l00237"></a>00237         nce-&gt;pendingPackets.push_back(msg);
<a name="l00238"></a>00238         <a class="code" href="class_i_pv6_neighbour_discovery.html#a8cebccf199f96d0903c4663b203199ca">pendingQueue</a>.insert(msg);
<a name="l00239"></a>00239     }
<a name="l00240"></a>00240     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nce-&gt;reachabilityState == <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a115199155dd43585124db1d8f471025b">IPv6NeighbourCache::STALE</a>)
<a name="l00241"></a>00241     {
<a name="l00242"></a>00242         EV &lt;&lt; <span class="stringliteral">&quot;Reachability State is STALE.\n&quot;</span>;
<a name="l00243"></a>00243         send(msg,<span class="stringliteral">&quot;ipv6Out&quot;</span>);
<a name="l00244"></a>00244         <a class="code" href="class_i_pv6_neighbour_discovery.html#a9f14cc2bfe0cce622308be4388b3b397">initiateNeighbourUnreachabilityDetection</a>(nce);
<a name="l00245"></a>00245     }
<a name="l00246"></a>00246     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nce-&gt;reachabilityState == <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a537cfe5cd6d576deab91b256b6da873a">IPv6NeighbourCache::REACHABLE</a>)
<a name="l00247"></a>00247     {
<a name="l00248"></a>00248         EV &lt;&lt; <span class="stringliteral">&quot;Next hop is REACHABLE, sending packet to next-hop address.&quot;</span>;
<a name="l00249"></a>00249         <a class="code" href="class_i_pv6_neighbour_discovery.html#a58642b1dc383266b43abc6d6e4a74e5e">sendPacketToIPv6Module</a>(msg, nextHopAddr, msg-&gt;getSrcAddress(), nextHopIfID);
<a name="l00250"></a>00250     }
<a name="l00251"></a>00251     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nce-&gt;reachabilityState == <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a815cc3dd5d8b220495a69641b00f5bdb">IPv6NeighbourCache::DELAY</a>)<span class="comment">//TODO: What if NCE is in PROBE state?</span>
<a name="l00252"></a>00252     {
<a name="l00253"></a>00253         EV &lt;&lt; <span class="stringliteral">&quot;Next hop is in DELAY state, sending packet to next-hop address.&quot;</span>;
<a name="l00254"></a>00254         <a class="code" href="class_i_pv6_neighbour_discovery.html#a58642b1dc383266b43abc6d6e4a74e5e">sendPacketToIPv6Module</a>(msg, nextHopAddr, msg-&gt;getSrcAddress(), nextHopIfID);
<a name="l00255"></a>00255     }
<a name="l00256"></a>00256     <span class="keywordflow">else</span>
<a name="l00257"></a>00257         error(<span class="stringliteral">&quot;Unknown Neighbour cache entry state.&quot;</span>);
<a name="l00258"></a>00258 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a093219842e9055dc413f8f6d401001ee"></a><!-- doxytag: member="IPv6NeighbourDiscovery::processNAForIncompleteNCEState" ref="a093219842e9055dc413f8f6d401001ee" args="(IPv6NeighbourAdvertisement *na, IPv6NeighbourCache::Neighbour *nce)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPv6NeighbourDiscovery::processNAForIncompleteNCEState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_neighbour_advertisement.html">IPv6NeighbourAdvertisement</a> *&nbsp;</td>
          <td class="paramname"> <em>na</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html">IPv6NeighbourCache::Neighbour</a> *&nbsp;</td>
          <td class="paramname"> <em>nce</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01974">1974</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01891">processNAPacket()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01976"></a>01976 {
<a name="l01977"></a>01977     <a class="code" href="class_m_a_c_address.html">MACAddress</a> naMacAddr = na-&gt;<a class="code" href="class_i_pv6_neighbour_advertisement.html#a30d4ff1f627fd97932c2ee4d9c435f8b">getTargetLinkLayerAddress</a>();
<a name="l01978"></a>01978     <span class="keywordtype">bool</span> naRouterFlag = na-&gt;<a class="code" href="class_i_pv6_neighbour_advertisement.html#a88ac570e8f5e77f9a37f7f1ac545a0dc">getRouterFlag</a>();
<a name="l01979"></a>01979     <span class="keywordtype">bool</span> naSolicitedFlag = na-&gt;<a class="code" href="class_i_pv6_neighbour_advertisement.html#a930381145de395cf787734ae40ea7361">getSolicitedFlag</a>();
<a name="l01980"></a>01980     <span class="keyword">const</span> <a class="code" href="class_i_pv6_neighbour_discovery.html#a747705ed3b49881e2d144e2d9f0c8044">Key</a> *nceKey = nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#ad5af58880fcaf23480829713c6842037">nceKey</a>;
<a name="l01981"></a>01981     <a class="code" href="class_interface_entry.html">InterfaceEntry</a> *ie = <a class="code" href="class_i_pv6_neighbour_discovery.html#a4b4f35b761b93c397e2a5a36c1e08d38">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a92764d620c345b7261de20e9ee5247d7">getInterfaceById</a>(nceKey-&gt;interfaceID);
<a name="l01982"></a>01982 
<a name="l01983"></a>01983     <span class="comment">/*If the target&apos;s neighbour Cache entry is in the INCOMPLETE state when the</span>
<a name="l01984"></a>01984 <span class="comment">    advertisement is received, one of two things happens.*/</span>
<a name="l01985"></a>01985     <span class="keywordflow">if</span> (naMacAddr.<a class="code" href="class_m_a_c_address.html#ae41af013d782b46483e7d0c84f0ed107">isUnspecified</a>())
<a name="l01986"></a>01986     {
<a name="l01987"></a>01987         <span class="comment">/*If the link layer has addresses and no Target Link-Layer address option</span>
<a name="l01988"></a>01988 <span class="comment">        is included, the receiving node SHOULD silently discard the received</span>
<a name="l01989"></a>01989 <span class="comment">        advertisement.*/</span>
<a name="l01990"></a>01990         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;No MAC Address specified in NA. Ignoring NA\n&quot;</span>;
<a name="l01991"></a>01991         <span class="keywordflow">return</span>;
<a name="l01992"></a>01992     }
<a name="l01993"></a>01993     <span class="keywordflow">else</span>
<a name="l01994"></a>01994     {
<a name="l01995"></a>01995         <span class="comment">//Otherwise, the receiving node performs the following steps:</span>
<a name="l01996"></a>01996         <span class="comment">//- It records the link-layer address in the neighbour Cache entry.</span>
<a name="l01997"></a>01997         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;ND is updating Neighbour Cache Entry.\n&quot;</span>;
<a name="l01998"></a>01998         nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#a3b51b5802cd50245bc2cdbbca1069dd0">macAddress</a> = naMacAddr;
<a name="l01999"></a>01999 
<a name="l02000"></a>02000         <span class="comment">//- If the advertisement&apos;s Solicited flag is set, the state of the</span>
<a name="l02001"></a>02001         <span class="comment">//  entry is set to REACHABLE, otherwise it is set to STALE.</span>
<a name="l02002"></a>02002         <span class="keywordflow">if</span> (naSolicitedFlag == <span class="keyword">true</span>)
<a name="l02003"></a>02003         {
<a name="l02004"></a>02004             nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#a0895435c223a2d4f67f02c3c614afbb5">reachabilityState</a> = <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a537cfe5cd6d576deab91b256b6da873a">IPv6NeighbourCache::REACHABLE</a>;
<a name="l02005"></a>02005             <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Reachability confirmed through successful Addr Resolution.\n&quot;</span>;
<a name="l02006"></a>02006             nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#ad89a5f7ec5a7834e440c4437d108687a">reachabilityExpires</a> = simTime() + ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#ad383bc920fcd091c25c907478c1fd38e">_getReachableTime</a>();
<a name="l02007"></a>02007         }
<a name="l02008"></a>02008         <span class="keywordflow">else</span>
<a name="l02009"></a>02009             nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#a0895435c223a2d4f67f02c3c614afbb5">reachabilityState</a> = <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a115199155dd43585124db1d8f471025b">IPv6NeighbourCache::STALE</a>;
<a name="l02010"></a>02010 
<a name="l02011"></a>02011         <span class="comment">//- It sets the IsRouter flag in the cache entry based on the Router</span>
<a name="l02012"></a>02012         <span class="comment">//  flag in the received advertisement.</span>
<a name="l02013"></a>02013         nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#af5203d6dd6d97a8b2baf782f44f8206f">isRouter</a> = naRouterFlag;
<a name="l02014"></a>02014 
<a name="l02015"></a>02015         <span class="comment">//- It sends any packets queued for the neighbour awaiting address</span>
<a name="l02016"></a>02016         <span class="comment">//  resolution.</span>
<a name="l02017"></a>02017         <a class="code" href="class_i_pv6_neighbour_discovery.html#a6cc2bafedafa13f79df2410b6617ff4b">sendQueuedPacketsToIPv6Module</a>(nce);
<a name="l02018"></a>02018         cancelEvent(nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#a85eabb9c45740ac29550eb11cb03cdb6">arTimer</a>);
<a name="l02019"></a>02019     }
<a name="l02020"></a>02020 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a58a8a7aaf00643c4eb0044cc1380413b"></a><!-- doxytag: member="IPv6NeighbourDiscovery::processNAForOtherNCEStates" ref="a58a8a7aaf00643c4eb0044cc1380413b" args="(IPv6NeighbourAdvertisement *na, IPv6NeighbourCache::Neighbour *nce)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPv6NeighbourDiscovery::processNAForOtherNCEStates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_neighbour_advertisement.html">IPv6NeighbourAdvertisement</a> *&nbsp;</td>
          <td class="paramname"> <em>na</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html">IPv6NeighbourCache::Neighbour</a> *&nbsp;</td>
          <td class="paramname"> <em>nce</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l02022">2022</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01891">processNAPacket()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02024"></a>02024 {
<a name="l02025"></a>02025     <span class="keywordtype">bool</span> naRouterFlag = na-&gt;<a class="code" href="class_i_pv6_neighbour_advertisement.html#a88ac570e8f5e77f9a37f7f1ac545a0dc">getRouterFlag</a>();
<a name="l02026"></a>02026     <span class="keywordtype">bool</span> naSolicitedFlag = na-&gt;<a class="code" href="class_i_pv6_neighbour_advertisement.html#a930381145de395cf787734ae40ea7361">getSolicitedFlag</a>();
<a name="l02027"></a>02027     <span class="keywordtype">bool</span> naOverrideFlag = na-&gt;<a class="code" href="class_i_pv6_neighbour_advertisement.html#a6cb96afeb88e2c5dcfed94d1992916df">getOverrideFlag</a>();
<a name="l02028"></a>02028     <a class="code" href="class_m_a_c_address.html">MACAddress</a> naMacAddr = na-&gt;<a class="code" href="class_i_pv6_neighbour_advertisement.html#a30d4ff1f627fd97932c2ee4d9c435f8b">getTargetLinkLayerAddress</a>();
<a name="l02029"></a>02029     <span class="keyword">const</span> <a class="code" href="class_i_pv6_neighbour_discovery.html#a747705ed3b49881e2d144e2d9f0c8044">Key</a> *nceKey = nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#ad5af58880fcaf23480829713c6842037">nceKey</a>;
<a name="l02030"></a>02030     <a class="code" href="class_interface_entry.html">InterfaceEntry</a> *ie = <a class="code" href="class_i_pv6_neighbour_discovery.html#a4b4f35b761b93c397e2a5a36c1e08d38">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a92764d620c345b7261de20e9ee5247d7">getInterfaceById</a>(nceKey-&gt;interfaceID);
<a name="l02031"></a>02031 
<a name="l02032"></a>02032     <span class="comment">/*draft-ietf-ipv6-2461bis-04</span>
<a name="l02033"></a>02033 <span class="comment">    Section 7.2.5: Receipt of Neighbour Advertisements</span>
<a name="l02034"></a>02034 <span class="comment">    If the target&apos;s Neighbor Cache entry is in any state other than INCOMPLETE</span>
<a name="l02035"></a>02035 <span class="comment">    when the advertisement is received, the following actions take place:*/</span>
<a name="l02036"></a>02036 
<a name="l02037"></a>02037     <span class="keywordflow">if</span> (naOverrideFlag == <span class="keyword">false</span> &amp;&amp; !(naMacAddr.<a class="code" href="class_m_a_c_address.html#a2d1669ce517436105cd75faed677a303">equals</a>(nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#a3b51b5802cd50245bc2cdbbca1069dd0">macAddress</a>))
<a name="l02038"></a>02038         &amp;&amp; !(naMacAddr.<a class="code" href="class_m_a_c_address.html#ae41af013d782b46483e7d0c84f0ed107">isUnspecified</a>()))
<a name="l02039"></a>02039     {
<a name="l02040"></a>02040         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;NA override is FALSE and NA MAC addr is different.\n&quot;</span>;
<a name="l02041"></a>02041         <span class="comment">//I. If the Override flag is clear and the supplied link-layer address</span>
<a name="l02042"></a>02042         <span class="comment">//   differs from that in the cache, then one of two actions takes place:</span>
<a name="l02043"></a>02043         <span class="comment">//(Note: An unspecified MAC should not be compared with the NCE&apos;s mac!)</span>
<a name="l02044"></a>02044         <span class="comment">//a. If the state of the entry is REACHABLE,</span>
<a name="l02045"></a>02045         <span class="keywordflow">if</span> (nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#a0895435c223a2d4f67f02c3c614afbb5">reachabilityState</a> == <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a537cfe5cd6d576deab91b256b6da873a">IPv6NeighbourCache::REACHABLE</a>)
<a name="l02046"></a>02046         {
<a name="l02047"></a>02047             <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;NA mac is different. Change NCE state from REACHABLE to STALE\n&quot;</span>;
<a name="l02048"></a>02048             <span class="comment">//set it to STALE, but do not update the entry in any other way.</span>
<a name="l02049"></a>02049             nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#a0895435c223a2d4f67f02c3c614afbb5">reachabilityState</a> = <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a115199155dd43585124db1d8f471025b">IPv6NeighbourCache::STALE</a>;
<a name="l02050"></a>02050         }
<a name="l02051"></a>02051         <span class="keywordflow">else</span>
<a name="l02052"></a>02052             <span class="comment">//b. Otherwise, the received advertisement should be ignored and</span>
<a name="l02053"></a>02053             <span class="comment">//MUST NOT update the cache.</span>
<a name="l02054"></a>02054             <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;NCE is not in REACHABLE state. Ignore NA.\n&quot;</span>;
<a name="l02055"></a>02055     }
<a name="l02056"></a>02056     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (naOverrideFlag == <span class="keyword">true</span> || naMacAddr.<a class="code" href="class_m_a_c_address.html#a2d1669ce517436105cd75faed677a303">equals</a>(nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#a3b51b5802cd50245bc2cdbbca1069dd0">macAddress</a>)
<a name="l02057"></a>02057         || naMacAddr.<a class="code" href="class_m_a_c_address.html#ae41af013d782b46483e7d0c84f0ed107">isUnspecified</a>())
<a name="l02058"></a>02058     {
<a name="l02059"></a>02059         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;NA override flag is TRUE. or Advertised MAC is same as NCE&apos;s. or&quot;</span>
<a name="l02060"></a>02060            &lt;&lt; <span class="stringliteral">&quot; NA MAC is not specified.\n&quot;</span>;
<a name="l02061"></a>02061         <span class="comment">/*II. If the Override flag is set, or the supplied link-layer address</span>
<a name="l02062"></a>02062 <span class="comment">        is the same as that in the cache, or no Target Link-layer address</span>
<a name="l02063"></a>02063 <span class="comment">        option was supplied, the received advertisement MUST update the</span>
<a name="l02064"></a>02064 <span class="comment">        Neighbor Cache entry as follows:*/</span>
<a name="l02065"></a>02065 
<a name="l02066"></a>02066         <span class="comment">/*- The link-layer address in the Target Link-Layer Address option</span>
<a name="l02067"></a>02067 <span class="comment">            MUST be inserted in the cache (if one is supplied and is</span>
<a name="l02068"></a>02068 <span class="comment">            Different than the already recorded address).*/</span>
<a name="l02069"></a>02069         <span class="keywordflow">if</span> (!(naMacAddr.<a class="code" href="class_m_a_c_address.html#ae41af013d782b46483e7d0c84f0ed107">isUnspecified</a>()) &amp;&amp;
<a name="l02070"></a>02070             !(naMacAddr.<a class="code" href="class_m_a_c_address.html#a2d1669ce517436105cd75faed677a303">equals</a>(nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#a3b51b5802cd50245bc2cdbbca1069dd0">macAddress</a>)))
<a name="l02071"></a>02071         {
<a name="l02072"></a>02072             <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Updating NCE&apos;s MAC addr with NA&apos;s.\n&quot;</span>;
<a name="l02073"></a>02073             nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#a3b51b5802cd50245bc2cdbbca1069dd0">macAddress</a> = naMacAddr;
<a name="l02074"></a>02074         }
<a name="l02075"></a>02075 
<a name="l02076"></a>02076         <span class="comment">//- If the Solicited flag is set,</span>
<a name="l02077"></a>02077         <span class="keywordflow">if</span> (naSolicitedFlag == <span class="keyword">true</span>)
<a name="l02078"></a>02078         {
<a name="l02079"></a>02079             <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Solicited Flag is TRUE. Set NCE state to REACHABLE.\n&quot;</span>;
<a name="l02080"></a>02080             <span class="comment">//the state of the entry MUST be set to REACHABLE.</span>
<a name="l02081"></a>02081             nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#a0895435c223a2d4f67f02c3c614afbb5">reachabilityState</a> = <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a537cfe5cd6d576deab91b256b6da873a">IPv6NeighbourCache::REACHABLE</a>;
<a name="l02082"></a>02082             <span class="comment">//We have to cancel the NUD self timer message if there is one.</span>
<a name="l02083"></a>02083             cMessage *msg = nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#a861411e349fda127a4b66659f155659f">nudTimeoutEvent</a>;
<a name="l02084"></a>02084             <span class="keywordflow">if</span> (msg != NULL)
<a name="l02085"></a>02085             {
<a name="l02086"></a>02086                 <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;NUD in progress. Cancelling NUD Timer\n&quot;</span>;
<a name="l02087"></a>02087                 bubble(<span class="stringliteral">&quot;Reachability Confirmed via NUD.&quot;</span>);
<a name="l02088"></a>02088                 nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#ad89a5f7ec5a7834e440c4437d108687a">reachabilityExpires</a> = simTime() + ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#ad383bc920fcd091c25c907478c1fd38e">_getReachableTime</a>();
<a name="l02089"></a>02089                 cancelEvent(msg);
<a name="l02090"></a>02090                 <span class="keyword">delete</span> msg;
<a name="l02091"></a>02091             }
<a name="l02092"></a>02092         }
<a name="l02093"></a>02093         <span class="keywordflow">else</span>
<a name="l02094"></a>02094         {
<a name="l02095"></a>02095             <span class="comment">//If the Solicited flag is zero</span>
<a name="l02096"></a>02096             <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Solicited Flag is FALSE.\n&quot;</span>;
<a name="l02097"></a>02097             <span class="comment">//and the link layer address was updated with a different address</span>
<a name="l02098"></a>02098             <span class="keywordflow">if</span> (!(naMacAddr.<a class="code" href="class_m_a_c_address.html#a2d1669ce517436105cd75faed677a303">equals</a>(nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#a3b51b5802cd50245bc2cdbbca1069dd0">macAddress</a>)))
<a name="l02099"></a>02099             {
<a name="l02100"></a>02100                 <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;NA&apos;s MAC is different from NCE&apos;s.Set NCE state to STALE\n&quot;</span>;
<a name="l02101"></a>02101                 <span class="comment">//the state MUST be set to STALE.</span>
<a name="l02102"></a>02102                 nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#a0895435c223a2d4f67f02c3c614afbb5">reachabilityState</a> = <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a115199155dd43585124db1d8f471025b">IPv6NeighbourCache::STALE</a>;
<a name="l02103"></a>02103             }
<a name="l02104"></a>02104             <span class="keywordflow">else</span>
<a name="l02105"></a>02105                 <span class="comment">//Otherwise, the entry&apos;s state remains unchanged.</span>
<a name="l02106"></a>02106                 <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;NA&apos;s MAC is the same as NCE&apos;s. State remains unchanged.\n&quot;</span>;
<a name="l02107"></a>02107         }
<a name="l02108"></a>02108         <span class="comment">//(Next paragraph with explanation is omitted.-WEI)</span>
<a name="l02109"></a>02109 
<a name="l02110"></a>02110         <span class="comment">/*- The IsRouter flag in the cache entry MUST be set based on the</span>
<a name="l02111"></a>02111 <span class="comment">        Router flag in the received advertisement.*/</span>
<a name="l02112"></a>02112         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Updating NCE&apos;s router flag to &quot;</span> &lt;&lt; naRouterFlag &lt;&lt; endl;
<a name="l02113"></a>02113         nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#af5203d6dd6d97a8b2baf782f44f8206f">isRouter</a> = naRouterFlag;
<a name="l02114"></a>02114 
<a name="l02115"></a>02115         <span class="comment">//TODO: To be implemented</span>
<a name="l02116"></a>02116         <span class="comment">/*In those cases where the IsRouter flag changes from TRUE to FALSE as a</span>
<a name="l02117"></a>02117 <span class="comment">        result of this update, the node MUST remove that router from the Default</span>
<a name="l02118"></a>02118 <span class="comment">        Router List and update the Destination Cache entries for all destinations</span>
<a name="l02119"></a>02119 <span class="comment">        using that neighbor as a router as specified in Section 7.3.3. This is</span>
<a name="l02120"></a>02120 <span class="comment">        needed to detect when a node that is used as a router stops forwarding</span>
<a name="l02121"></a>02121 <span class="comment">        packets due to being configured as a host.*/</span>
<a name="l02122"></a>02122     }
<a name="l02123"></a>02123 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a348ba5dd9e93f4640d465a74b8a73d53"></a><!-- doxytag: member="IPv6NeighbourDiscovery::processNAPacket" ref="a348ba5dd9e93f4640d465a74b8a73d53" args="(IPv6NeighbourAdvertisement *na, IPv6ControlInfo *naCtrlInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPv6NeighbourDiscovery::processNAPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_neighbour_advertisement.html">IPv6NeighbourAdvertisement</a> *&nbsp;</td>
          <td class="paramname"> <em>na</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>naCtrlInfo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01891">1891</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00146">processNDMessage()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01893"></a>01893 {
<a name="l01894"></a>01894     <span class="keywordflow">if</span> (<a class="code" href="class_i_pv6_neighbour_discovery.html#a8f18a6e238820911ee6253f12b766fad">validateNAPacket</a>(na, naCtrlInfo) == <span class="keyword">false</span>)
<a name="l01895"></a>01895     {
<a name="l01896"></a>01896         <span class="keyword">delete</span> naCtrlInfo;
<a name="l01897"></a>01897         <span class="keyword">delete</span> na;
<a name="l01898"></a>01898         <span class="keywordflow">return</span>;
<a name="l01899"></a>01899     }
<a name="l01900"></a>01900 
<a name="l01901"></a>01901     <span class="comment">//Neighbour Advertisement Information</span>
<a name="l01902"></a>01902     <a class="code" href="class_i_pv6_address.html">IPv6Address</a> naTargetAddr = na-&gt;<a class="code" href="class_i_pv6_neighbour_advertisement.html#ab4ced614f69b3cf120dbb835fbd7c11b">getTargetAddress</a>();
<a name="l01903"></a>01903 
<a name="l01904"></a>01904     <span class="comment">//First, we check if the target address in NA is found in the interface it</span>
<a name="l01905"></a>01905     <span class="comment">//was received on is tentative.</span>
<a name="l01906"></a>01906     <a class="code" href="class_interface_entry.html">InterfaceEntry</a> *ie = <a class="code" href="class_i_pv6_neighbour_discovery.html#a4b4f35b761b93c397e2a5a36c1e08d38">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a92764d620c345b7261de20e9ee5247d7">getInterfaceById</a>(naCtrlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a74046fa005d98f0c304eb39eb28a1ec3">getInterfaceId</a>());
<a name="l01907"></a>01907     <span class="keywordflow">if</span> (ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a90fa17dc7efaa7170176e853cf32dfed">isTentativeAddress</a>(naTargetAddr))
<a name="l01908"></a>01908     {
<a name="l01909"></a>01909         error(<span class="stringliteral">&quot;Duplicate Address Detected! Manual attention needed!&quot;</span>);
<a name="l01910"></a>01910     }
<a name="l01911"></a>01911     <span class="comment">//Logic as defined in Section 7.2.5</span>
<a name="l01912"></a>01912     <a class="code" href="class_i_pv6_neighbour_discovery.html#a13e99f7e1505dd01abbf03066e61384c">Neighbour</a> *neighbourEntry = <a class="code" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">neighbourCache</a>.<a class="code" href="class_i_pv6_neighbour_cache.html#af88ebc30d5f18f0a628ead79f1fc3cb9">lookup</a>(naTargetAddr, ie-&gt;<a class="code" href="class_interface_entry.html#adc901fa42c37ce16b5c0785da81106ce">getInterfaceId</a>());
<a name="l01913"></a>01913 
<a name="l01914"></a>01914     <span class="keywordflow">if</span> (neighbourEntry == NULL)
<a name="l01915"></a>01915     {
<a name="l01916"></a>01916         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;NA received. Target Address not found in Neighbour Cache\n&quot;</span>;
<a name="l01917"></a>01917         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Dropping NA packet.\n&quot;</span>;
<a name="l01918"></a>01918         <span class="keyword">delete</span> naCtrlInfo;
<a name="l01919"></a>01919         <span class="keyword">delete</span> na;
<a name="l01920"></a>01920         <span class="keywordflow">return</span>;
<a name="l01921"></a>01921     }
<a name="l01922"></a>01922 
<a name="l01923"></a>01923     <span class="comment">//Target Address has entry in Neighbour Cache</span>
<a name="l01924"></a>01924     <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;NA received. Target Address found in Neighbour Cache\n&quot;</span>;
<a name="l01925"></a>01925 
<a name="l01926"></a>01926     <span class="keywordflow">if</span> (neighbourEntry-&gt;reachabilityState == <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1ac2cfd6c9d21c7d34d2f6f53d6cfe6638">IPv6NeighbourCache::INCOMPLETE</a>)
<a name="l01927"></a>01927         <a class="code" href="class_i_pv6_neighbour_discovery.html#a093219842e9055dc413f8f6d401001ee">processNAForIncompleteNCEState</a>(na, neighbourEntry);
<a name="l01928"></a>01928     <span class="keywordflow">else</span>
<a name="l01929"></a>01929         <a class="code" href="class_i_pv6_neighbour_discovery.html#a58a8a7aaf00643c4eb0044cc1380413b">processNAForOtherNCEStates</a>(na, neighbourEntry);
<a name="l01930"></a>01930     <span class="keyword">delete</span> naCtrlInfo;
<a name="l01931"></a>01931     <span class="keyword">delete</span> na;
<a name="l01932"></a>01932 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a7662f293fab21a873bb22edab70de5ce"></a><!-- doxytag: member="IPv6NeighbourDiscovery::processNDMessage" ref="a7662f293fab21a873bb22edab70de5ce" args="(ICMPv6Message *msg, IPv6ControlInfo *ctrlInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPv6NeighbourDiscovery::processNDMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_c_m_pv6_message.html">ICMPv6Message</a> *&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>ctrlInfo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00146">146</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00081">handleMessage()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00148"></a>00148 {
<a name="l00149"></a>00149 
<a name="l00150"></a>00150     <span class="keywordflow">if</span> (dynamic_cast&lt;IPv6RouterSolicitation *&gt;(msg))
<a name="l00151"></a>00151     {
<a name="l00152"></a>00152         <a class="code" href="class_i_pv6_router_solicitation.html">IPv6RouterSolicitation</a> *rs = (<a class="code" href="class_i_pv6_router_solicitation.html">IPv6RouterSolicitation</a> *)msg;
<a name="l00153"></a>00153         <a class="code" href="class_i_pv6_neighbour_discovery.html#ac6f2316e1a19d2816bab83e96d11ef57">processRSPacket</a>(rs, ctrlInfo);
<a name="l00154"></a>00154     }
<a name="l00155"></a>00155     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dynamic_cast&lt;IPv6RouterAdvertisement *&gt;(msg))
<a name="l00156"></a>00156     {
<a name="l00157"></a>00157         <a class="code" href="class_i_pv6_router_advertisement.html">IPv6RouterAdvertisement</a> *ra = (<a class="code" href="class_i_pv6_router_advertisement.html">IPv6RouterAdvertisement</a> *)msg;
<a name="l00158"></a>00158         <a class="code" href="class_i_pv6_neighbour_discovery.html#a4482770f35807ddc238a9259e85752e3">processRAPacket</a>(ra, ctrlInfo);
<a name="l00159"></a>00159     }
<a name="l00160"></a>00160     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dynamic_cast&lt;IPv6NeighbourSolicitation *&gt;(msg))
<a name="l00161"></a>00161     {
<a name="l00162"></a>00162         <a class="code" href="class_i_pv6_neighbour_solicitation.html">IPv6NeighbourSolicitation</a> *ns = (<a class="code" href="class_i_pv6_neighbour_solicitation.html">IPv6NeighbourSolicitation</a> *)msg;
<a name="l00163"></a>00163         <a class="code" href="class_i_pv6_neighbour_discovery.html#a8d7676502f17ed01eb095afadab7bb33">processNSPacket</a>(ns, ctrlInfo);
<a name="l00164"></a>00164     }
<a name="l00165"></a>00165     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dynamic_cast&lt;IPv6NeighbourAdvertisement *&gt;(msg))
<a name="l00166"></a>00166     {
<a name="l00167"></a>00167         <a class="code" href="class_i_pv6_neighbour_advertisement.html">IPv6NeighbourAdvertisement</a> *na = (<a class="code" href="class_i_pv6_neighbour_advertisement.html">IPv6NeighbourAdvertisement</a> *)msg;
<a name="l00168"></a>00168         <a class="code" href="class_i_pv6_neighbour_discovery.html#a348ba5dd9e93f4640d465a74b8a73d53">processNAPacket</a>(na, ctrlInfo);
<a name="l00169"></a>00169     }
<a name="l00170"></a>00170     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dynamic_cast&lt;IPv6Redirect *&gt;(msg))
<a name="l00171"></a>00171     {
<a name="l00172"></a>00172         <a class="code" href="class_i_pv6_redirect.html">IPv6Redirect</a> *redirect = (<a class="code" href="class_i_pv6_redirect.html">IPv6Redirect</a> *)msg;
<a name="l00173"></a>00173         <a class="code" href="class_i_pv6_neighbour_discovery.html#ab95f9c30abcda08c3b762d191df4a3ae">processRedirectPacket</a>(redirect, ctrlInfo);
<a name="l00174"></a>00174     }
<a name="l00175"></a>00175     <span class="keywordflow">else</span>
<a name="l00176"></a>00176     {
<a name="l00177"></a>00177         error(<span class="stringliteral">&quot;Unrecognized ND message!&quot;</span>);
<a name="l00178"></a>00178     }
<a name="l00179"></a>00179 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="abccb93f2300252252370c5cfab5017c6"></a><!-- doxytag: member="IPv6NeighbourDiscovery::processNSForNonTentativeAddress" ref="abccb93f2300252252370c5cfab5017c6" args="(IPv6NeighbourSolicitation *ns, IPv6ControlInfo *ctrlInfo, InterfaceEntry *ie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPv6NeighbourDiscovery::processNSForNonTentativeAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_neighbour_solicitation.html">IPv6NeighbourSolicitation</a> *&nbsp;</td>
          <td class="paramname"> <em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>ctrlInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&nbsp;</td>
          <td class="paramname"> <em>ie</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01699">1699</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01591">processNSPacket()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01701"></a>01701 {
<a name="l01702"></a>01702     <span class="comment">//Neighbour Solicitation Information</span>
<a name="l01703"></a>01703     <a class="code" href="class_m_a_c_address.html">MACAddress</a> nsMacAddr = ns-&gt;<a class="code" href="class_i_pv6_neighbour_solicitation.html#ade4c8874a206e1696e204264db63d415">getSourceLinkLayerAddress</a>();
<a name="l01704"></a>01704 
<a name="l01705"></a>01705     <span class="keywordtype">int</span> ifID = ie-&gt;<a class="code" href="class_interface_entry.html#adc901fa42c37ce16b5c0785da81106ce">getInterfaceId</a>();
<a name="l01706"></a>01706 
<a name="l01707"></a>01707     <span class="comment">//target addr is not tentative addr</span>
<a name="l01708"></a>01708     <span class="comment">//solicitation processed as described in RFC2461:section 7.2.3</span>
<a name="l01709"></a>01709     <span class="keywordflow">if</span> (nsCtrlInfo-&gt;getSrcAddr().isUnspecified())
<a name="l01710"></a>01710     {
<a name="l01711"></a>01711         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Address is duplicate! Inform Sender of duplicate address!\n&quot;</span>;
<a name="l01712"></a>01712         <a class="code" href="class_i_pv6_neighbour_discovery.html#ac2a5f2e2cbd6845ecd10038fce448ead">sendSolicitedNA</a>(ns, nsCtrlInfo, ie);
<a name="l01713"></a>01713     }
<a name="l01714"></a>01714     <span class="keywordflow">else</span>
<a name="l01715"></a>01715     {
<a name="l01716"></a>01716         <a class="code" href="class_i_pv6_neighbour_discovery.html#a8106a5866c58a9c6372c741a15ce943b">processNSWithSpecifiedSrcAddr</a>(ns, nsCtrlInfo, ie);
<a name="l01717"></a>01717     }
<a name="l01718"></a>01718 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a1d21eff02fed770d1bf56dbb995c3db9"></a><!-- doxytag: member="IPv6NeighbourDiscovery::processNSForTentativeAddress" ref="a1d21eff02fed770d1bf56dbb995c3db9" args="(IPv6NeighbourSolicitation *ns, IPv6ControlInfo *ctrlInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPv6NeighbourDiscovery::processNSForTentativeAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_neighbour_solicitation.html">IPv6NeighbourSolicitation</a> *&nbsp;</td>
          <td class="paramname"> <em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>ctrlInfo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01671">1671</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01591">processNSPacket()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01673"></a>01673 {
<a name="l01674"></a>01674     <span class="comment">//Control Information</span>
<a name="l01675"></a>01675     <a class="code" href="class_i_pv6_address.html">IPv6Address</a> nsSrcAddr = nsCtrlInfo-&gt;getSrcAddr();
<a name="l01676"></a>01676     <a class="code" href="class_i_pv6_address.html">IPv6Address</a> nsDestAddr = nsCtrlInfo-&gt;getDestAddr();
<a name="l01677"></a>01677 
<a name="l01678"></a>01678     ASSERT(nsSrcAddr.<a class="code" href="class_i_pv6_address.html#a052b40d4f11c907cfacd29462dd5e385">isUnicast</a>() || nsSrcAddr.<a class="code" href="class_i_pv6_address.html#af526cffcc3a4aa5bb96d307de6e8d448">isUnspecified</a>());
<a name="l01679"></a>01679     <span class="comment">//solicitation is processed as described in RFC2462:section 5.4.3</span>
<a name="l01680"></a>01680 
<a name="l01681"></a>01681     <span class="keywordflow">if</span> (nsSrcAddr.<a class="code" href="class_i_pv6_address.html#af526cffcc3a4aa5bb96d307de6e8d448">isUnspecified</a>())
<a name="l01682"></a>01682     {
<a name="l01683"></a>01683         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Source Address is UNSPECIFIED. Sender is performing DAD\n&quot;</span>;
<a name="l01684"></a>01684         <span class="comment">//Sender performing Duplicate Address Detection</span>
<a name="l01685"></a>01685         <span class="keywordflow">if</span> (<a class="code" href="class_i_pv6_neighbour_discovery.html#a0f6a26512cd490f5a09e9bd7ec3bf61f">rt6</a>-&gt;<a class="code" href="class_routing_table6.html#acbf9dbfff5efa25eec0982afa1bbf061">isLocalAddress</a>(nsSrcAddr))
<a name="l01686"></a>01686             <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;NS comes from myself. Ignoring NS\n&quot;</span>;
<a name="l01687"></a>01687         <span class="keywordflow">else</span>
<a name="l01688"></a>01688             <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;NS comes from another node. Address is duplicate!\n&quot;</span>;
<a name="l01689"></a>01689             error(<span class="stringliteral">&quot;Duplicate Address Detected! Manual Attention Required!&quot;</span>);
<a name="l01690"></a>01690     }
<a name="l01691"></a>01691     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nsSrcAddr.<a class="code" href="class_i_pv6_address.html#a052b40d4f11c907cfacd29462dd5e385">isUnicast</a>())
<a name="l01692"></a>01692     {
<a name="l01693"></a>01693         <span class="comment">//Sender performing address resolution</span>
<a name="l01694"></a>01694         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Sender is performing Address Resolution\n&quot;</span>;
<a name="l01695"></a>01695         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Target Address is tentative. Ignoring NS.\n&quot;</span>;
<a name="l01696"></a>01696     }
<a name="l01697"></a>01697 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a8d7676502f17ed01eb095afadab7bb33"></a><!-- doxytag: member="IPv6NeighbourDiscovery::processNSPacket" ref="a8d7676502f17ed01eb095afadab7bb33" args="(IPv6NeighbourSolicitation *ns, IPv6ControlInfo *naCtrlInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPv6NeighbourDiscovery::processNSPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_neighbour_solicitation.html">IPv6NeighbourSolicitation</a> *&nbsp;</td>
          <td class="paramname"> <em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>naCtrlInfo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01591">1591</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00146">processNDMessage()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01593"></a>01593 {
<a name="l01594"></a>01594     <span class="comment">//Control Information</span>
<a name="l01595"></a>01595     <a class="code" href="class_interface_entry.html">InterfaceEntry</a> *ie = <a class="code" href="class_i_pv6_neighbour_discovery.html#a4b4f35b761b93c397e2a5a36c1e08d38">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a92764d620c345b7261de20e9ee5247d7">getInterfaceById</a>(nsCtrlInfo-&gt;getInterfaceId());
<a name="l01596"></a>01596 
<a name="l01597"></a>01597     <a class="code" href="class_i_pv6_address.html">IPv6Address</a> nsTargetAddr = ns-&gt;<a class="code" href="class_i_pv6_neighbour_solicitation.html#aa8758b1539001a247c925ead4856ec69">getTargetAddress</a>();
<a name="l01598"></a>01598 
<a name="l01599"></a>01599     <span class="comment">//RFC 2461:Section 7.2.3</span>
<a name="l01600"></a>01600     <span class="comment">//If target address is not a valid &quot;unicast&quot; or anycast address assigned to the</span>
<a name="l01601"></a>01601     <span class="comment">//receiving interface, we should silently discard the packet.</span>
<a name="l01602"></a>01602     <span class="keywordflow">if</span> (<a class="code" href="class_i_pv6_neighbour_discovery.html#a72d9ee3401361c560c47f5172c05c1a4">validateNSPacket</a>(ns, nsCtrlInfo) == <span class="keyword">false</span>
<a name="l01603"></a>01603         || ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#af4856e5c4da3563e03fbc388db63ba8a">hasAddress</a>(nsTargetAddr) == <span class="keyword">false</span>)
<a name="l01604"></a>01604     {
<a name="l01605"></a>01605         bubble(<span class="stringliteral">&quot;NS validation failed\n&quot;</span>);
<a name="l01606"></a>01606         <span class="keyword">delete</span> nsCtrlInfo;
<a name="l01607"></a>01607         <span class="keyword">delete</span> ns;
<a name="l01608"></a>01608         <span class="keywordflow">return</span>;
<a name="l01609"></a>01609     }
<a name="l01610"></a>01610     bubble(<span class="stringliteral">&quot;NS validation passed.\n&quot;</span>);
<a name="l01611"></a>01611     <span class="keywordflow">if</span> (ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a90fa17dc7efaa7170176e853cf32dfed">isTentativeAddress</a>(nsTargetAddr))
<a name="l01612"></a>01612     {
<a name="l01613"></a>01613         <span class="comment">//If the Target Address is tentative, the Neighbor Solicitation should</span>
<a name="l01614"></a>01614         <span class="comment">//be processed as described in [ADDRCONF].</span>
<a name="l01615"></a>01615         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Process NS for Tentative target address.\n&quot;</span>;
<a name="l01616"></a>01616         <a class="code" href="class_i_pv6_neighbour_discovery.html#a1d21eff02fed770d1bf56dbb995c3db9">processNSForTentativeAddress</a>(ns, nsCtrlInfo);
<a name="l01617"></a>01617     }
<a name="l01618"></a>01618     <span class="keywordflow">else</span>
<a name="l01619"></a>01619     {
<a name="l01620"></a>01620         <span class="comment">//Otherwise, the following description applies.</span>
<a name="l01621"></a>01621         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Process NS for Non-Tentative target address.\n&quot;</span>;
<a name="l01622"></a>01622         <a class="code" href="class_i_pv6_neighbour_discovery.html#abccb93f2300252252370c5cfab5017c6">processNSForNonTentativeAddress</a>(ns, nsCtrlInfo, ie);
<a name="l01623"></a>01623     }
<a name="l01624"></a>01624     <span class="keyword">delete</span> nsCtrlInfo;
<a name="l01625"></a>01625     <span class="keyword">delete</span> ns;
<a name="l01626"></a>01626 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a8106a5866c58a9c6372c741a15ce943b"></a><!-- doxytag: member="IPv6NeighbourDiscovery::processNSWithSpecifiedSrcAddr" ref="a8106a5866c58a9c6372c741a15ce943b" args="(IPv6NeighbourSolicitation *ns, IPv6ControlInfo *ctrlInfo, InterfaceEntry *ie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPv6NeighbourDiscovery::processNSWithSpecifiedSrcAddr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_neighbour_solicitation.html">IPv6NeighbourSolicitation</a> *&nbsp;</td>
          <td class="paramname"> <em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>ctrlInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&nbsp;</td>
          <td class="paramname"> <em>ie</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01720">1720</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01699">processNSForNonTentativeAddress()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01722"></a>01722 {
<a name="l01723"></a>01723     <span class="comment">//RFC 2461, Section 7.2.3</span>
<a name="l01724"></a>01724     <span class="comment">/*If the Source Address is not the unspecified address and, on link layers</span>
<a name="l01725"></a>01725 <span class="comment">    that have addresses, the solicitation includes a Source Link-Layer Address</span>
<a name="l01726"></a>01726 <span class="comment">    option, then the recipient SHOULD create or update the Neighbor Cache entry</span>
<a name="l01727"></a>01727 <span class="comment">    for the IP Source Address of the solicitation.*/</span>
<a name="l01728"></a>01728 
<a name="l01729"></a>01729     <span class="comment">//Neighbour Solicitation Information</span>
<a name="l01730"></a>01730     <a class="code" href="class_m_a_c_address.html">MACAddress</a> nsMacAddr = ns-&gt;<a class="code" href="class_i_pv6_neighbour_solicitation.html#ade4c8874a206e1696e204264db63d415">getSourceLinkLayerAddress</a>();
<a name="l01731"></a>01731 
<a name="l01732"></a>01732     <span class="keywordtype">int</span> ifID = ie-&gt;<a class="code" href="class_interface_entry.html#adc901fa42c37ce16b5c0785da81106ce">getInterfaceId</a>();
<a name="l01733"></a>01733 
<a name="l01734"></a>01734     <span class="comment">//Look for the Neighbour Cache Entry</span>
<a name="l01735"></a>01735     <a class="code" href="class_i_pv6_neighbour_discovery.html#a13e99f7e1505dd01abbf03066e61384c">Neighbour</a> *entry = <a class="code" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">neighbourCache</a>.<a class="code" href="class_i_pv6_neighbour_cache.html#af88ebc30d5f18f0a628ead79f1fc3cb9">lookup</a>(nsCtrlInfo-&gt;getSrcAddr(), ifID);
<a name="l01736"></a>01736 
<a name="l01737"></a>01737     <span class="keywordflow">if</span> (entry == NULL)
<a name="l01738"></a>01738     {
<a name="l01739"></a>01739         <span class="comment">/*If an entry does not already exist, the node SHOULD create a new one</span>
<a name="l01740"></a>01740 <span class="comment">        and set its reachability state to STALE as specified in Section 7.3.3.*/</span>
<a name="l01741"></a>01741         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Neighbour Entry not found. Create a Neighbour Cache Entry.\n&quot;</span>;
<a name="l01742"></a>01742         <a class="code" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">neighbourCache</a>.<a class="code" href="class_i_pv6_neighbour_cache.html#ab0751209af2b66c4171f92ba6ed7eee1">addNeighbour</a>(nsCtrlInfo-&gt;getSrcAddr(), ifID, nsMacAddr);
<a name="l01743"></a>01743     }
<a name="l01744"></a>01744     <span class="keywordflow">else</span>
<a name="l01745"></a>01745     {
<a name="l01746"></a>01746         <span class="comment">/*If an entry already exists, and the cached link-layer address differs from</span>
<a name="l01747"></a>01747 <span class="comment">        the one in the received Source Link-Layer option,*/</span>
<a name="l01748"></a>01748         <span class="keywordflow">if</span> (!(entry-&gt;macAddress.equals(nsMacAddr)) &amp;&amp; !nsMacAddr.<a class="code" href="class_m_a_c_address.html#ae41af013d782b46483e7d0c84f0ed107">isUnspecified</a>())
<a name="l01749"></a>01749         {
<a name="l01750"></a>01750             <span class="comment">//the cached address should be replaced by the received address</span>
<a name="l01751"></a>01751             entry-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#a3b51b5802cd50245bc2cdbbca1069dd0">macAddress</a> = nsMacAddr;
<a name="l01752"></a>01752             <span class="comment">//and the entry&apos;s reachability state MUST be set to STALE.</span>
<a name="l01753"></a>01753             entry-&gt;reachabilityState = <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a115199155dd43585124db1d8f471025b">IPv6NeighbourCache::STALE</a>;
<a name="l01754"></a>01754         }
<a name="l01755"></a>01755     }
<a name="l01756"></a>01756     <span class="comment">/*After any updates to the Neighbor Cache, the node sends a Neighbor</span>
<a name="l01757"></a>01757 <span class="comment">    Advertisement response as described in the next section.*/</span>
<a name="l01758"></a>01758     <a class="code" href="class_i_pv6_neighbour_discovery.html#ac2a5f2e2cbd6845ecd10038fce448ead">sendSolicitedNA</a>(ns, nsCtrlInfo, ie);
<a name="l01759"></a>01759 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a623b4069795d46d2b421d5aee4f1eb59"></a><!-- doxytag: member="IPv6NeighbourDiscovery::processNUDTimeout" ref="a623b4069795d46d2b421d5aee4f1eb59" args="(cMessage *timeoutMsg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPv6NeighbourDiscovery::processNUDTimeout </td>
          <td>(</td>
          <td class="paramtype">cMessage *&nbsp;</td>
          <td class="paramname"> <em>timeoutMsg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00449">449</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00081">handleMessage()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00450"></a>00450 {
<a name="l00451"></a>00451     <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;NUD has timed out\n&quot;</span>;
<a name="l00452"></a>00452     <a class="code" href="class_i_pv6_neighbour_discovery.html#a13e99f7e1505dd01abbf03066e61384c">Neighbour</a> *nce = (<a class="code" href="class_i_pv6_neighbour_discovery.html#a13e99f7e1505dd01abbf03066e61384c">Neighbour</a> *) timeoutMsg-&gt;getContextPointer();
<a name="l00453"></a>00453     <span class="keyword">const</span> <a class="code" href="class_i_pv6_neighbour_discovery.html#a747705ed3b49881e2d144e2d9f0c8044">Key</a> *nceKey = nce-&gt;nceKey;
<a name="l00454"></a>00454     <a class="code" href="class_interface_entry.html">InterfaceEntry</a> *ie = <a class="code" href="class_i_pv6_neighbour_discovery.html#a4b4f35b761b93c397e2a5a36c1e08d38">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a92764d620c345b7261de20e9ee5247d7">getInterfaceById</a>(nceKey-&gt;interfaceID);
<a name="l00455"></a>00455 
<a name="l00456"></a>00456     <span class="keywordflow">if</span> (nce-&gt;reachabilityState == <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a815cc3dd5d8b220495a69641b00f5bdb">IPv6NeighbourCache::DELAY</a>)
<a name="l00457"></a>00457     {
<a name="l00458"></a>00458         <span class="comment">/*If the entry is still in the DELAY state when the timer expires, the</span>
<a name="l00459"></a>00459 <span class="comment">        entry&apos;s state changes to PROBE. If reachability confirmation is received,</span>
<a name="l00460"></a>00460 <span class="comment">        the entry&apos;s state changes to REACHABLE.*/</span>
<a name="l00461"></a>00461         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Neighbour Entry is still in DELAY state.\n&quot;</span>;
<a name="l00462"></a>00462         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Entering PROBE state. Sending NS probe.\n&quot;</span>;
<a name="l00463"></a>00463         nce-&gt;reachabilityState = <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a8fdd2d1853264aa8f5479ebfa6502054">IPv6NeighbourCache::PROBE</a>;
<a name="l00464"></a>00464         nce-&gt;numProbesSent = 0;
<a name="l00465"></a>00465     }
<a name="l00466"></a>00466 
<a name="l00467"></a>00467     <span class="comment">/*If no response is received after waiting RetransTimer milliseconds</span>
<a name="l00468"></a>00468 <span class="comment">    after sending the MAX_UNICAST_SOLICIT solicitations, retransmissions cease</span>
<a name="l00469"></a>00469 <span class="comment">    and the entry SHOULD be deleted. Subsequent traffic to that neighbor will</span>
<a name="l00470"></a>00470 <span class="comment">    recreate the entry and performs address resolution again.*/</span>
<a name="l00471"></a>00471     <span class="keywordflow">if</span> (nce-&gt;numProbesSent == (<span class="keywordtype">int</span>)ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#af9eb8f221b38bd240ac1dcbf5b3917b5">_getMaxUnicastSolicit</a>())
<a name="l00472"></a>00472     {
<a name="l00473"></a>00473         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Max number of probes have been sent.&quot;</span> &lt;&lt; endl;
<a name="l00474"></a>00474         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Neighbour is Unreachable, removing NCE.&quot;</span> &lt;&lt; endl;
<a name="l00475"></a>00475         <a class="code" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">neighbourCache</a>.<a class="code" href="class_i_pv6_neighbour_cache.html#a877bc367ca422baabc22199c5036df83">remove</a>(nceKey-&gt;address, nceKey-&gt;interfaceID);
<a name="l00476"></a>00476         <span class="keywordflow">return</span>;
<a name="l00477"></a>00477     }
<a name="l00478"></a>00478 
<a name="l00479"></a>00479     <span class="comment">/*Upon entering the PROBE state, a node sends a unicast Neighbor Solicitation</span>
<a name="l00480"></a>00480 <span class="comment">    message to the neighbor using the cached link-layer address.*/</span>
<a name="l00481"></a>00481     <a class="code" href="class_i_pv6_neighbour_discovery.html#aedad2b550812f9be54ab691296e5876d">createAndSendNSPacket</a>(nceKey-&gt;address, nceKey-&gt;address,
<a name="l00482"></a>00482         ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a56f3fe4007e3df66dc88edd008f059b9">getPreferredAddress</a>(), ie);
<a name="l00483"></a>00483     nce-&gt;numProbesSent++;
<a name="l00484"></a>00484     <span class="comment">/*While in the PROBE state, a node retransmits Neighbor Solicitation messages</span>
<a name="l00485"></a>00485 <span class="comment">    every RetransTimer milliseconds until reachability confirmation is obtained.</span>
<a name="l00486"></a>00486 <span class="comment">    Probes are retransmitted even if no additional packets are sent to the</span>
<a name="l00487"></a>00487 <span class="comment">    neighbor.*/</span>
<a name="l00488"></a>00488     scheduleAt(simTime()+ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a089952430501d3e7a4f82481caf8be61">_getRetransTimer</a>(), timeoutMsg);
<a name="l00489"></a>00489 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a41da6658d387e46e3e656d4704bf908f"></a><!-- doxytag: member="IPv6NeighbourDiscovery::processRAForRouterUpdates" ref="a41da6658d387e46e3e656d4704bf908f" args="(IPv6RouterAdvertisement *ra, IPv6ControlInfo *raCtrlInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPv6NeighbourDiscovery::processRAForRouterUpdates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_router_advertisement.html">IPv6RouterAdvertisement</a> *&nbsp;</td>
          <td class="paramname"> <em>ra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>raCtrlInfo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01153">1153</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01116">processRAPacket()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01155"></a>01155 {
<a name="l01156"></a>01156     <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Processing RA for Router Updates\n&quot;</span>;
<a name="l01157"></a>01157     <span class="comment">//RFC2461: Section 6.3.4</span>
<a name="l01158"></a>01158     <span class="comment">//Paragraphs 1 and 2 omitted.</span>
<a name="l01159"></a>01159 
<a name="l01160"></a>01160     <span class="comment">//On receipt of a valid Router Advertisement, a host extracts the source</span>
<a name="l01161"></a>01161     <span class="comment">//address of the packet and does the following:</span>
<a name="l01162"></a>01162     <a class="code" href="class_i_pv6_address.html">IPv6Address</a> raSrcAddr = raCtrlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a8980bdcd6051ae3fe071bf2c18a0215e">getSrcAddr</a>();
<a name="l01163"></a>01163     <a class="code" href="class_interface_entry.html">InterfaceEntry</a> *ie = <a class="code" href="class_i_pv6_neighbour_discovery.html#a4b4f35b761b93c397e2a5a36c1e08d38">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a92764d620c345b7261de20e9ee5247d7">getInterfaceById</a>(raCtrlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a74046fa005d98f0c304eb39eb28a1ec3">getInterfaceId</a>());
<a name="l01164"></a>01164     <span class="keywordtype">int</span> ifID = ie-&gt;<a class="code" href="class_interface_entry.html#adc901fa42c37ce16b5c0785da81106ce">getInterfaceId</a>();
<a name="l01165"></a>01165 
<a name="l01166"></a>01166     <span class="comment">/*- If the address is not already present in the host&apos;s Default Router List,</span>
<a name="l01167"></a>01167 <span class="comment">    and the advertisement&apos;s Router Lifetime is non-zero, create a new entry in</span>
<a name="l01168"></a>01168 <span class="comment">    the list, and initialize its invalidation timer value from the advertisement&apos;s</span>
<a name="l01169"></a>01169 <span class="comment">    Router Lifetime field.*/</span>
<a name="l01170"></a>01170     <a class="code" href="class_i_pv6_neighbour_discovery.html#a13e99f7e1505dd01abbf03066e61384c">Neighbour</a> *neighbour = <a class="code" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">neighbourCache</a>.<a class="code" href="class_i_pv6_neighbour_cache.html#af88ebc30d5f18f0a628ead79f1fc3cb9">lookup</a>(raSrcAddr, ifID);
<a name="l01171"></a>01171     <span class="keywordflow">if</span> (neighbour == NULL)
<a name="l01172"></a>01172     {
<a name="l01173"></a>01173         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Neighbour Cache Entry does not contain RA&apos;s source address\n&quot;</span>;
<a name="l01174"></a>01174         <span class="keywordflow">if</span> (ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a8792d1615047ca1fbaa446c1a8316f9a">getRouterLifetime</a>() != 0)
<a name="l01175"></a>01175         {
<a name="l01176"></a>01176             <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;RA&apos;s router lifetime is non-zero, creating an entry in the &quot;</span>
<a name="l01177"></a>01177                &lt;&lt; <span class="stringliteral">&quot;Host&apos;s default router list.\n&quot;</span> &lt;&lt; ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a8792d1615047ca1fbaa446c1a8316f9a">getRouterLifetime</a>();
<a name="l01178"></a>01178             <span class="comment">//If a Neighbor Cache entry is created for the router its reachability</span>
<a name="l01179"></a>01179             <span class="comment">//state MUST be set to STALE as specified in Section 7.3.3.</span>
<a name="l01180"></a>01180             <span class="keywordflow">if</span> (ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a705aaac520402119b8aa6e9efc5ceb64">getSourceLinkLayerAddress</a>().<a class="code" href="class_m_a_c_address.html#ae41af013d782b46483e7d0c84f0ed107">isUnspecified</a>())
<a name="l01181"></a>01181             {
<a name="l01182"></a>01182                 neighbour = <a class="code" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">neighbourCache</a>.<a class="code" href="class_i_pv6_neighbour_cache.html#a13016f349669033902152b07d1e466aa">addRouter</a>(raSrcAddr, ifID,
<a name="l01183"></a>01183                     simTime()+ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a8792d1615047ca1fbaa446c1a8316f9a">getRouterLifetime</a>());
<a name="l01184"></a>01184                 <span class="comment">//Note:invalidation timers are not explicitly defined.</span>
<a name="l01185"></a>01185             }
<a name="l01186"></a>01186             <span class="keywordflow">else</span>
<a name="l01187"></a>01187             {
<a name="l01188"></a>01188                 neighbour = <a class="code" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">neighbourCache</a>.<a class="code" href="class_i_pv6_neighbour_cache.html#a13016f349669033902152b07d1e466aa">addRouter</a>(raSrcAddr, ifID,
<a name="l01189"></a>01189                     ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a705aaac520402119b8aa6e9efc5ceb64">getSourceLinkLayerAddress</a>(), simTime()+ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a8792d1615047ca1fbaa446c1a8316f9a">getRouterLifetime</a>());
<a name="l01190"></a>01190                 <span class="comment">//According to Greg, we should add a default route for hosts as well!</span>
<a name="l01191"></a>01191                 <a class="code" href="class_i_pv6_neighbour_discovery.html#a0f6a26512cd490f5a09e9bd7ec3bf61f">rt6</a>-&gt;<a class="code" href="class_routing_table6.html#a50f73e181d9c5e965ad72f74f0b43c40">addDefaultRoute</a>(raSrcAddr, ifID, simTime()+ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a8792d1615047ca1fbaa446c1a8316f9a">getRouterLifetime</a>());
<a name="l01192"></a>01192             }
<a name="l01193"></a>01193         }
<a name="l01194"></a>01194         <span class="keywordflow">else</span>
<a name="l01195"></a>01195         {
<a name="l01196"></a>01196             <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Router Lifetime is 0, adding NON-default router.\n&quot;</span>;
<a name="l01197"></a>01197             <span class="comment">//WEI-The router is advertising itself, BUT not as a default router.</span>
<a name="l01198"></a>01198             <span class="keywordflow">if</span> (ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a705aaac520402119b8aa6e9efc5ceb64">getSourceLinkLayerAddress</a>().<a class="code" href="class_m_a_c_address.html#ae41af013d782b46483e7d0c84f0ed107">isUnspecified</a>())
<a name="l01199"></a>01199                 neighbour = <a class="code" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">neighbourCache</a>.<a class="code" href="class_i_pv6_neighbour_cache.html#ab0751209af2b66c4171f92ba6ed7eee1">addNeighbour</a>(raSrcAddr, ifID);
<a name="l01200"></a>01200             <span class="keywordflow">else</span>
<a name="l01201"></a>01201                 neighbour = <a class="code" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">neighbourCache</a>.<a class="code" href="class_i_pv6_neighbour_cache.html#ab0751209af2b66c4171f92ba6ed7eee1">addNeighbour</a>(raSrcAddr, ifID,
<a name="l01202"></a>01202                     ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a705aaac520402119b8aa6e9efc5ceb64">getSourceLinkLayerAddress</a>());
<a name="l01203"></a>01203             neighbour-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#af5203d6dd6d97a8b2baf782f44f8206f">isRouter</a> = <span class="keyword">true</span>;
<a name="l01204"></a>01204         }
<a name="l01205"></a>01205     }
<a name="l01206"></a>01206     <span class="keywordflow">else</span>
<a name="l01207"></a>01207     {
<a name="l01208"></a>01208         <span class="comment">//If no Source Link-Layer Address is included, but a corresponding Neighbor</span>
<a name="l01209"></a>01209         <span class="comment">//Cache entry exists, its IsRouter flag MUST be set to TRUE.</span>
<a name="l01210"></a>01210         neighbour-&gt;isRouter = <span class="keyword">true</span>;
<a name="l01211"></a>01211 
<a name="l01212"></a>01212         <span class="comment">//If a cache entry already exists and is updated with a different link-</span>
<a name="l01213"></a>01213         <span class="comment">//layer address the reachability state MUST also be set to STALE.</span>
<a name="l01214"></a>01214         <span class="keywordflow">if</span> (ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a705aaac520402119b8aa6e9efc5ceb64">getSourceLinkLayerAddress</a>().<a class="code" href="class_m_a_c_address.html#ae41af013d782b46483e7d0c84f0ed107">isUnspecified</a>() == <span class="keyword">false</span> &amp;&amp;
<a name="l01215"></a>01215             neighbour-&gt;macAddress.equals(ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a705aaac520402119b8aa6e9efc5ceb64">getSourceLinkLayerAddress</a>()) == <span class="keyword">false</span>)
<a name="l01216"></a>01216             neighbour-&gt;macAddress = ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a705aaac520402119b8aa6e9efc5ceb64">getSourceLinkLayerAddress</a>();
<a name="l01217"></a>01217 
<a name="l01218"></a>01218         <span class="comment">/*- If the address is already present in the host&apos;s Default Router List</span>
<a name="l01219"></a>01219 <span class="comment">        as a result of a previously-received advertisement, reset its invalidation</span>
<a name="l01220"></a>01220 <span class="comment">        timer to the Router Lifetime value in the newly-received advertisement.*/</span>
<a name="l01221"></a>01221         neighbour-&gt;routerExpiryTime = simTime()+ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a8792d1615047ca1fbaa446c1a8316f9a">getRouterLifetime</a>();
<a name="l01222"></a>01222 
<a name="l01223"></a>01223         <span class="comment">/*- If the address is already present in the host&apos;s Default Router List</span>
<a name="l01224"></a>01224 <span class="comment">        and the received Router Lifetime value is zero, immediately time-out the</span>
<a name="l01225"></a>01225 <span class="comment">        entry as specified in Section 6.3.5.*/</span>
<a name="l01226"></a>01226         <span class="keywordflow">if</span> (ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a8792d1615047ca1fbaa446c1a8316f9a">getRouterLifetime</a>() == 0)
<a name="l01227"></a>01227         {
<a name="l01228"></a>01228             <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;RA&apos;s router lifetime is ZERO. Timing-out entry.\n&quot;</span>;
<a name="l01229"></a>01229             <a class="code" href="class_i_pv6_neighbour_discovery.html#a303391440ad2004ff69cfc5e4cf7504a">timeoutDefaultRouter</a>(raSrcAddr, ifID);
<a name="l01230"></a>01230         }
<a name="l01231"></a>01231     }
<a name="l01232"></a>01232 
<a name="l01233"></a>01233     <span class="comment">//Paragraph Omitted.</span>
<a name="l01234"></a>01234 
<a name="l01235"></a>01235     <span class="comment">//If the received Cur Hop Limit value is non-zero the host SHOULD set</span>
<a name="l01236"></a>01236     <span class="comment">//its CurHopLimit variable to the received value.</span>
<a name="l01237"></a>01237     <span class="keywordflow">if</span> (ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a0a81a0acaac716d216feb8f859d199a1">getCurHopLimit</a>() != 0)
<a name="l01238"></a>01238     {
<a name="l01239"></a>01239         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;RA&apos;s Cur Hop Limit is non-zero. Setting host&apos;s Cur Hop Limit to &quot;</span>
<a name="l01240"></a>01240            &lt;&lt; <span class="stringliteral">&quot;received value.\n&quot;</span>;
<a name="l01241"></a>01241         ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a1ea2f32f4ae7ebbfa060ea5af5b7c603">setCurHopLimit</a>(ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a0a81a0acaac716d216feb8f859d199a1">getCurHopLimit</a>());
<a name="l01242"></a>01242     }
<a name="l01243"></a>01243 
<a name="l01244"></a>01244     <span class="comment">//If the received Reachable Time value is non-zero the host SHOULD set its</span>
<a name="l01245"></a>01245     <span class="comment">//BaseReachableTime variable to the received value.</span>
<a name="l01246"></a>01246     <span class="keywordflow">if</span> (ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#acfc4519404fc893bc99e7f0d9e1d531e">getReachableTime</a>() != 0)
<a name="l01247"></a>01247     {
<a name="l01248"></a>01248         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;RA&apos;s reachable time is non-zero &quot;</span>;
<a name="l01249"></a>01249         <span class="keywordflow">if</span> (ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#acfc4519404fc893bc99e7f0d9e1d531e">getReachableTime</a>() != SIMTIME_DBL(ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#afe19d3650ea8762180d97b18d5b3c131">getReachableTime</a>()))
<a name="l01250"></a>01250         {
<a name="l01251"></a>01251             <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot; and RA&apos;s and Host&apos;s reachable time differ, \nsetting host&apos;s base&quot;</span>
<a name="l01252"></a>01252                &lt;&lt; <span class="stringliteral">&quot; reachable time to received value.\n&quot;</span>;
<a name="l01253"></a>01253             ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#ae4305f5d17e9073b911ab750b3a4fb78">setBaseReachableTime</a>(ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#acfc4519404fc893bc99e7f0d9e1d531e">getReachableTime</a>());
<a name="l01254"></a>01254             <span class="comment">//If the new value differs from the previous value, the host SHOULD</span>
<a name="l01255"></a>01255             <span class="comment">//recompute a new random ReachableTime value.</span>
<a name="l01256"></a>01256             ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#aa9a9bd84379adbe33bb06319f8e1e807">setReachableTime</a>(ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a923ed5aa070331f87ff6a541387b046a">generateReachableTime</a>());
<a name="l01257"></a>01257         }
<a name="l01258"></a>01258         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; endl;
<a name="l01259"></a>01259     }
<a name="l01260"></a>01260 
<a name="l01261"></a>01261     <span class="comment">//The RetransTimer variable SHOULD be copied from the Retrans Timer field,</span>
<a name="l01262"></a>01262     <span class="comment">//if the received value is non-zero.</span>
<a name="l01263"></a>01263     <span class="keywordflow">if</span> (ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a7478bb558c46dec7f012860622cff7e2">getRetransTimer</a>() != 0)
<a name="l01264"></a>01264     {
<a name="l01265"></a>01265         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;RA&apos;s retrans timer is non-zero, copying retrans timer variable.\n&quot;</span>;
<a name="l01266"></a>01266         ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#ae017519c2fb2144ad9e5827f12cb4740">setRetransTimer</a>(ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a7478bb558c46dec7f012860622cff7e2">getRetransTimer</a>());
<a name="l01267"></a>01267     }
<a name="l01268"></a>01268 
<a name="l01269"></a>01269     <span class="comment">/*If the MTU option is present, hosts SHOULD copy the option&apos;s value into</span>
<a name="l01270"></a>01270 <span class="comment">    LinkMTU so long as the value is greater than or equal to the minimum link MTU</span>
<a name="l01271"></a>01271 <span class="comment">    [IPv6] and does not exceed the default LinkMTU value specified in the link</span>
<a name="l01272"></a>01272 <span class="comment">    type specific document (e.g., [IPv6-ETHER]).*/</span>
<a name="l01273"></a>01273     <span class="comment">//TODO: not done yet</span>
<a name="l01274"></a>01274 
<a name="l01275"></a>01275     <a class="code" href="class_i_pv6_neighbour_discovery.html#a5acf0814f6ca500c38d87763c0a5aef7">processRAPrefixInfo</a>(ra, ie);
<a name="l01276"></a>01276 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a4482770f35807ddc238a9259e85752e3"></a><!-- doxytag: member="IPv6NeighbourDiscovery::processRAPacket" ref="a4482770f35807ddc238a9259e85752e3" args="(IPv6RouterAdvertisement *ra, IPv6ControlInfo *raCtrlInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPv6NeighbourDiscovery::processRAPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_router_advertisement.html">IPv6RouterAdvertisement</a> *&nbsp;</td>
          <td class="paramname"> <em>ra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>raCtrlInfo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01116">1116</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00146">processNDMessage()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01118"></a>01118 {
<a name="l01119"></a>01119     <a class="code" href="class_interface_entry.html">InterfaceEntry</a> *ie = <a class="code" href="class_i_pv6_neighbour_discovery.html#a4b4f35b761b93c397e2a5a36c1e08d38">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a92764d620c345b7261de20e9ee5247d7">getInterfaceById</a>(raCtrlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a74046fa005d98f0c304eb39eb28a1ec3">getInterfaceId</a>());
<a name="l01120"></a>01120 
<a name="l01121"></a>01121     <span class="keywordflow">if</span> (ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a3e629909076b47fa0886f83fbb7af09a">getAdvSendAdvertisements</a>())
<a name="l01122"></a>01122     {
<a name="l01123"></a>01123         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Interface is an advertising interface, dropping RA message.\n&quot;</span>;
<a name="l01124"></a>01124         <span class="keyword">delete</span> ra;
<a name="l01125"></a>01125         <span class="keywordflow">return</span>;
<a name="l01126"></a>01126     }
<a name="l01127"></a>01127     <span class="keywordflow">else</span>
<a name="l01128"></a>01128     {
<a name="l01129"></a>01129         <span class="keywordflow">if</span> (<a class="code" href="class_i_pv6_neighbour_discovery.html#a902261563ea0bd130700a148a062781c">validateRAPacket</a>(ra, raCtrlInfo) == <span class="keyword">false</span>)
<a name="l01130"></a>01130         {
<a name="l01131"></a>01131             <span class="keyword">delete</span> ra;
<a name="l01132"></a>01132             <span class="keywordflow">return</span>;
<a name="l01133"></a>01133         }
<a name="l01134"></a>01134         <a class="code" href="class_i_pv6_neighbour_discovery.html#a01e12e84e38baf2539a8335f8f01abc6">cancelRouterDiscovery</a>(ie);<span class="comment">//Cancel router discovery if it is in progress.</span>
<a name="l01135"></a>01135         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Interface is a host, processing RA.\n&quot;</span>;
<a name="l01136"></a>01136 
<a name="l01137"></a>01137         <a class="code" href="class_i_pv6_neighbour_discovery.html#a41da6658d387e46e3e656d4704bf908f">processRAForRouterUpdates</a>(ra, raCtrlInfo);<span class="comment">//See RFC2461: Section 6.3.4</span>
<a name="l01138"></a>01138 
<a name="l01139"></a>01139         <span class="comment">//Possible options</span>
<a name="l01140"></a>01140         <a class="code" href="class_m_a_c_address.html">MACAddress</a> macAddress = ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a705aaac520402119b8aa6e9efc5ceb64">getSourceLinkLayerAddress</a>();
<a name="l01141"></a>01141         <a class="code" href="_i_n_e_t_defs_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> mtu = ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#ac81af8393ce5a310e51a126d37a50751">getMTU</a>();
<a name="l01142"></a>01142         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (int)ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a5189c47459ce2df26c6067b00bf6a670">getPrefixInformationArraySize</a>(); i++)
<a name="l01143"></a>01143         {
<a name="l01144"></a>01144             <a class="code" href="class_i_pv6_n_d_prefix_information.html">IPv6NDPrefixInformation</a>&amp; prefixInfo = ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#ab0392fb8b0189220ef2c47c8fa3dc898">getPrefixInformation</a>(i);
<a name="l01145"></a>01145             <span class="keywordflow">if</span> (prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#a8d2e5ddefb6960d75a594dad8574c1c6">getAutoAddressConfFlag</a>() == <span class="keyword">true</span>)<span class="comment">//If auto addr conf is set</span>
<a name="l01146"></a>01146                 <a class="code" href="class_i_pv6_neighbour_discovery.html#ae187033477823763f0fc0063353821f6">processRAPrefixInfoForAddrAutoConf</a>(prefixInfo, ie);<span class="comment">//We process prefix Info and form an addr</span>
<a name="l01147"></a>01147         }
<a name="l01148"></a>01148     }
<a name="l01149"></a>01149     <span class="keyword">delete</span> raCtrlInfo;
<a name="l01150"></a>01150     <span class="keyword">delete</span> ra;
<a name="l01151"></a>01151 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a5acf0814f6ca500c38d87763c0a5aef7"></a><!-- doxytag: member="IPv6NeighbourDiscovery::processRAPrefixInfo" ref="a5acf0814f6ca500c38d87763c0a5aef7" args="(IPv6RouterAdvertisement *ra, InterfaceEntry *ie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPv6NeighbourDiscovery::processRAPrefixInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_router_advertisement.html">IPv6RouterAdvertisement</a> *&nbsp;</td>
          <td class="paramname"> <em>ra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&nbsp;</td>
          <td class="paramname"> <em>ie</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01278">1278</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01153">processRAForRouterUpdates()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01280"></a>01280 {
<a name="l01281"></a>01281     <span class="comment">//Continued from section 6.3.4</span>
<a name="l01282"></a>01282     <span class="comment">/*Prefix Information options that have the &quot;on-link&quot; (L) flag set indicate a</span>
<a name="l01283"></a>01283 <span class="comment">    prefix identifying a range of addresses that should be considered on-link.</span>
<a name="l01284"></a>01284 <span class="comment">    Note, however, that a Prefix Information option with the on-link flag set to</span>
<a name="l01285"></a>01285 <span class="comment">    zero conveys no information concerning on-link determination and MUST NOT be</span>
<a name="l01286"></a>01286 <span class="comment">    interpreted to mean that addresses covered by the prefix are off-link. The</span>
<a name="l01287"></a>01287 <span class="comment">    only way to cancel a previous on-link indication is to advertise that prefix</span>
<a name="l01288"></a>01288 <span class="comment">    with the L-bit set and the Lifetime set to zero. The default behavior (see</span>
<a name="l01289"></a>01289 <span class="comment">    Section 5.2) when sending a packet to an address for which no information is</span>
<a name="l01290"></a>01290 <span class="comment">    known about the on-link status of the address is to forward the packet to a</span>
<a name="l01291"></a>01291 <span class="comment">    default router; the reception of a Prefix Information option with the &quot;on-link &quot;</span>
<a name="l01292"></a>01292 <span class="comment">    (L) flag set to zero does not change this behavior. The reasons for an address</span>
<a name="l01293"></a>01293 <span class="comment">    being treated as on-link is specified in the definition of &quot;on-link&quot; in</span>
<a name="l01294"></a>01294 <span class="comment">    Section 2.1. Prefixes with the on-link flag set to zero would normally have</span>
<a name="l01295"></a>01295 <span class="comment">    the autonomous flag set and be used by [ADDRCONF].*/</span>
<a name="l01296"></a>01296     <a class="code" href="class_i_pv6_n_d_prefix_information.html">IPv6NDPrefixInformation</a> prefixInfo;
<a name="l01297"></a>01297     <span class="comment">//For each Prefix Information option</span>
<a name="l01298"></a>01298     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (int)ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a5189c47459ce2df26c6067b00bf6a670">getPrefixInformationArraySize</a>(); i++)
<a name="l01299"></a>01299     {
<a name="l01300"></a>01300         prefixInfo = ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#ab0392fb8b0189220ef2c47c8fa3dc898">getPrefixInformation</a>(i);
<a name="l01301"></a>01301         <span class="keywordflow">if</span> (!prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#a62f9e56892d77b017288a1461d8edba1">getOnlinkFlag</a>()) <span class="keywordflow">break</span>;<span class="comment">//skip to next prefix option</span>
<a name="l01302"></a>01302 
<a name="l01303"></a>01303         <span class="comment">//with the on-link flag set, a host does the following:</span>
<a name="l01304"></a>01304         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Fetching Prefix Information:&quot;</span> &lt;&lt; i+1 &lt;&lt; <span class="stringliteral">&quot; of &quot;</span>
<a name="l01305"></a>01305            &lt;&lt; ra-&gt;<a class="code" href="class_i_pv6_router_advertisement.html#a5189c47459ce2df26c6067b00bf6a670">getPrefixInformationArraySize</a>() &lt;&lt; endl;
<a name="l01306"></a>01306         <a class="code" href="_i_n_e_t_defs_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> prefixLength = prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#a6660082e882c5e64e664b352d2fe31d9">getPrefixLength</a>();
<a name="l01307"></a>01307         simtime_t validLifetime = prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#a93e32dbccf0d60cff0269f4450d6323e">getValidLifetime</a>();
<a name="l01308"></a>01308         <a class="code" href="_i_n_e_t_defs_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> preferredLifetime = prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#a4bbcfaafccb44d3e136cd17627f46641">getPreferredLifetime</a>();
<a name="l01309"></a>01309         <a class="code" href="class_i_pv6_address.html">IPv6Address</a> prefix = prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#a769743b8ab554bc69cc0830652aa5c1d">getPrefix</a>();
<a name="l01310"></a>01310 
<a name="l01311"></a>01311         <span class="comment">//- If the prefix is the link-local prefix, silently ignore the Prefix</span>
<a name="l01312"></a>01312         <span class="comment">//Information option.</span>
<a name="l01313"></a>01313         <span class="keywordflow">if</span> (prefix.<a class="code" href="class_i_pv6_address.html#a304edc5014ff3c991ae531aca21d2260">isLinkLocal</a>())
<a name="l01314"></a>01314         {
<a name="l01315"></a>01315             <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Prefix is link-local, ignoring prefix.\n&quot;</span>;
<a name="l01316"></a>01316             <span class="keywordflow">return</span>;
<a name="l01317"></a>01317         }
<a name="l01318"></a>01318 
<a name="l01319"></a>01319         <span class="comment">//- If the prefix is not already present in the Prefix List,</span>
<a name="l01320"></a>01320         <span class="keywordflow">if</span> (!<a class="code" href="class_i_pv6_neighbour_discovery.html#a0f6a26512cd490f5a09e9bd7ec3bf61f">rt6</a>-&gt;<a class="code" href="class_routing_table6.html#afef0aa2431b02b3744b58238c7a73547">isPrefixPresent</a>(prefix)) {
<a name="l01321"></a>01321             <span class="comment">//and the Prefix Information option&apos;s Valid Lifetime field is non-zero,</span>
<a name="l01322"></a>01322             <span class="keywordflow">if</span> (validLifetime != 0)
<a name="l01323"></a>01323             {
<a name="l01324"></a>01324                 <span class="comment">/*create a new entry for the prefix and initialize its invalidation</span>
<a name="l01325"></a>01325 <span class="comment">                timer to the Valid Lifetime value in the Prefix Information option.*/</span>
<a name="l01326"></a>01326                 <a class="code" href="class_i_pv6_neighbour_discovery.html#a0f6a26512cd490f5a09e9bd7ec3bf61f">rt6</a>-&gt;<a class="code" href="class_routing_table6.html#ad942d6cb5b1376b132947f75924344f6">addOrUpdateOnLinkPrefix</a>(prefix, prefixLength, ie-&gt;<a class="code" href="class_interface_entry.html#adc901fa42c37ce16b5c0785da81106ce">getInterfaceId</a>(),
<a name="l01327"></a>01327                     simTime()+validLifetime);
<a name="l01328"></a>01328             }
<a name="l01329"></a>01329             <span class="comment">/*- If the Prefix Information option&apos;s Valid Lifetime field is zero,</span>
<a name="l01330"></a>01330 <span class="comment">            and the prefix is not present in the host&apos;s Prefix List,</span>
<a name="l01331"></a>01331 <span class="comment">            silently ignore the option.*/</span>
<a name="l01332"></a>01332         }
<a name="l01333"></a>01333         <span class="keywordflow">else</span>
<a name="l01334"></a>01334         {
<a name="l01335"></a>01335             <span class="comment">/* If the new Lifetime value is zero, time-out the prefix immediately</span>
<a name="l01336"></a>01336 <span class="comment">            (see Section 6.3.5).*/</span>
<a name="l01337"></a>01337             <span class="keywordflow">if</span> (validLifetime == 0)
<a name="l01338"></a>01338             {
<a name="l01339"></a>01339                 <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Prefix Info&apos;s valid lifetime is 0, time-out prefix\n&quot;</span>;
<a name="l01340"></a>01340                 <a class="code" href="class_i_pv6_neighbour_discovery.html#a0f6a26512cd490f5a09e9bd7ec3bf61f">rt6</a>-&gt;<a class="code" href="class_routing_table6.html#a85e00922381c188efc0ad51197e5f718">removeOnLinkPrefix</a>(prefix, prefixLength);
<a name="l01341"></a>01341                 <span class="keywordflow">return</span>;
<a name="l01342"></a>01342             }
<a name="l01343"></a>01343             <span class="comment">/*- If the prefix is already present in the host&apos;s Prefix List as</span>
<a name="l01344"></a>01344 <span class="comment">            the result of a previously-received advertisement, reset its</span>
<a name="l01345"></a>01345 <span class="comment">            invalidation timer to the Valid Lifetime value in the Prefix</span>
<a name="l01346"></a>01346 <span class="comment">            Information option.*/</span>
<a name="l01347"></a>01347             <a class="code" href="class_i_pv6_neighbour_discovery.html#a0f6a26512cd490f5a09e9bd7ec3bf61f">rt6</a>-&gt;<a class="code" href="class_routing_table6.html#ad942d6cb5b1376b132947f75924344f6">addOrUpdateOnLinkPrefix</a>(prefix, prefixLength, ie-&gt;<a class="code" href="class_interface_entry.html#adc901fa42c37ce16b5c0785da81106ce">getInterfaceId</a>(),
<a name="l01348"></a>01348                 simTime()+validLifetime);
<a name="l01349"></a>01349         }
<a name="l01350"></a>01350 
<a name="l01351"></a>01351         <span class="comment">/*Stateless address autoconfiguration [ADDRCONF] may in some</span>
<a name="l01352"></a>01352 <span class="comment">        circumstances increase the Valid Lifetime of a prefix or ignore it</span>
<a name="l01353"></a>01353 <span class="comment">        completely in order to prevent a particular denial of service attack.</span>
<a name="l01354"></a>01354 <span class="comment">        However, since the effect of the same denial of service targeted at</span>
<a name="l01355"></a>01355 <span class="comment">        the on-link prefix list is not catastrophic (hosts would send packets</span>
<a name="l01356"></a>01356 <span class="comment">        to a default router and receive a redirect rather than sending</span>
<a name="l01357"></a>01357 <span class="comment">        packets directly to a neighbor) the Neighbor Discovery protocol does</span>
<a name="l01358"></a>01358 <span class="comment">        not impose such a check on the prefix lifetime values.*/</span>
<a name="l01359"></a>01359     }
<a name="l01360"></a>01360 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ae187033477823763f0fc0063353821f6"></a><!-- doxytag: member="IPv6NeighbourDiscovery::processRAPrefixInfoForAddrAutoConf" ref="ae187033477823763f0fc0063353821f6" args="(IPv6NDPrefixInformation &amp;prefixInfo, InterfaceEntry *ie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPv6NeighbourDiscovery::processRAPrefixInfoForAddrAutoConf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_n_d_prefix_information.html">IPv6NDPrefixInformation</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>prefixInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&nbsp;</td>
          <td class="paramname"> <em>ie</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01362">1362</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01116">processRAPacket()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01364"></a>01364 {
<a name="l01365"></a>01365     <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Processing Prefix Info for address auto-configuration.\n&quot;</span>;
<a name="l01366"></a>01366     <a class="code" href="class_i_pv6_address.html">IPv6Address</a> prefix = prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#a769743b8ab554bc69cc0830652aa5c1d">getPrefix</a>();
<a name="l01367"></a>01367     <a class="code" href="_i_n_e_t_defs_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> prefixLength = prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#a6660082e882c5e64e664b352d2fe31d9">getPrefixLength</a>();
<a name="l01368"></a>01368     simtime_t preferredLifetime = prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#a4bbcfaafccb44d3e136cd17627f46641">getPreferredLifetime</a>();
<a name="l01369"></a>01369     simtime_t validLifetime = prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#a93e32dbccf0d60cff0269f4450d6323e">getValidLifetime</a>();
<a name="l01370"></a>01370 
<a name="l01371"></a>01371     <span class="comment">//RFC 2461: Section 5.5.3</span>
<a name="l01372"></a>01372     <span class="comment">//First condition tested, the autonomous flag is already set</span>
<a name="l01373"></a>01373 
<a name="l01374"></a>01374     <span class="comment">//b) If the prefix is the link-local prefix, silently ignore the Prefix</span>
<a name="l01375"></a>01375     <span class="comment">//Information option.</span>
<a name="l01376"></a>01376     <span class="keywordflow">if</span> (prefixInfo.<a class="code" href="class_i_pv6_n_d_prefix_information.html#a769743b8ab554bc69cc0830652aa5c1d">getPrefix</a>().<a class="code" href="class_i_pv6_address.html#a304edc5014ff3c991ae531aca21d2260">isLinkLocal</a>() == <span class="keyword">true</span>)
<a name="l01377"></a>01377     {
<a name="l01378"></a>01378         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Prefix is link-local, ignore Prefix Information Option\n&quot;</span>;
<a name="l01379"></a>01379         <span class="keywordflow">return</span>;
<a name="l01380"></a>01380     }
<a name="l01381"></a>01381 
<a name="l01382"></a>01382     <span class="comment">//c) If the preferred lifetime is greater than the valid lifetime, silently</span>
<a name="l01383"></a>01383     <span class="comment">//ignore the Prefix Information option. A node MAY wish to log a system</span>
<a name="l01384"></a>01384     <span class="comment">//management error in this case.</span>
<a name="l01385"></a>01385     <span class="keywordflow">if</span> (preferredLifetime &gt; validLifetime)
<a name="l01386"></a>01386     {
<a name="l01387"></a>01387         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Preferred lifetime is greater than valid lifetime, ignore Prefix Information\n&quot;</span>;
<a name="l01388"></a>01388         <span class="keywordflow">return</span>;
<a name="l01389"></a>01389     }
<a name="l01390"></a>01390 
<a name="l01391"></a>01391     <span class="keywordtype">bool</span> isPrefixAssignedToInterface = <span class="keyword">false</span>;
<a name="l01392"></a>01392     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#ae4fe7ab839b3c7f08226eed79f224103">getNumAddresses</a>(); i++)
<a name="l01393"></a>01393     {
<a name="l01394"></a>01394         <span class="keywordflow">if</span> (ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a908a45071d8685ebbb01f73bb086525b">getAddress</a>(i).<a class="code" href="class_i_pv6_address.html#a4d9102b52fcf98d1945c75a098bc678a">matches</a>(prefix, prefixLength) == <span class="keyword">true</span>)
<a name="l01395"></a>01395             isPrefixAssignedToInterface = <span class="keyword">true</span>;
<a name="l01396"></a>01396     }
<a name="l01397"></a>01397     <span class="comment">/*d) If the prefix advertised does not match the prefix of an address already</span>
<a name="l01398"></a>01398 <span class="comment">         in the list, and the Valid Lifetime is not 0, form an address (and add</span>
<a name="l01399"></a>01399 <span class="comment">         it to the list) by combining the advertised prefix with the links</span>
<a name="l01400"></a>01400 <span class="comment">         interface identifier as follows:*/</span>
<a name="l01401"></a>01401     <span class="keywordflow">if</span> (isPrefixAssignedToInterface == <span class="keyword">false</span> &amp;&amp; validLifetime != 0)
<a name="l01402"></a>01402     {
<a name="l01403"></a>01403         <a class="code" href="class_i_pv6_address.html">IPv6Address</a> linkLocalAddress = ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a3b9fa2d8e186014cf9c758e45b5a56df">getLinkLocalAddress</a>();
<a name="l01404"></a>01404         ASSERT(linkLocalAddress.<a class="code" href="class_i_pv6_address.html#af526cffcc3a4aa5bb96d307de6e8d448">isUnspecified</a>() == <span class="keyword">false</span>);
<a name="l01405"></a>01405         <a class="code" href="class_i_pv6_address.html">IPv6Address</a> newAddr = linkLocalAddress.<a class="code" href="class_i_pv6_address.html#a6820830388fdffcd01de42d2f9fe2762">setPrefix</a>(prefix, prefixLength);
<a name="l01406"></a>01406         <span class="comment">//TODO: for now we leave the newly formed address as not tentative,</span>
<a name="l01407"></a>01407         <span class="comment">//according to Greg, we have to always perform DAD for a newly formed address.</span>
<a name="l01408"></a>01408         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Assigning new address to: &quot;</span> &lt;&lt; ie-&gt;getName() &lt;&lt; endl;
<a name="l01409"></a>01409         ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a715b339dc41612149940ed0607af1535">assignAddress</a>(newAddr, <span class="keyword">false</span>, simTime()+validLifetime,
<a name="l01410"></a>01410             simTime()+preferredLifetime);
<a name="l01411"></a>01411     }
<a name="l01412"></a>01412 
<a name="l01413"></a>01413     <span class="comment">//TODO: this is the simplified version.</span>
<a name="l01414"></a>01414     <span class="comment">/*e) If the advertised prefix matches the prefix of an autoconfigured</span>
<a name="l01415"></a>01415 <span class="comment">       address (i.e., one obtained via stateless or stateful address</span>
<a name="l01416"></a>01416 <span class="comment">       autoconfiguration) in the list of addresses associated with the</span>
<a name="l01417"></a>01417 <span class="comment">       interface, the specific action to perform depends on the Valid</span>
<a name="l01418"></a>01418 <span class="comment">       Lifetime in the received advertisement and the Lifetime</span>
<a name="l01419"></a>01419 <span class="comment">       associated with the previously autoconfigured address (which we</span>
<a name="l01420"></a>01420 <span class="comment">       call StoredLifetime in the discussion that follows):</span>
<a name="l01421"></a>01421 <span class="comment"></span>
<a name="l01422"></a>01422 <span class="comment">       1) If the received Lifetime is greater than 2 hours or greater</span>
<a name="l01423"></a>01423 <span class="comment">          than StoredLifetime, update the stored Lifetime of the</span>
<a name="l01424"></a>01424 <span class="comment">          corresponding address.</span>
<a name="l01425"></a>01425 <span class="comment"></span>
<a name="l01426"></a>01426 <span class="comment">       2) If the StoredLifetime is less than or equal to 2 hours and the</span>
<a name="l01427"></a>01427 <span class="comment">          received Lifetime is less than or equal to StoredLifetime,</span>
<a name="l01428"></a>01428 <span class="comment">          ignore the prefix, unless the Router Advertisement from which</span>
<a name="l01429"></a>01429 <span class="comment"></span>
<a name="l01430"></a>01430 <span class="comment">          this Prefix Information option was obtained has been</span>
<a name="l01431"></a>01431 <span class="comment">          authenticated (e.g., via IPSec [RFC2402]). If the Router</span>
<a name="l01432"></a>01432 <span class="comment">          Advertisment was authenticated, the StoredLifetime should be</span>
<a name="l01433"></a>01433 <span class="comment">          set to the Lifetime in the received option.</span>
<a name="l01434"></a>01434 <span class="comment"></span>
<a name="l01435"></a>01435 <span class="comment">       3) Otherwise, reset the stored Lifetime in the corresponding</span>
<a name="l01436"></a>01436 <span class="comment">          address to two hours.*/</span>
<a name="l01437"></a>01437 
<a name="l01438"></a>01438 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a860a64e4fbb311fef343ec7044c0a10b"></a><!-- doxytag: member="IPv6NeighbourDiscovery::processRDTimeout" ref="a860a64e4fbb311fef343ec7044c0a10b" args="(cMessage *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPv6NeighbourDiscovery::processRDTimeout </td>
          <td>(</td>
          <td class="paramtype">cMessage *&nbsp;</td>
          <td class="paramname"> <em>msg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00904">904</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00081">handleMessage()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00905"></a>00905 {
<a name="l00906"></a>00906     <a class="code" href="class_interface_entry.html">InterfaceEntry</a> *ie = (<a class="code" href="class_interface_entry.html">InterfaceEntry</a> *)msg-&gt;getContextPointer();
<a name="l00907"></a>00907     RDEntry *rdEntry = <a class="code" href="class_i_pv6_neighbour_discovery.html#ab83db378f6596fd37ab6657b13707aa4">fetchRDEntry</a>(ie);
<a name="l00908"></a>00908     <span class="keywordflow">if</span> (rdEntry-&gt;numRSSent &lt; ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a1a792673e93983d3d713738d2cce056a">_getMaxRtrSolicitations</a>())
<a name="l00909"></a>00909     {
<a name="l00910"></a>00910         bubble(<span class="stringliteral">&quot;Sending another RS message.&quot;</span>);
<a name="l00911"></a>00911         <a class="code" href="class_i_pv6_neighbour_discovery.html#a75431d6a5076b17ae0630f2fc4aa441a">createAndSendRSPacket</a>(ie);
<a name="l00912"></a>00912         rdEntry-&gt;numRSSent++;
<a name="l00913"></a>00913         <span class="comment">//Need to find out if this is the last RS we are sending out.</span>
<a name="l00914"></a>00914         <span class="keywordflow">if</span> (rdEntry-&gt;numRSSent == ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a1a792673e93983d3d713738d2cce056a">_getMaxRtrSolicitations</a>())
<a name="l00915"></a>00915             scheduleAt(simTime()+ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a517877f2a3d3d2ce80f08931a3b640ca">_getMaxRtrSolicitationDelay</a>(), msg);
<a name="l00916"></a>00916         <span class="keywordflow">else</span>
<a name="l00917"></a>00917             scheduleAt(simTime()+ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#adf35c471f2a5fb67e59838754318a88e">_getRtrSolicitationInterval</a>(), msg);
<a name="l00918"></a>00918     }
<a name="l00919"></a>00919     <span class="keywordflow">else</span>
<a name="l00920"></a>00920     {
<a name="l00921"></a>00921         <span class="comment">//RFC 2461, Section 6.3.7</span>
<a name="l00922"></a>00922         <span class="comment">/*If a host sends MAX_RTR_SOLICITATIONS solicitations, and receives no Router</span>
<a name="l00923"></a>00923 <span class="comment">        Advertisements after having waited MAX_RTR_SOLICITATION_DELAY seconds after</span>
<a name="l00924"></a>00924 <span class="comment">        sending the last solicitation, the host concludes that there are no routers</span>
<a name="l00925"></a>00925 <span class="comment">        on the link for the purpose of [ADDRCONF]. However, the host continues to</span>
<a name="l00926"></a>00926 <span class="comment">        receive and process Router Advertisements messages in the event that routers</span>
<a name="l00927"></a>00927 <span class="comment">        appear on the link.*/</span>
<a name="l00928"></a>00928         bubble(<span class="stringliteral">&quot;Max number of RS messages sent&quot;</span>);
<a name="l00929"></a>00929         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;No RA messages were received. Assume no routers are on-link&quot;</span>;
<a name="l00930"></a>00930         <span class="keyword">delete</span> rdEntry;
<a name="l00931"></a>00931         <span class="keyword">delete</span> msg;
<a name="l00932"></a>00932     }
<a name="l00933"></a>00933 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ab95f9c30abcda08c3b762d191df4a3ae"></a><!-- doxytag: member="IPv6NeighbourDiscovery::processRedirectPacket" ref="ab95f9c30abcda08c3b762d191df4a3ae" args="(IPv6Redirect *redirect, IPv6ControlInfo *ctrlInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPv6NeighbourDiscovery::processRedirectPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_redirect.html">IPv6Redirect</a> *&nbsp;</td>
          <td class="paramname"> <em>redirect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>ctrlInfo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l02141">2141</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00146">processNDMessage()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02143"></a>02143 {
<a name="l02144"></a>02144     <span class="comment">//First we need to extract information from the redirect message</span>
<a name="l02145"></a>02145     <a class="code" href="class_i_pv6_address.html">IPv6Address</a> targetAddr = redirect-&gt;<a class="code" href="class_i_pv6_redirect.html#abb02c3892f73bd9bec0a57f9c839ab19">getTargetAddress</a>();<span class="comment">//Addressed to me</span>
<a name="l02146"></a>02146     <a class="code" href="class_i_pv6_address.html">IPv6Address</a> destAddr = redirect-&gt;<a class="code" href="class_i_pv6_redirect.html#a786a7735f06ed73eeb90776ea962c74b">getDestinationAddress</a>();<span class="comment">//new dest addr</span>
<a name="l02147"></a>02147 
<a name="l02148"></a>02148     <span class="comment">//Optional</span>
<a name="l02149"></a>02149     <a class="code" href="class_m_a_c_address.html">MACAddress</a> macAddr = redirect-&gt;<a class="code" href="class_i_pv6_redirect.html#a5b137567866a7f466420021270f2f865">getTargetLinkLayerAddress</a>();
<a name="l02150"></a>02150 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac6f2316e1a19d2816bab83e96d11ef57"></a><!-- doxytag: member="IPv6NeighbourDiscovery::processRSPacket" ref="ac6f2316e1a19d2816bab83e96d11ef57" args="(IPv6RouterSolicitation *rs, IPv6ControlInfo *rsCtrlInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPv6NeighbourDiscovery::processRSPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_router_solicitation.html">IPv6RouterSolicitation</a> *&nbsp;</td>
          <td class="paramname"> <em>rs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>rsCtrlInfo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00935">935</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00146">processNDMessage()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00937"></a>00937 {
<a name="l00938"></a>00938     <span class="keywordflow">if</span> (<a class="code" href="class_i_pv6_neighbour_discovery.html#a09f8b6d13b8546d9c3d735589df9e37f">validateRSPacket</a>(rs, rsCtrlInfo) == <span class="keyword">false</span>) <span class="keywordflow">return</span>;
<a name="l00939"></a>00939     <span class="comment">//Find out which interface the RS message arrived on.</span>
<a name="l00940"></a>00940     <a class="code" href="class_interface_entry.html">InterfaceEntry</a> *ie = <a class="code" href="class_i_pv6_neighbour_discovery.html#a4b4f35b761b93c397e2a5a36c1e08d38">ift</a>-&gt;<a class="code" href="class_i_interface_table.html#a92764d620c345b7261de20e9ee5247d7">getInterfaceById</a>(rsCtrlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a74046fa005d98f0c304eb39eb28a1ec3">getInterfaceId</a>());
<a name="l00941"></a>00941     AdvIfEntry *advIfEntry = <a class="code" href="class_i_pv6_neighbour_discovery.html#a44d5adf445298a56e275377d70d620ef">fetchAdvIfEntry</a>(ie);<span class="comment">//fetch advertising interface entry.</span>
<a name="l00942"></a>00942 
<a name="l00943"></a>00943     <span class="comment">//RFC 2461: Section 6.2.6</span>
<a name="l00944"></a>00944     <span class="comment">//A host MUST silently discard any received Router Solicitation messages.</span>
<a name="l00945"></a>00945     <span class="keywordflow">if</span> (ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a3e629909076b47fa0886f83fbb7af09a">getAdvSendAdvertisements</a>())
<a name="l00946"></a>00946     {
<a name="l00947"></a>00947         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;This is an advertising interface, processing RS\n&quot;</span>;
<a name="l00948"></a>00948 
<a name="l00949"></a>00949         <span class="keywordflow">if</span> (<a class="code" href="class_i_pv6_neighbour_discovery.html#a09f8b6d13b8546d9c3d735589df9e37f">validateRSPacket</a>(rs, rsCtrlInfo) == <span class="keyword">false</span>) <span class="keywordflow">return</span>;
<a name="l00950"></a>00950         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;RS message validated\n&quot;</span>;
<a name="l00951"></a>00951 
<a name="l00952"></a>00952         <span class="comment">//First we extract RS specific information from the received message</span>
<a name="l00953"></a>00953         <a class="code" href="class_m_a_c_address.html">MACAddress</a> macAddr = rs-&gt;<a class="code" href="class_i_pv6_router_solicitation.html#ac27e5211d09ebbfe316b4c2b28e3a232">getSourceLinkLayerAddress</a>();
<a name="l00954"></a>00954         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;MAC Address extracted\n&quot;</span>;
<a name="l00955"></a>00955         <span class="keyword">delete</span> rs;
<a name="l00956"></a>00956 
<a name="l00957"></a>00957         <span class="comment">/*A router MAY choose to unicast the response directly to the soliciting</span>
<a name="l00958"></a>00958 <span class="comment">        host&apos;s address (if the solicitation&apos;s source address is not the unspecified</span>
<a name="l00959"></a>00959 <span class="comment">        address), but the usual case is to multicast the response to the</span>
<a name="l00960"></a>00960 <span class="comment">        all-nodes group. In the latter case, the interface&apos;s interval timer is</span>
<a name="l00961"></a>00961 <span class="comment">        reset to a new random value, as if an unsolicited advertisement had just</span>
<a name="l00962"></a>00962 <span class="comment">        been sent(see Section 6.2.4).*/</span>
<a name="l00963"></a>00963 
<a name="l00964"></a>00964         <span class="comment">/*In all cases, Router Advertisements sent in response to a Router</span>
<a name="l00965"></a>00965 <span class="comment">        Solicitation MUST be delayed by a random time between 0 and</span>
<a name="l00966"></a>00966 <span class="comment">        MAX_RA_DELAY_TIME seconds. (If a single advertisement is sent in</span>
<a name="l00967"></a>00967 <span class="comment">        response to multiple solicitations, the delay is relative to the</span>
<a name="l00968"></a>00968 <span class="comment">        first solicitation.)  In addition, consecutive Router Advertisements</span>
<a name="l00969"></a>00969 <span class="comment">        sent to the all-nodes multicast address MUST be rate limited to no</span>
<a name="l00970"></a>00970 <span class="comment">        more than one advertisement every MIN_DELAY_BETWEEN_RAS seconds.*/</span>
<a name="l00971"></a>00971 
<a name="l00972"></a>00972         <span class="comment">/*A router might process Router Solicitations as follows:</span>
<a name="l00973"></a>00973 <span class="comment">        - Upon receipt of a Router Solicitation, compute a random delay</span>
<a name="l00974"></a>00974 <span class="comment">        within the range 0 through MAX_RA_DELAY_TIME. If the computed</span>
<a name="l00975"></a>00975 <span class="comment">        value corresponds to a time later than the time the next multicast</span>
<a name="l00976"></a>00976 <span class="comment">        Router Advertisement is scheduled to be sent, ignore the random</span>
<a name="l00977"></a>00977 <span class="comment">        delay and send the advertisement at the already-scheduled time.*/</span>
<a name="l00978"></a>00978         cMessage *msg = <span class="keyword">new</span> cMessage(<span class="stringliteral">&quot;sendSolicitedRA&quot;</span>, <a class="code" href="_i_pv6_neighbour_discovery_8cc.html#ab76c2fe672ed307b0a91f9efa35a7548">MK_SEND_SOL_RTRADV</a>);
<a name="l00979"></a>00979         msg-&gt;setContextPointer(ie);
<a name="l00980"></a>00980         simtime_t interval = uniform(0, ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a3049d46330724fba44165a5c6edf9801">_getMaxRADelayTime</a>());
<a name="l00981"></a>00981 
<a name="l00982"></a>00982         <span class="keywordflow">if</span> (interval &lt; advIfEntry-&gt;nextScheduledRATime)
<a name="l00983"></a>00983         {
<a name="l00984"></a>00984             simtime_t nextScheduledTime;
<a name="l00985"></a>00985             nextScheduledTime = simTime()+interval;
<a name="l00986"></a>00986             scheduleAt(nextScheduledTime, msg);
<a name="l00987"></a>00987             advIfEntry-&gt;nextScheduledRATime = nextScheduledTime;
<a name="l00988"></a>00988         }
<a name="l00989"></a>00989         <span class="comment">//else we ignore the generate interval and send it at the next scheduled time.</span>
<a name="l00990"></a>00990 
<a name="l00991"></a>00991         <span class="comment">//We need to keep a log here each time an RA is sent. Not implemented yet.</span>
<a name="l00992"></a>00992         <span class="comment">//Assume the first course of action.</span>
<a name="l00993"></a>00993         <span class="comment">/*- If the router sent a multicast Router Advertisement (solicited or</span>
<a name="l00994"></a>00994 <span class="comment">        unsolicited) within the last MIN_DELAY_BETWEEN_RAS seconds,</span>
<a name="l00995"></a>00995 <span class="comment">        schedule the advertisement to be sent at a time corresponding to</span>
<a name="l00996"></a>00996 <span class="comment">        MIN_DELAY_BETWEEN_RAS plus the random value after the previous</span>
<a name="l00997"></a>00997 <span class="comment">        advertisement was sent. This ensures that the multicast Router</span>
<a name="l00998"></a>00998 <span class="comment">        Advertisements are rate limited.</span>
<a name="l00999"></a>00999 <span class="comment"></span>
<a name="l01000"></a>01000 <span class="comment">        - Otherwise, schedule the sending of a Router Advertisement at the</span>
<a name="l01001"></a>01001 <span class="comment">        time given by the random value.*/</span>
<a name="l01002"></a>01002     }
<a name="l01003"></a>01003     <span class="keywordflow">else</span>
<a name="l01004"></a>01004     {
<a name="l01005"></a>01005         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;This interface is a host, discarding RA message\n&quot;</span>;
<a name="l01006"></a>01006         <span class="keyword">delete</span> rs;
<a name="l01007"></a>01007     }
<a name="l01008"></a>01008 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="abcd9999f935e23b593499f8d23a970bf"></a><!-- doxytag: member="IPv6NeighbourDiscovery::reachabilityConfirmed" ref="abcd9999f935e23b593499f8d23a970bf" args="(const IPv6Address &amp;neighbour, int interfaceId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPv6NeighbourDiscovery::reachabilityConfirmed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>neighbour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>interfaceId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Public method, it can be invoked from the <a class="el" href="class_i_pv6.html">IPv6</a> module or any other module to let Neighbour Discovery know that the reachability of the given neighbor has just been confirmed (e.g. <a class="el" href="class_t_c_p.html">TCP</a> received ACK of new data from it). Neighbour Discovery can then update the neighbour cache with this information, and cancel the Neighbour Unreachability Detection procedure if it is currently running. </p>

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00314">314</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00315"></a>00315 {
<a name="l00316"></a>00316     Enter_Method(<span class="stringliteral">&quot;reachabilityConfirmed(%s,if=%d)&quot;</span>, neighbour.<a class="code" href="class_i_pv6_address.html#a7c42fb066db81588a439aed1de5e4b3a">str</a>().c_str(), interfaceId);
<a name="l00317"></a>00317     <span class="comment">//hmmm... this should only be invoked if a TCP ACK was received and NUD is</span>
<a name="l00318"></a>00318     <span class="comment">//currently being performed on the neighbour where the TCP ACK was received from.</span>
<a name="l00319"></a>00319 
<a name="l00320"></a>00320     <a class="code" href="class_i_pv6_neighbour_discovery.html#a13e99f7e1505dd01abbf03066e61384c">Neighbour</a> *nce = <a class="code" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">neighbourCache</a>.<a class="code" href="class_i_pv6_neighbour_cache.html#af88ebc30d5f18f0a628ead79f1fc3cb9">lookup</a>(neighbour, interfaceId);
<a name="l00321"></a>00321 
<a name="l00322"></a>00322     cMessage *msg = nce-&gt;<a class="code" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html#a861411e349fda127a4b66659f155659f">nudTimeoutEvent</a>;
<a name="l00323"></a>00323     <span class="keywordflow">if</span> (msg != NULL)
<a name="l00324"></a>00324     {
<a name="l00325"></a>00325         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;NUD in progress. Cancelling NUD Timer\n&quot;</span>;
<a name="l00326"></a>00326         bubble(<span class="stringliteral">&quot;Reachability Confirmed via NUD.&quot;</span>);
<a name="l00327"></a>00327         cancelEvent(msg);
<a name="l00328"></a>00328         <span class="keyword">delete</span> msg;
<a name="l00329"></a>00329     }
<a name="l00330"></a>00330 
<a name="l00331"></a>00331     <span class="comment">// TODO (see header file for description)</span>
<a name="l00332"></a>00332     <span class="comment">/*A neighbor is considered reachable if the node has recently received</span>
<a name="l00333"></a>00333 <span class="comment">    a confirmation that packets sent recently to the neighbor were</span>
<a name="l00334"></a>00334 <span class="comment">    received by its IP layer.  Positive confirmation can be gathered in</span>
<a name="l00335"></a>00335 <span class="comment">    two ways: hints from upper layer protocols that indicate a connection</span>
<a name="l00336"></a>00336 <span class="comment">    is making &quot;forward progress&quot;, or receipt of a Neighbor Advertisement</span>
<a name="l00337"></a>00337 <span class="comment">    message that is a response to a Neighbor Solicitation message.</span>
<a name="l00338"></a>00338 <span class="comment"></span>
<a name="l00339"></a>00339 <span class="comment">    A connection makes &quot;forward progress&quot; if the packets received from a</span>
<a name="l00340"></a>00340 <span class="comment">    remote peer can only be arriving if recent packets sent to that peer</span>
<a name="l00341"></a>00341 <span class="comment">    are actually reaching it.  In TCP, for example, receipt of a (new)</span>
<a name="l00342"></a>00342 <span class="comment">    acknowledgement indicates that previously sent data reached the peer.</span>
<a name="l00343"></a>00343 <span class="comment">    Likewise, the arrival of new (non-duplicate) data indicates that</span>
<a name="l00344"></a>00344 <span class="comment"></span>
<a name="l00345"></a>00345 <span class="comment">    earlier acknowledgements are being delivered to the remote peer.  If</span>
<a name="l00346"></a>00346 <span class="comment">    packets are reaching the peer, they must also be reaching the</span>
<a name="l00347"></a>00347 <span class="comment">    sender&apos;s next-hop neighbor; thus &quot;forward progress&quot; is a confirmation</span>
<a name="l00348"></a>00348 <span class="comment">    that the next-hop neighbor is reachable.  For off-link destinations,</span>
<a name="l00349"></a>00349 <span class="comment">    forward progress implies that the first-hop router is reachable.</span>
<a name="l00350"></a>00350 <span class="comment">    When available, this upper-layer information SHOULD be used.</span>
<a name="l00351"></a>00351 <span class="comment"></span>
<a name="l00352"></a>00352 <span class="comment">    In some cases (e.g., UDP-based protocols and routers forwarding</span>
<a name="l00353"></a>00353 <span class="comment">    packets to hosts) such reachability information may not be readily</span>
<a name="l00354"></a>00354 <span class="comment">    available from upper-layer protocols.  When no hints are available</span>
<a name="l00355"></a>00355 <span class="comment">    and a node is sending packets to a neighbor, the node actively probes</span>
<a name="l00356"></a>00356 <span class="comment">    the neighbor using unicast Neighbor Solicitation messages to verify</span>
<a name="l00357"></a>00357 <span class="comment">    that the forward path is still working.</span>
<a name="l00358"></a>00358 <span class="comment"></span>
<a name="l00359"></a>00359 <span class="comment">    The receipt of a solicited Neighbor Advertisement serves as</span>
<a name="l00360"></a>00360 <span class="comment">    reachability confirmation, since advertisements with the Solicited</span>
<a name="l00361"></a>00361 <span class="comment">    flag set to one are sent only in response to a Neighbor Solicitation.</span>
<a name="l00362"></a>00362 <span class="comment">    Receipt of other Neighbor Discovery messages such as Router</span>
<a name="l00363"></a>00363 <span class="comment">    Advertisements and Neighbor Advertisement with the Solicited flag set</span>
<a name="l00364"></a>00364 <span class="comment">    to zero MUST NOT be treated as a reachability confirmation.  Receipt</span>
<a name="l00365"></a>00365 <span class="comment">    of unsolicited messages only confirm the one-way path from the sender</span>
<a name="l00366"></a>00366 <span class="comment">    to the recipient node.  In contrast, Neighbor Unreachability</span>
<a name="l00367"></a>00367 <span class="comment">    Detection requires that a node keep track of the reachability of the</span>
<a name="l00368"></a>00368 <span class="comment">    forward path to a neighbor from the its perspective, not the</span>
<a name="l00369"></a>00369 <span class="comment">    neighbor&apos;s perspective.  Note that receipt of a solicited</span>
<a name="l00370"></a>00370 <span class="comment">    advertisement indicates that a path is working in both directions.</span>
<a name="l00371"></a>00371 <span class="comment">    The solicitation must have reached the neighbor, prompting it to</span>
<a name="l00372"></a>00372 <span class="comment">    generate an advertisement.  Likewise, receipt of an advertisement</span>
<a name="l00373"></a>00373 <span class="comment">    indicates that the path from the sender to the recipient is working.</span>
<a name="l00374"></a>00374 <span class="comment">    However, the latter fact is known only to the recipient; the</span>
<a name="l00375"></a>00375 <span class="comment">    advertisement&apos;s sender has no direct way of knowing that the</span>
<a name="l00376"></a>00376 <span class="comment">    advertisement it sent actually reached a neighbor.  From the</span>
<a name="l00377"></a>00377 <span class="comment">    perspective of Neighbor Unreachability Detection, only the</span>
<a name="l00378"></a>00378 <span class="comment">    reachability of the forward path is of interest.*/</span>
<a name="l00379"></a>00379 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="acd79bbeb030e0105e39d63cab1cee297"></a><!-- doxytag: member="IPv6NeighbourDiscovery::resetRATimer" ref="acd79bbeb030e0105e39d63cab1cee297" args="(InterfaceEntry *ie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPv6NeighbourDiscovery::resetRATimer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&nbsp;</td>
          <td class="paramname"> <em>ie</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset the given interface entry's Router Advertisement timer. This is usually done when a router interface responds (by replying with a Router Advertisement sent to the All-Node multicast group)to a router solicitation Also see: RFC 2461, Section 6.2.6 </p>

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01459">1459</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01460"></a>01460 {<span class="comment">//Not used yet but could be useful later on.-WEI</span>
<a name="l01461"></a>01461     <span class="comment">//Iterate through all RA timers within the Neighbour Discovery module.</span>
<a name="l01462"></a>01462 <span class="comment">/*</span>
<a name="l01463"></a>01463 <span class="comment">    for (RATimerList::iterator it=raTimerList.begin(); it != raTimerList.end(); it++)</span>
<a name="l01464"></a>01464 <span class="comment">    {</span>
<a name="l01465"></a>01465 <span class="comment">        cMessage *msg = (*it);</span>
<a name="l01466"></a>01466 <span class="comment">        InterfaceEntry *msgIE = (InterfaceEntry *)msg-&gt;getContextPointer();</span>
<a name="l01467"></a>01467 <span class="comment">        //Find the timer that matches the given Interface Entry.</span>
<a name="l01468"></a>01468 <span class="comment">        if (msgIE-&gt;outputPort() == ie-&gt;outputPort())</span>
<a name="l01469"></a>01469 <span class="comment">        {</span>
<a name="l01470"></a>01470 <span class="comment">            EV &lt;&lt; &quot;Resetting RA timer for port: &quot; &lt;&lt; ie-&gt;outputPort();</span>
<a name="l01471"></a>01471 <span class="comment">            cancelEvent(msg);//Cancel the next scheduled msg.</span>
<a name="l01472"></a>01472 <span class="comment">            simtime_t interval</span>
<a name="l01473"></a>01473 <span class="comment">                = uniform(ie-&gt;ipv6Data()-&gt;getMinRtrAdvInterval(),ie-&gt;ipv6Data()-&gt;getMaxRtrAdvInterval());</span>
<a name="l01474"></a>01474 <span class="comment">            scheduleAt(simTime()+interval, msg);</span>
<a name="l01475"></a>01475 <span class="comment">        }</span>
<a name="l01476"></a>01476 <span class="comment">    }</span>
<a name="l01477"></a>01477 <span class="comment">*/</span>
<a name="l01478"></a>01478 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a567588762bff7af739e72916df55aebc"></a><!-- doxytag: member="IPv6NeighbourDiscovery::resolveNeighbour" ref="a567588762bff7af739e72916df55aebc" args="(const IPv6Address &amp;nextHop, int interfaceId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_m_a_c_address.html">MACAddress</a> &amp; IPv6NeighbourDiscovery::resolveNeighbour </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>nextHop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>interfaceId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Public method, to be invoked from the <a class="el" href="class_i_pv6.html">IPv6</a> module to determine link-layer address and the output interface of the next hop.</p>
<p>If the neighbor cache does not contain this address or it's in the state INCOMPLETE, this method will return the NULL address, and the <a class="el" href="class_i_pv6.html">IPv6</a> module should then send the datagram here to <a class="el" href="class_i_pv6_neighbour_discovery.html">IPv6NeighbourDiscovery</a> where it will be stored until neighbour resolution completes.</p>
<p>If the neighbour cache entry is STALE (or REACHABLE but more than reachableTime elapsed since reachability was last confirmed), the link-layer address is still returned and <a class="el" href="class_i_pv6.html">IPv6</a> can send the datagram, but simultaneously, this call should trigger the Neighbour Unreachability Detection procedure to start in the <a class="el" href="class_i_pv6_neighbour_discovery.html">IPv6NeighbourDiscovery</a> module. </p>

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00286">286</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_8cc_source.html#l00165">IPv6::routePacket()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00287"></a>00287 {
<a name="l00288"></a>00288     Enter_Method(<span class="stringliteral">&quot;resolveNeighbor(%s,if=%d)&quot;</span>, nextHop.<a class="code" href="class_i_pv6_address.html#a7c42fb066db81588a439aed1de5e4b3a">str</a>().c_str(), interfaceId);
<a name="l00289"></a>00289 
<a name="l00290"></a>00290     <a class="code" href="class_i_pv6_neighbour_discovery.html#a13e99f7e1505dd01abbf03066e61384c">Neighbour</a> *nce = <a class="code" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">neighbourCache</a>.<a class="code" href="class_i_pv6_neighbour_cache.html#af88ebc30d5f18f0a628ead79f1fc3cb9">lookup</a>(nextHop, interfaceId);
<a name="l00291"></a>00291     <span class="comment">//InterfaceEntry *ie = ift-&gt;getInterfaceById(interfaceId);</span>
<a name="l00292"></a>00292 
<a name="l00293"></a>00293     <span class="keywordflow">if</span> (!nce || nce-&gt;reachabilityState==<a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1ac2cfd6c9d21c7d34d2f6f53d6cfe6638">IPv6NeighbourCache::INCOMPLETE</a>)
<a name="l00294"></a>00294         <span class="keywordflow">return</span> <a class="code" href="class_m_a_c_address.html#a9083fdb636ab09f77e7af806f2d471b6">MACAddress::UNSPECIFIED_ADDRESS</a>;
<a name="l00295"></a>00295     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nce-&gt;reachabilityState==<a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a115199155dd43585124db1d8f471025b">IPv6NeighbourCache::STALE</a>)
<a name="l00296"></a>00296         <a class="code" href="class_i_pv6_neighbour_discovery.html#a9f14cc2bfe0cce622308be4388b3b397">initiateNeighbourUnreachabilityDetection</a>(nce);
<a name="l00297"></a>00297     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nce-&gt;reachabilityState==<a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a537cfe5cd6d576deab91b256b6da873a">IPv6NeighbourCache::REACHABLE</a> &amp;&amp;
<a name="l00298"></a>00298         simTime() &gt; nce-&gt;reachabilityExpires)
<a name="l00299"></a>00299     {
<a name="l00300"></a>00300         nce-&gt;reachabilityState = <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a115199155dd43585124db1d8f471025b">IPv6NeighbourCache::STALE</a>;
<a name="l00301"></a>00301         <a class="code" href="class_i_pv6_neighbour_discovery.html#a9f14cc2bfe0cce622308be4388b3b397">initiateNeighbourUnreachabilityDetection</a>(nce);
<a name="l00302"></a>00302     }
<a name="l00303"></a>00303     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nce-&gt;reachabilityState!=<a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a537cfe5cd6d576deab91b256b6da873a">IPv6NeighbourCache::REACHABLE</a>)
<a name="l00304"></a>00304     {
<a name="l00305"></a>00305         <span class="comment">//reachability state must be either in DELAY or PROBE</span>
<a name="l00306"></a>00306         ASSERT(nce-&gt;reachabilityState==<a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a815cc3dd5d8b220495a69641b00f5bdb">IPv6NeighbourCache::DELAY</a> ||
<a name="l00307"></a>00307                nce-&gt;reachabilityState==<a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a8fdd2d1853264aa8f5479ebfa6502054">IPv6NeighbourCache::PROBE</a>);
<a name="l00308"></a>00308         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;NUD in progress.\n&quot;</span>;
<a name="l00309"></a>00309     }
<a name="l00310"></a>00310     <span class="comment">//else the entry is REACHABLE and no further action is required here.</span>
<a name="l00311"></a>00311     <span class="keywordflow">return</span> nce-&gt;macAddress;
<a name="l00312"></a>00312 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a9f6c83de24b3e270c3843cc213b5250a"></a><!-- doxytag: member="IPv6NeighbourDiscovery::selectDefaultRouter" ref="a9f6c83de24b3e270c3843cc213b5250a" args="(int &amp;outIfID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_pv6_address.html">IPv6Address</a> IPv6NeighbourDiscovery::selectDefaultRouter </td>
          <td>(</td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>outIfID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00491">491</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00381">determineNextHop()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00492"></a>00492 {
<a name="l00493"></a>00493     <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Selecting default router...\n&quot;</span>;
<a name="l00494"></a>00494     <span class="comment">//draft-ietf-ipv6-2461bis-04.txt Section 6.3.6</span>
<a name="l00495"></a>00495     <span class="comment">/*The algorithm for selecting a router depends in part on whether or not a</span>
<a name="l00496"></a>00496 <span class="comment">    router is known to be reachable. The exact details of how a node keeps track</span>
<a name="l00497"></a>00497 <span class="comment">    of a neighbor&apos;s reachability state are covered in Section 7.3.  The algorithm</span>
<a name="l00498"></a>00498 <span class="comment">    for selecting a default router is invoked during next-hop determination when</span>
<a name="l00499"></a>00499 <span class="comment">    no Destination Cache entry exists for an off-link destination or when</span>
<a name="l00500"></a>00500 <span class="comment">    communication through an existing router appears to be failing.  Under normal</span>
<a name="l00501"></a>00501 <span class="comment">    conditions, a router would be selected the first time traffic is sent to a</span>
<a name="l00502"></a>00502 <span class="comment">    destination, with subsequent traffic for that destination using the same router</span>
<a name="l00503"></a>00503 <span class="comment">    as indicated in the Destination Cache modulo any changes to the Destination</span>
<a name="l00504"></a>00504 <span class="comment">    Cache caused by Redirect messages.</span>
<a name="l00505"></a>00505 <span class="comment"></span>
<a name="l00506"></a>00506 <span class="comment">    The policy for selecting routers from the Default Router List is as</span>
<a name="l00507"></a>00507 <span class="comment">    follows:*/</span>
<a name="l00508"></a>00508 
<a name="l00509"></a>00509     <a class="code" href="class_i_pv6_address.html">IPv6Address</a> routerAddr;
<a name="l00510"></a>00510     <span class="comment">//Cycle through all entries in the neighbour cache entry.</span>
<a name="l00511"></a>00511     <span class="keywordflow">for</span>(<a class="code" href="class_i_pv6_neighbour_cache.html#ab1cc9b2e581aa3e334f0c38874505f44">IPv6NeighbourCache::iterator</a> it=<a class="code" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">neighbourCache</a>.<a class="code" href="class_i_pv6_neighbour_cache.html#aba15c06ac0746775e6740c727033f37b">begin</a>(); it != <a class="code" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">neighbourCache</a>.<a class="code" href="class_i_pv6_neighbour_cache.html#a4dc511141fb8fa7cab64d60fc8ee7ab5">end</a>(); it++)
<a name="l00512"></a>00512     {
<a name="l00513"></a>00513         <a class="code" href="class_i_pv6_neighbour_discovery.html#a747705ed3b49881e2d144e2d9f0c8044">Key</a> key = it-&gt;first;
<a name="l00514"></a>00514         <a class="code" href="class_i_pv6_neighbour_discovery.html#a13e99f7e1505dd01abbf03066e61384c">Neighbour</a> nce = it-&gt;second;
<a name="l00515"></a>00515         <span class="keywordtype">bool</span> routerExpired = <span class="keyword">false</span>;
<a name="l00516"></a>00516         <span class="keywordflow">if</span> (nce.isDefaultRouter)
<a name="l00517"></a>00517         {
<a name="l00518"></a>00518             <span class="keywordflow">if</span> (simTime()&gt;nce.routerExpiryTime)
<a name="l00519"></a>00519             {
<a name="l00520"></a>00520                 <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Found an expired default router. Deleting entry...\n&quot;</span>;
<a name="l00521"></a>00521                 <a class="code" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">neighbourCache</a>.<a class="code" href="class_i_pv6_neighbour_cache.html#a877bc367ca422baabc22199c5036df83">remove</a>(key.address,key.interfaceID);
<a name="l00522"></a>00522                 routerExpired = <span class="keyword">true</span>;
<a name="l00523"></a>00523             }
<a name="l00524"></a>00524         }
<a name="l00525"></a>00525 
<a name="l00526"></a>00526         <span class="keywordflow">if</span> (routerExpired == <span class="keyword">false</span>)
<a name="l00527"></a>00527         {
<a name="l00528"></a>00528             <span class="keywordflow">if</span> (nce.reachabilityState == <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a537cfe5cd6d576deab91b256b6da873a">IPv6NeighbourCache::REACHABLE</a> ||
<a name="l00529"></a>00529                 nce.reachabilityState == <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a115199155dd43585124db1d8f471025b">IPv6NeighbourCache::STALE</a> ||
<a name="l00530"></a>00530                 nce.reachabilityState == <a class="code" href="class_i_pv6_neighbour_cache.html#ae3981577e32da8a5d021f5440573a2a1a815cc3dd5d8b220495a69641b00f5bdb">IPv6NeighbourCache::DELAY</a>)<span class="comment">//TODO: Need to improve this algorithm!</span>
<a name="l00531"></a>00531             {
<a name="l00532"></a>00532                 <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Found a router in the neighbour cache(default router list).\n&quot;</span>;
<a name="l00533"></a>00533                 outIfID = key.interfaceID;
<a name="l00534"></a>00534                 <span class="keywordflow">if</span> (routerExpired == <span class="keyword">false</span>) <span class="keywordflow">return</span> key.address;
<a name="l00535"></a>00535             }
<a name="l00536"></a>00536         }
<a name="l00537"></a>00537     }
<a name="l00538"></a>00538     <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;No suitable routers found.\n&quot;</span>;
<a name="l00539"></a>00539 
<a name="l00540"></a>00540     <span class="comment">/*1) Routers that are reachable or probably reachable (i.e., in any state</span>
<a name="l00541"></a>00541 <span class="comment">    other than INCOMPLETE) SHOULD be preferred over routers whose reachability</span>
<a name="l00542"></a>00542 <span class="comment">    is unknown or suspect (i.e., in the INCOMPLETE state, or for which no Neighbor</span>
<a name="l00543"></a>00543 <span class="comment">    Cache entry exists). An implementation may choose to always return the same</span>
<a name="l00544"></a>00544 <span class="comment">    router or cycle through the router list in a round-robin fashion as long as</span>
<a name="l00545"></a>00545 <span class="comment">    it always returns a reachable or a probably reachable router when one is</span>
<a name="l00546"></a>00546 <span class="comment">    available.*/</span>
<a name="l00547"></a>00547 
<a name="l00548"></a>00548     <span class="comment">/*2) When no routers on the list are known to be reachable or probably</span>
<a name="l00549"></a>00549 <span class="comment">    reachable, routers SHOULD be selected in a round-robin fashion, so that</span>
<a name="l00550"></a>00550 <span class="comment">    subsequent requests for a default router do not return the same router until</span>
<a name="l00551"></a>00551 <span class="comment">    all other routers have been selected.</span>
<a name="l00552"></a>00552 <span class="comment"></span>
<a name="l00553"></a>00553 <span class="comment">    Cycling through the router list in this case ensures that all available</span>
<a name="l00554"></a>00554 <span class="comment">    routers are actively probed by the Neighbor Unreachability Detection algorithm.</span>
<a name="l00555"></a>00555 <span class="comment">    A request for a default router is made in conjunction with the sending of a</span>
<a name="l00556"></a>00556 <span class="comment">    packet to a router, and the selected router will be probed for reachability</span>
<a name="l00557"></a>00557 <span class="comment">    as a side effect.*/</span>
<a name="l00558"></a>00558 
<a name="l00559"></a>00559     outIfID = -1;<span class="comment">//nothing found yet</span>
<a name="l00560"></a>00560     <span class="keywordflow">return</span> <a class="code" href="class_i_pv6_address.html">IPv6Address</a>();
<a name="l00561"></a>00561 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a58642b1dc383266b43abc6d6e4a74e5e"></a><!-- doxytag: member="IPv6NeighbourDiscovery::sendPacketToIPv6Module" ref="a58642b1dc383266b43abc6d6e4a74e5e" args="(cMessage *msg, const IPv6Address &amp;destAddr, const IPv6Address &amp;srcAddr, int interfaceId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPv6NeighbourDiscovery::sendPacketToIPv6Module </td>
          <td>(</td>
          <td class="paramtype">cMessage *&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>destAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>srcAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>interfaceId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create control info and assigns it to a msg. Returns a copy of the msg with the control info. </p>

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00700">700</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01566">createAndSendNSPacket()</a>, <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01044">createAndSendRAPacket()</a>, <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00828">createAndSendRSPacket()</a>, <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00185">processIPv6Datagram()</a>, and <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01761">sendSolicitedNA()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00702"></a>00702 {
<a name="l00703"></a>00703     <a class="code" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *controlInfo = <span class="keyword">new</span> <a class="code" href="class_i_pv6_control_info.html">IPv6ControlInfo</a>();
<a name="l00704"></a>00704     controlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a1d7bdca688829aec49c5ba5bcbbad43a">setProtocol</a>(<a class="code" href="_i_p_protocol_id__m_8h.html#a4297c2f400ba53cf6866e6d45bc81b70a3f40fb193e9edf4e297fcd7952acb024">IP_PROT_IPv6_ICMP</a>);
<a name="l00705"></a>00705     controlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a33ad14801b514f598753f68ece7ccc27">setDestAddr</a>(destAddr);
<a name="l00706"></a>00706     controlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#ae038bde950f03730e1765a4f037c9c17">setSrcAddr</a>(srcAddr);
<a name="l00707"></a>00707     controlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a1914e0065fc12407b7154ecab5a60e66">setHopLimit</a>(255);
<a name="l00708"></a>00708     controlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#acd34348fa8a834c536b5122c2efb9eb2">setInterfaceId</a>(interfaceId);
<a name="l00709"></a>00709     msg-&gt;setControlInfo(controlInfo);
<a name="l00710"></a>00710 
<a name="l00711"></a>00711     send(msg,<span class="stringliteral">&quot;ipv6Out&quot;</span>);
<a name="l00712"></a>00712 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a7ab6b1fc3d01da2bc31d772a31013e08"></a><!-- doxytag: member="IPv6NeighbourDiscovery::sendPeriodicRA" ref="a7ab6b1fc3d01da2bc31d772a31013e08" args="(cMessage *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPv6NeighbourDiscovery::sendPeriodicRA </td>
          <td>(</td>
          <td class="paramtype">cMessage *&nbsp;</td>
          <td class="paramname"> <em>msg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01480">1480</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00081">handleMessage()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01481"></a>01481 {
<a name="l01482"></a>01482     <a class="code" href="class_interface_entry.html">InterfaceEntry</a> *ie = (<a class="code" href="class_interface_entry.html">InterfaceEntry</a> *)msg-&gt;getContextPointer();
<a name="l01483"></a>01483     AdvIfEntry *advIfEntry = <a class="code" href="class_i_pv6_neighbour_discovery.html#a44d5adf445298a56e275377d70d620ef">fetchAdvIfEntry</a>(ie);
<a name="l01484"></a>01484     <a class="code" href="class_i_pv6_address.html">IPv6Address</a> destAddr = <a class="code" href="class_i_pv6_address.html">IPv6Address</a>(<span class="stringliteral">&quot;FF02::1&quot;</span>);
<a name="l01485"></a>01485     <a class="code" href="class_i_pv6_neighbour_discovery.html#a50d09a125fd3477828643875b72573ec">createAndSendRAPacket</a>(destAddr, ie);
<a name="l01486"></a>01486     advIfEntry-&gt;numRASent++;
<a name="l01487"></a>01487     simtime_t nextScheduledTime;
<a name="l01488"></a>01488 
<a name="l01489"></a>01489     <span class="comment">//RFC 2461, Section 6.2.4</span>
<a name="l01490"></a>01490     <span class="comment">/*Whenever a multicast advertisement is sent from an interface, the timer is</span>
<a name="l01491"></a>01491 <span class="comment">    reset to a uniformly-distributed random value between the interface&apos;s</span>
<a name="l01492"></a>01492 <span class="comment">    configured MinRtrAdvInterval and MaxRtrAdvInterval; expiration of the timer</span>
<a name="l01493"></a>01493 <span class="comment">    causes the next advertisement to be sent and a new random value to be chosen.*/</span>
<a name="l01494"></a>01494     simtime_t interval = uniform(ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a85b20115f117fb1038b72abf4ff27c51">getMinRtrAdvInterval</a>(), ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a05d2457e8285b73350353863e796954b">getMaxRtrAdvInterval</a>());
<a name="l01495"></a>01495     nextScheduledTime = simTime() + interval;
<a name="l01496"></a>01496 
<a name="l01497"></a>01497     <span class="comment">/*For the first few advertisements (up to MAX_INITIAL_RTR_ADVERTISEMENTS)</span>
<a name="l01498"></a>01498 <span class="comment">    sent from an interface when it becomes an advertising interface,*/</span>
<a name="l01499"></a>01499     <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Num RA sent is: &quot;</span> &lt;&lt; advIfEntry-&gt;numRASent &lt;&lt; endl;
<a name="l01500"></a>01500     <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;maxInitialRtrAdvertisements is: &quot;</span> &lt;&lt; ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a4e7715a7d677ef59b7f2d61f6560de9b">_getMaxInitialRtrAdvertisements</a>() &lt;&lt; endl;
<a name="l01501"></a>01501     <span class="keywordflow">if</span>(advIfEntry-&gt;numRASent &lt;= ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a4e7715a7d677ef59b7f2d61f6560de9b">_getMaxInitialRtrAdvertisements</a>())
<a name="l01502"></a>01502     {
<a name="l01503"></a>01503         <span class="keywordflow">if</span> (interval &gt; ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a8588d9959f5ae174058183b0355a4d39">_getMaxInitialRtrAdvertInterval</a>())
<a name="l01504"></a>01504         {
<a name="l01505"></a>01505             <span class="comment">//if the randomly chosen interval is greater than MAX_INITIAL_RTR_ADVERT_INTERVAL,</span>
<a name="l01506"></a>01506             <span class="comment">//the timer SHOULD be set to MAX_INITIAL_RTR_ADVERT_INTERVAL instead.</span>
<a name="l01507"></a>01507             nextScheduledTime = simTime() + ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a8588d9959f5ae174058183b0355a4d39">_getMaxInitialRtrAdvertInterval</a>();
<a name="l01508"></a>01508             <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Sending initial RA but interval is too long. Using default value.&quot;</span> &lt;&lt; endl;
<a name="l01509"></a>01509         }
<a name="l01510"></a>01510         <span class="keywordflow">else</span>
<a name="l01511"></a>01511             <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Sending initial RA. Using randomly generated interval.&quot;</span> &lt;&lt; endl;
<a name="l01512"></a>01512     }
<a name="l01513"></a>01513     <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Next scheduled time: &quot;</span> &lt;&lt; nextScheduledTime &lt;&lt; endl;
<a name="l01514"></a>01514     advIfEntry-&gt;nextScheduledRATime = nextScheduledTime;
<a name="l01515"></a>01515     ASSERT(nextScheduledTime &gt; simTime());
<a name="l01516"></a>01516     scheduleAt(nextScheduledTime, msg);
<a name="l01517"></a>01517 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a6cc2bafedafa13f79df2410b6617ff4b"></a><!-- doxytag: member="IPv6NeighbourDiscovery::sendQueuedPacketsToIPv6Module" ref="a6cc2bafedafa13f79df2410b6617ff4b" args="(Neighbour *nce)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPv6NeighbourDiscovery::sendQueuedPacketsToIPv6Module </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i_pv6_neighbour_cache_1_1_neighbour.html">Neighbour</a> *&nbsp;</td>
          <td class="paramname"> <em>nce</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send off any queued packets within the Neighbour Discovery module awaiting address resolution.</p>
<p>Not used yet-unsure if we really need it. --DELETED, Andras </p>

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00716">716</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01974">processNAForIncompleteNCEState()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00717"></a>00717 {
<a name="l00718"></a>00718     <a class="code" href="class_i_pv6_neighbour_discovery.html#a0e2372b38f3787dd836bcee6b77eb268">MsgPtrVector</a>&amp; pendingPackets = nce-&gt;pendingPackets;
<a name="l00719"></a>00719     <span class="keywordflow">while</span>(!pendingPackets.empty())<span class="comment">//FIXME: pendingPackets are always empty!!!!</span>
<a name="l00720"></a>00720     {
<a name="l00721"></a>00721         MsgPtrVector::iterator i = pendingPackets.begin();
<a name="l00722"></a>00722         cMessage *msg = (*i);
<a name="l00723"></a>00723         pendingPackets.erase(i);
<a name="l00724"></a>00724         <a class="code" href="class_i_pv6_neighbour_discovery.html#a8cebccf199f96d0903c4663b203199ca">pendingQueue</a>.remove(msg);
<a name="l00725"></a>00725         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Sending queued packet &quot;</span> &lt;&lt; msg &lt;&lt; endl;
<a name="l00726"></a>00726         send(msg,<span class="stringliteral">&quot;ipv6Out&quot;</span>);
<a name="l00727"></a>00727     }
<a name="l00728"></a>00728 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac2a5f2e2cbd6845ecd10038fce448ead"></a><!-- doxytag: member="IPv6NeighbourDiscovery::sendSolicitedNA" ref="ac2a5f2e2cbd6845ecd10038fce448ead" args="(IPv6NeighbourSolicitation *ns, IPv6ControlInfo *nsCtrlInfo, InterfaceEntry *ie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPv6NeighbourDiscovery::sendSolicitedNA </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_neighbour_solicitation.html">IPv6NeighbourSolicitation</a> *&nbsp;</td>
          <td class="paramname"> <em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>nsCtrlInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&nbsp;</td>
          <td class="paramname"> <em>ie</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01761">1761</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01699">processNSForNonTentativeAddress()</a>, and <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01720">processNSWithSpecifiedSrcAddr()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01763"></a>01763 {
<a name="l01764"></a>01764     <a class="code" href="class_i_pv6_neighbour_advertisement.html">IPv6NeighbourAdvertisement</a> *na = <span class="keyword">new</span> <a class="code" href="class_i_pv6_neighbour_advertisement.html">IPv6NeighbourAdvertisement</a>(<span class="stringliteral">&quot;NApacket&quot;</span>);
<a name="l01765"></a>01765     <span class="comment">//RFC 2461: Section 7.2.4</span>
<a name="l01766"></a>01766     <span class="comment">/*A node sends a Neighbor Advertisement in response to a valid Neighbor</span>
<a name="l01767"></a>01767 <span class="comment">    Solicitation targeting one of the node&apos;s assigned addresses.  The</span>
<a name="l01768"></a>01768 <span class="comment">    Target Address of the advertisement is copied from the Target Address</span>
<a name="l01769"></a>01769 <span class="comment">    of the solicitation.*/</span>
<a name="l01770"></a>01770     na-&gt;<a class="code" href="class_i_pv6_neighbour_advertisement.html#a600badcf3c7b5692f8c880e4e744c742">setTargetAddress</a>(ns-&gt;<a class="code" href="class_i_pv6_neighbour_solicitation.html#aa8758b1539001a247c925ead4856ec69">getTargetAddress</a>());
<a name="l01771"></a>01771 
<a name="l01772"></a>01772     <span class="comment">/*If the solicitation&apos;s IP Destination Address is not a multicast address,</span>
<a name="l01773"></a>01773 <span class="comment">    the Target Link-Layer Address option MAY be omitted; the neighboring node&apos;s</span>
<a name="l01774"></a>01774 <span class="comment">    cached value must already be current in order for the solicitation to have</span>
<a name="l01775"></a>01775 <span class="comment">    been received. If the solicitation&apos;s IP Destination Address is a multicast</span>
<a name="l01776"></a>01776 <span class="comment">    address, the Target Link-Layer option MUST be included in the advertisement.*/</span>
<a name="l01777"></a>01777     na-&gt;<a class="code" href="class_i_pv6_neighbour_advertisement.html#aa130a85bfaa5d5e3138160f583a1c816">setTargetLinkLayerAddress</a>(ie-&gt;<a class="code" href="class_interface_entry.html#af8004a12e9aac171699ff1f7f08ee4c4">getMacAddress</a>());<span class="comment">//here, we always include the MAC addr.</span>
<a name="l01778"></a>01778 
<a name="l01779"></a>01779     <span class="comment">/*Furthermore, if the node is a router, it MUST set the Router flag to one;</span>
<a name="l01780"></a>01780 <span class="comment">    otherwise it MUST set the flag to zero.*/</span>
<a name="l01781"></a>01781     na-&gt;<a class="code" href="class_i_pv6_neighbour_advertisement.html#af2e814ed9bc9dae603efef13d94afbca">setRouterFlag</a>(<a class="code" href="class_i_pv6_neighbour_discovery.html#a0f6a26512cd490f5a09e9bd7ec3bf61f">rt6</a>-&gt;<a class="code" href="class_routing_table6.html#a79a742fa2d94543412e183ebe0e83d3a">isRouter</a>());
<a name="l01782"></a>01782 
<a name="l01783"></a>01783     <span class="comment">/*If the (NS)Target Address is either an anycast address or a unicast</span>
<a name="l01784"></a>01784 <span class="comment">    address for which the node is providing proxy service, or the Target</span>
<a name="l01785"></a>01785 <span class="comment">    Link-Layer Address option is not included,*/</span>
<a name="l01786"></a>01786     <span class="comment">//TODO:ANYCAST will not be implemented here!</span>
<a name="l01787"></a>01787     <span class="keywordflow">if</span> (ns-&gt;<a class="code" href="class_i_pv6_neighbour_solicitation.html#ade4c8874a206e1696e204264db63d415">getSourceLinkLayerAddress</a>().<a class="code" href="class_m_a_c_address.html#ae41af013d782b46483e7d0c84f0ed107">isUnspecified</a>())
<a name="l01788"></a>01788         <span class="comment">//the Override flag SHOULD be set to zero.</span>
<a name="l01789"></a>01789         na-&gt;<a class="code" href="class_i_pv6_neighbour_advertisement.html#aaa9727d70111bdd604790662d8cf329c">setOverrideFlag</a>(<span class="keyword">false</span>);
<a name="l01790"></a>01790     <span class="keywordflow">else</span>
<a name="l01791"></a>01791         <span class="comment">//Otherwise, the Override flag SHOULD be set to one.</span>
<a name="l01792"></a>01792         na-&gt;<a class="code" href="class_i_pv6_neighbour_advertisement.html#aaa9727d70111bdd604790662d8cf329c">setOverrideFlag</a>(<span class="keyword">true</span>);
<a name="l01793"></a>01793     <span class="comment">/*Proper setting of the Override flag ensures that nodes give preference to</span>
<a name="l01794"></a>01794 <span class="comment">    non-proxy advertisements, even when received after proxy advertisements, and</span>
<a name="l01795"></a>01795 <span class="comment">    also ensures that the first advertisement for an anycast address &quot;wins&quot;.*/</span>
<a name="l01796"></a>01796 
<a name="l01797"></a>01797     <a class="code" href="class_i_pv6_address.html">IPv6Address</a> naDestAddr;
<a name="l01798"></a>01798     <span class="comment">//If the source of the solicitation is the unspecified address,</span>
<a name="l01799"></a>01799     <span class="keywordflow">if</span>(nsCtrlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a8980bdcd6051ae3fe071bf2c18a0215e">getSrcAddr</a>().<a class="code" href="class_i_pv6_address.html#af526cffcc3a4aa5bb96d307de6e8d448">isUnspecified</a>())
<a name="l01800"></a>01800     {
<a name="l01801"></a>01801         <span class="comment">/*the node MUST set the Solicited flag to zero and multicast the advertisement</span>
<a name="l01802"></a>01802 <span class="comment">        to the all-nodes address.*/</span>
<a name="l01803"></a>01803         na-&gt;<a class="code" href="class_i_pv6_neighbour_advertisement.html#a639b85fb52531eef528448f5ea53a7b3">setSolicitedFlag</a>(<span class="keyword">false</span>);
<a name="l01804"></a>01804         naDestAddr = <a class="code" href="class_i_pv6_address.html#af71ff608917fe0fc14baf50d11815aeb">IPv6Address::ALL_NODES_2</a>;
<a name="l01805"></a>01805     }
<a name="l01806"></a>01806     <span class="keywordflow">else</span>
<a name="l01807"></a>01807     {
<a name="l01808"></a>01808         <span class="comment">/*Otherwise, the node MUST set the Solicited flag to one and unicast</span>
<a name="l01809"></a>01809 <span class="comment">        the advertisement to the Source Address of the solicitation.*/</span>
<a name="l01810"></a>01810         na-&gt;<a class="code" href="class_i_pv6_neighbour_advertisement.html#a639b85fb52531eef528448f5ea53a7b3">setSolicitedFlag</a>(<span class="keyword">true</span>);
<a name="l01811"></a>01811         naDestAddr = nsCtrlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a8980bdcd6051ae3fe071bf2c18a0215e">getSrcAddr</a>();
<a name="l01812"></a>01812     }
<a name="l01813"></a>01813 
<a name="l01814"></a>01814     <span class="comment">/*If the Target Address is an anycast address the sender SHOULD delay sending</span>
<a name="l01815"></a>01815 <span class="comment">    a response for a random time between 0 and MAX_ANYCAST_DELAY_TIME seconds.*/</span>
<a name="l01816"></a>01816     <span class="comment">/*TODO: More associated complexity for this one. We will have to delay</span>
<a name="l01817"></a>01817 <span class="comment">    sending off the solicitation. Perhaps the self message could have a context</span>
<a name="l01818"></a>01818 <span class="comment">    pointer pointing to a struct with enough info to create and send a NA packet.*/</span>
<a name="l01819"></a>01819 
<a name="l01820"></a>01820     <span class="comment">/*Because unicast Neighbor Solicitations are not required to include a</span>
<a name="l01821"></a>01821 <span class="comment">    Source Link-Layer Address, it is possible that a node sending a</span>
<a name="l01822"></a>01822 <span class="comment">    solicited Neighbor Advertisement does not have a corresponding link-</span>
<a name="l01823"></a>01823 <span class="comment">    layer address for its neighbor in its Neighbor Cache.  In such</span>
<a name="l01824"></a>01824 <span class="comment">    situations, a node will first have to use Neighbor Discovery to</span>
<a name="l01825"></a>01825 <span class="comment">    determine the link-layer address of its neighbor (i.e, send out a</span>
<a name="l01826"></a>01826 <span class="comment">    multicast Neighbor Solicitation).*/</span>
<a name="l01827"></a>01827     <span class="comment">//TODO: if above mentioned happens, can addr resolution be performed for ND messages?</span>
<a name="l01828"></a>01828     <span class="comment">//if no link-layer addr exists for unicast addr when sending solicited NA, we should</span>
<a name="l01829"></a>01829     <span class="comment">//add the NA to the list of queued packets. What if we have a list of queued</span>
<a name="l01830"></a>01830     <span class="comment">//packets for different unicast solicitations? each time addr resolution is</span>
<a name="l01831"></a>01831     <span class="comment">//done we should check the destinations of the list of queued packets and send</span>
<a name="l01832"></a>01832     <span class="comment">//off the respective ones.</span>
<a name="l01833"></a>01833     <a class="code" href="class_i_pv6_address.html">IPv6Address</a> myIPv6Addr = ie-&gt;<a class="code" href="class_interface_entry.html#aed2588713b620093ada1ebfeb85fdbfc">ipv6Data</a>()-&gt;<a class="code" href="class_i_pv6_interface_data.html#a56f3fe4007e3df66dc88edd008f059b9">getPreferredAddress</a>();
<a name="l01834"></a>01834     <a class="code" href="class_i_pv6_neighbour_discovery.html#a58642b1dc383266b43abc6d6e4a74e5e">sendPacketToIPv6Module</a>(na, naDestAddr, myIPv6Addr, ie-&gt;<a class="code" href="class_interface_entry.html#adc901fa42c37ce16b5c0785da81106ce">getInterfaceId</a>());
<a name="l01835"></a>01835 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a32ed95da45989efe4509946492299d34"></a><!-- doxytag: member="IPv6NeighbourDiscovery::sendSolicitedRA" ref="a32ed95da45989efe4509946492299d34" args="(cMessage *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPv6NeighbourDiscovery::sendSolicitedRA </td>
          <td>(</td>
          <td class="paramtype">cMessage *&nbsp;</td>
          <td class="paramname"> <em>msg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01519">1519</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00081">handleMessage()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01520"></a>01520 {
<a name="l01521"></a>01521     <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Send Solicited RA invoked!\n&quot;</span>;
<a name="l01522"></a>01522     <a class="code" href="class_interface_entry.html">InterfaceEntry</a> *ie = (<a class="code" href="class_interface_entry.html">InterfaceEntry</a> *)msg-&gt;getContextPointer();
<a name="l01523"></a>01523     <a class="code" href="class_i_pv6_address.html">IPv6Address</a> destAddr = <a class="code" href="class_i_pv6_address.html">IPv6Address</a>(<span class="stringliteral">&quot;FF02::1&quot;</span>);
<a name="l01524"></a>01524     <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Testing condition!\n&quot;</span>;
<a name="l01525"></a>01525     <a class="code" href="class_i_pv6_neighbour_discovery.html#a50d09a125fd3477828643875b72573ec">createAndSendRAPacket</a>(destAddr, ie);
<a name="l01526"></a>01526     <span class="keyword">delete</span> msg;
<a name="l01527"></a>01527 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a30bc9cd2bec93e40e238fe91b573ca9f"></a><!-- doxytag: member="IPv6NeighbourDiscovery::sendUnsolicitedNA" ref="a30bc9cd2bec93e40e238fe91b573ca9f" args="(InterfaceEntry *ie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPv6NeighbourDiscovery::sendUnsolicitedNA </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_interface_entry.html">InterfaceEntry</a> *&nbsp;</td>
          <td class="paramname"> <em>ie</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01837">1837</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01838"></a>01838 {
<a name="l01839"></a>01839     <span class="comment">//RFC 2461</span>
<a name="l01840"></a>01840     <span class="comment">//Section 7.2.6: Sending Unsolicited Neighbor Advertisements</span>
<a name="l01841"></a>01841 
<a name="l01842"></a>01842     <span class="comment">/*In some cases a node may be able to determine that its link-layer</span>
<a name="l01843"></a>01843 <span class="comment">    address has changed (e.g., hot-swap of an interface card) and may</span>
<a name="l01844"></a>01844 <span class="comment">    wish to inform its neighbors of the new link-layer address quickly.</span>
<a name="l01845"></a>01845 <span class="comment">    In such cases a node MAY send up to MAX_NEIGHBOR_ADVERTISEMENT</span>
<a name="l01846"></a>01846 <span class="comment">    unsolicited Neighbor Advertisement messages to the all-nodes</span>
<a name="l01847"></a>01847 <span class="comment">    multicast address.  These advertisements MUST be separated by at</span>
<a name="l01848"></a>01848 <span class="comment">    least RetransTimer seconds.</span>
<a name="l01849"></a>01849 <span class="comment"></span>
<a name="l01850"></a>01850 <span class="comment">    The Target Address field in the unsolicited advertisement is set to</span>
<a name="l01851"></a>01851 <span class="comment">    an IP address of the interface, and the Target Link-Layer Address</span>
<a name="l01852"></a>01852 <span class="comment">    option is filled with the new link-layer address.  The Solicited flag</span>
<a name="l01853"></a>01853 <span class="comment">    MUST be set to zero, in order to avoid confusing the Neighbor</span>
<a name="l01854"></a>01854 <span class="comment">    Unreachability Detection algorithm.  If the node is a router, it MUST</span>
<a name="l01855"></a>01855 <span class="comment">    set the Router flag to one; otherwise it MUST set it to zero.  The</span>
<a name="l01856"></a>01856 <span class="comment">    Override flag MAY be set to either zero or one.  In either case,</span>
<a name="l01857"></a>01857 <span class="comment">    neighboring nodes will immediately change the state of their Neighbor</span>
<a name="l01858"></a>01858 <span class="comment">    Cache entries for the Target Address to STALE, prompting them to</span>
<a name="l01859"></a>01859 <span class="comment">    verify the path for reachability.  If the Override flag is set to</span>
<a name="l01860"></a>01860 <span class="comment">    one, neighboring nodes will install the new link-layer address in</span>
<a name="l01861"></a>01861 <span class="comment">    their caches.  Otherwise, they will ignore the new link-layer</span>
<a name="l01862"></a>01862 <span class="comment">    address, choosing instead to probe the cached address.</span>
<a name="l01863"></a>01863 <span class="comment"></span>
<a name="l01864"></a>01864 <span class="comment">    A node that has multiple IP addresses assigned to an interface MAY</span>
<a name="l01865"></a>01865 <span class="comment">    multicast a separate Neighbor Advertisement for each address.  In</span>
<a name="l01866"></a>01866 <span class="comment">    such a case the node SHOULD introduce a small delay between the</span>
<a name="l01867"></a>01867 <span class="comment">    sending of each advertisement to reduce the probability of the</span>
<a name="l01868"></a>01868 <span class="comment">    advertisements being lost due to congestion.</span>
<a name="l01869"></a>01869 <span class="comment"></span>
<a name="l01870"></a>01870 <span class="comment">    A proxy MAY multicast Neighbor Advertisements when its link-layer</span>
<a name="l01871"></a>01871 <span class="comment">    address changes or when it is configured (by system management or</span>
<a name="l01872"></a>01872 <span class="comment">    other mechanisms) to proxy for an address.  If there are multiple</span>
<a name="l01873"></a>01873 <span class="comment">    nodes that are providing proxy services for the same set of addresses</span>
<a name="l01874"></a>01874 <span class="comment">    the proxies SHOULD provide a mechanism that prevents multiple proxies</span>
<a name="l01875"></a>01875 <span class="comment">    from multicasting advertisements for any one address, in order to</span>
<a name="l01876"></a>01876 <span class="comment">    reduce the risk of excessive multicast traffic.</span>
<a name="l01877"></a>01877 <span class="comment"></span>
<a name="l01878"></a>01878 <span class="comment">    Also, a node belonging to an anycast address MAY multicast</span>
<a name="l01879"></a>01879 <span class="comment">    unsolicited Neighbor Advertisements for the anycast address when the</span>
<a name="l01880"></a>01880 <span class="comment">    node&apos;s link-layer address changes.</span>
<a name="l01881"></a>01881 <span class="comment"></span>
<a name="l01882"></a>01882 <span class="comment">    Note that because unsolicited Neighbor Advertisements do not reliably</span>
<a name="l01883"></a>01883 <span class="comment">    update caches in all nodes (the advertisements might not be received</span>
<a name="l01884"></a>01884 <span class="comment">    by all nodes), they should only be viewed as a performance</span>
<a name="l01885"></a>01885 <span class="comment">    optimization to quickly update the caches in most neighbors.  The</span>
<a name="l01886"></a>01886 <span class="comment">    Neighbor Unreachability Detection algorithm ensures that all nodes</span>
<a name="l01887"></a>01887 <span class="comment">    obtain a reachable link-layer address, though the delay may be</span>
<a name="l01888"></a>01888 <span class="comment">    slightly longer.*/</span>
<a name="l01889"></a>01889 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a303391440ad2004ff69cfc5e4cf7504a"></a><!-- doxytag: member="IPv6NeighbourDiscovery::timeoutDefaultRouter" ref="a303391440ad2004ff69cfc5e4cf7504a" args="(const IPv6Address &amp;addr, int interfaceID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPv6NeighbourDiscovery::timeoutDefaultRouter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>interfaceID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>RFC 2461: Section 6.3.5 Whenever the Lifetime of an entry in the Default Router List expires, that entry is discarded. When removing a router from the Default Router list, the node MUST update the Destination Cache in such a way that all entries using the router perform next-hop determination again rather than continue sending traffic to the (deleted) router. </p>

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00578">578</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01153">processRAForRouterUpdates()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00580"></a>00580 {
<a name="l00581"></a>00581     <span class="comment">//RFC 2461: Section 6.3.5</span>
<a name="l00582"></a>00582     <span class="comment">/*Whenever the Lifetime of an entry in the Default Router List expires,</span>
<a name="l00583"></a>00583 <span class="comment">    that entry is discarded.*/</span>
<a name="l00584"></a>00584     <a class="code" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">neighbourCache</a>.<a class="code" href="class_i_pv6_neighbour_cache.html#a877bc367ca422baabc22199c5036df83">remove</a>(addr, interfaceID);
<a name="l00585"></a>00585 
<a name="l00586"></a>00586     <span class="comment">/*When removing a router from the Default Router list, the node MUST update</span>
<a name="l00587"></a>00587 <span class="comment">    the Destination Cache in such a way that all entries using the router perform</span>
<a name="l00588"></a>00588 <span class="comment">    next-hop determination again rather than continue sending traffic to the</span>
<a name="l00589"></a>00589 <span class="comment">    (deleted) router.*/</span>
<a name="l00590"></a>00590     <a class="code" href="class_i_pv6_neighbour_discovery.html#a0f6a26512cd490f5a09e9bd7ec3bf61f">rt6</a>-&gt;<a class="code" href="class_routing_table6.html#a1b4f1c86d678de8ac3f873ac7de0687f">purgeDestCacheEntriesToNeighbour</a>(addr, interfaceID);
<a name="l00591"></a>00591 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0e59b5c2995f7bdec6b6a67e60a1e675"></a><!-- doxytag: member="IPv6NeighbourDiscovery::timeoutPrefixEntry" ref="a0e59b5c2995f7bdec6b6a67e60a1e675" args="(const IPv6Address &amp;destPrefix, int prefixLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPv6NeighbourDiscovery::timeoutPrefixEntry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_pv6_address.html">IPv6Address</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>destPrefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>prefixLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>RFC 2461: Section 6.3.5 Whenever the invalidation timer expires for a Prefix List entry, that entry is discarded. No existing Destination Cache entries need be updated, however. Should a reachability problem arise with an existing Neighbor Cache entry, Neighbor Unreachability Detection will perform any needed recovery. </p>

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00563">563</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00565"></a>00565 {
<a name="l00566"></a>00566     <span class="comment">//RFC 2461: Section 6.3.5</span>
<a name="l00567"></a>00567     <span class="comment">/*Whenever the invalidation timer expires for a Prefix List entry, that</span>
<a name="l00568"></a>00568 <span class="comment">    entry is discarded.*/</span>
<a name="l00569"></a>00569     <a class="code" href="class_i_pv6_neighbour_discovery.html#a0f6a26512cd490f5a09e9bd7ec3bf61f">rt6</a>-&gt;<a class="code" href="class_routing_table6.html#a85e00922381c188efc0ad51197e5f718">removeOnLinkPrefix</a>(destPrefix, prefixLength);
<a name="l00570"></a>00570     <span class="comment">//hmmm... should the unicast address associated with this prefix be deleted</span>
<a name="l00571"></a>00571     <span class="comment">//as well?-TODO: The address should be timeout/deleted as well!!</span>
<a name="l00572"></a>00572 
<a name="l00573"></a>00573     <span class="comment">/*No existing Destination Cache entries need be updated, however. Should a</span>
<a name="l00574"></a>00574 <span class="comment">    reachability problem arise with an existing Neighbor Cache entry, Neighbor</span>
<a name="l00575"></a>00575 <span class="comment">    Unreachability Detection will perform any needed recovery.*/</span>
<a name="l00576"></a>00576 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a8f18a6e238820911ee6253f12b766fad"></a><!-- doxytag: member="IPv6NeighbourDiscovery::validateNAPacket" ref="a8f18a6e238820911ee6253f12b766fad" args="(IPv6NeighbourAdvertisement *na, IPv6ControlInfo *naCtrlInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IPv6NeighbourDiscovery::validateNAPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_neighbour_advertisement.html">IPv6NeighbourAdvertisement</a> *&nbsp;</td>
          <td class="paramname"> <em>na</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>naCtrlInfo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01934">1934</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01891">processNAPacket()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01936"></a>01936 {
<a name="l01937"></a>01937     <span class="keywordtype">bool</span> result = <span class="keyword">true</span>;<span class="comment">//adopt optimistic approach</span>
<a name="l01938"></a>01938 
<a name="l01939"></a>01939     <span class="comment">//RFC 2461:7.1.2 Validation of Neighbor Advertisments(some checks are omitted)</span>
<a name="l01940"></a>01940     <span class="comment">//A node MUST silently discard any received Neighbor Advertisment messages</span>
<a name="l01941"></a>01941     <span class="comment">//that do not satisfy all of the following validity checks:</span>
<a name="l01942"></a>01942 
<a name="l01943"></a>01943     <span class="comment">//- The IP Hop Limit field has a value of 255, i.e., the packet</span>
<a name="l01944"></a>01944     <span class="comment">//  could not possibly have been forwarded by a router.</span>
<a name="l01945"></a>01945     <span class="keywordflow">if</span> (naCtrlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a2eea197980c0c35518b3285ab9c123da">getHopLimit</a>() != 255)
<a name="l01946"></a>01946     {
<a name="l01947"></a>01947         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Hop Limit is not 255! NA validation failed!\n&quot;</span>;
<a name="l01948"></a>01948         result = <span class="keyword">false</span>;
<a name="l01949"></a>01949     }
<a name="l01950"></a>01950 
<a name="l01951"></a>01951     <span class="comment">//- Target Address is not a multicast address.</span>
<a name="l01952"></a>01952     <span class="keywordflow">if</span> (na-&gt;<a class="code" href="class_i_pv6_neighbour_advertisement.html#ab4ced614f69b3cf120dbb835fbd7c11b">getTargetAddress</a>().<a class="code" href="class_i_pv6_address.html#a3c3bb6898821e044b12cf31911c90201">isMulticast</a>() == <span class="keyword">true</span>)
<a name="l01953"></a>01953     {
<a name="l01954"></a>01954         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Target Address is a multicast address! NA validation failed!\n&quot;</span>;
<a name="l01955"></a>01955         result = <span class="keyword">false</span>;
<a name="l01956"></a>01956     }
<a name="l01957"></a>01957 
<a name="l01958"></a>01958     <span class="comment">//- If the IP Destination Address is a multicast address the Solicited flag</span>
<a name="l01959"></a>01959     <span class="comment">//  is zero.</span>
<a name="l01960"></a>01960     <span class="keywordflow">if</span> (naCtrlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#abd1d2c1cca62a40e351304d8584b4fd7">getDestAddr</a>().<a class="code" href="class_i_pv6_address.html#a3c3bb6898821e044b12cf31911c90201">isMulticast</a>())
<a name="l01961"></a>01961     {
<a name="l01962"></a>01962         <span class="keywordflow">if</span> (na-&gt;<a class="code" href="class_i_pv6_neighbour_advertisement.html#a930381145de395cf787734ae40ea7361">getSolicitedFlag</a>() == <span class="keyword">true</span>)
<a name="l01963"></a>01963         {
<a name="l01964"></a>01964             <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Dest Address is multicast address but solicted flag is 0!\n&quot;</span>;
<a name="l01965"></a>01965             result = <span class="keyword">false</span>;
<a name="l01966"></a>01966         }
<a name="l01967"></a>01967     }
<a name="l01968"></a>01968 
<a name="l01969"></a>01969     <span class="keywordflow">if</span> (result == <span class="keyword">true</span>) bubble(<span class="stringliteral">&quot;NA validation passed.&quot;</span>);
<a name="l01970"></a>01970     <span class="keywordflow">else</span> bubble(<span class="stringliteral">&quot;NA validation failed.&quot;</span>);
<a name="l01971"></a>01971     <span class="keywordflow">return</span> result;
<a name="l01972"></a>01972 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a72d9ee3401361c560c47f5172c05c1a4"></a><!-- doxytag: member="IPv6NeighbourDiscovery::validateNSPacket" ref="a72d9ee3401361c560c47f5172c05c1a4" args="(IPv6NeighbourSolicitation *ns, IPv6ControlInfo *nsCtrlInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IPv6NeighbourDiscovery::validateNSPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_neighbour_solicitation.html">IPv6NeighbourSolicitation</a> *&nbsp;</td>
          <td class="paramname"> <em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>nsCtrlInfo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01628">1628</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01591">processNSPacket()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01630"></a>01630 {
<a name="l01631"></a>01631     <span class="keywordtype">bool</span> result = <span class="keyword">true</span>;
<a name="l01632"></a>01632     <span class="comment">/*RFC 2461:7.1.1. Validation of Neighbor Solicitations(some checks are omitted)</span>
<a name="l01633"></a>01633 <span class="comment">    A node MUST silently discard any received Neighbor Solicitation</span>
<a name="l01634"></a>01634 <span class="comment">    messages that do not satisfy all of the following validity checks:*/</span>
<a name="l01635"></a>01635     <span class="comment">//- The IP Hop Limit field has a value of 255, i.e., the packet</span>
<a name="l01636"></a>01636     <span class="comment">//could not possibly have been forwarded by a router.</span>
<a name="l01637"></a>01637     <span class="keywordflow">if</span> (nsCtrlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a2eea197980c0c35518b3285ab9c123da">getHopLimit</a>() != 255)
<a name="l01638"></a>01638     {
<a name="l01639"></a>01639         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Hop limit is not 255! NS validation failed!\n&quot;</span>;
<a name="l01640"></a>01640         result = <span class="keyword">false</span>;
<a name="l01641"></a>01641     }
<a name="l01642"></a>01642     <span class="comment">//- Target Address is not a multicast address.</span>
<a name="l01643"></a>01643     <span class="keywordflow">if</span> (ns-&gt;<a class="code" href="class_i_pv6_neighbour_solicitation.html#aa8758b1539001a247c925ead4856ec69">getTargetAddress</a>().<a class="code" href="class_i_pv6_address.html#a3c3bb6898821e044b12cf31911c90201">isMulticast</a>() == <span class="keyword">true</span>)
<a name="l01644"></a>01644     {
<a name="l01645"></a>01645         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Target address is a multicast address! NS validation failed!\n&quot;</span>;
<a name="l01646"></a>01646         result = <span class="keyword">false</span>;
<a name="l01647"></a>01647     }
<a name="l01648"></a>01648     <span class="comment">//- If the IP source address is the unspecified address,</span>
<a name="l01649"></a>01649     <span class="keywordflow">if</span> (nsCtrlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a8980bdcd6051ae3fe071bf2c18a0215e">getSrcAddr</a>().<a class="code" href="class_i_pv6_address.html#af526cffcc3a4aa5bb96d307de6e8d448">isUnspecified</a>())
<a name="l01650"></a>01650     {
<a name="l01651"></a>01651         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Source Address is unspecified\n&quot;</span>;
<a name="l01652"></a>01652         <span class="comment">//the IP destination address is a solicited-node multicast address.</span>
<a name="l01653"></a>01653         <span class="keywordflow">if</span> (nsCtrlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#abd1d2c1cca62a40e351304d8584b4fd7">getDestAddr</a>().<a class="code" href="class_i_pv6_address.html#a4d9102b52fcf98d1945c75a098bc678a">matches</a>(<a class="code" href="class_i_pv6_address.html#a05683ca5f1a158a96c9a319314cb47bd">IPv6Address::SOLICITED_NODE_PREFIX</a>,104) == <span class="keyword">false</span>)
<a name="l01654"></a>01654         {
<a name="l01655"></a>01655             <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot; but IP dest address is not a solicited-node multicast address! NS validation failed!\n&quot;</span>;
<a name="l01656"></a>01656             result = <span class="keyword">false</span>;
<a name="l01657"></a>01657         }
<a name="l01658"></a>01658         <span class="comment">//there is no source link-layer address option in the message.</span>
<a name="l01659"></a>01659         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ns-&gt;<a class="code" href="class_i_pv6_neighbour_solicitation.html#ade4c8874a206e1696e204264db63d415">getSourceLinkLayerAddress</a>().<a class="code" href="class_m_a_c_address.html#ae41af013d782b46483e7d0c84f0ed107">isUnspecified</a>() == <span class="keyword">false</span>)
<a name="l01660"></a>01660         {
<a name="l01661"></a>01661             <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot; but Source link-layer address is not empty! NS validation failed!\n&quot;</span>;
<a name="l01662"></a>01662             result = <span class="keyword">false</span>;
<a name="l01663"></a>01663         }
<a name="l01664"></a>01664         <span class="keywordflow">else</span>
<a name="l01665"></a>01665             <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;NS Validation Passed\n&quot;</span>;
<a name="l01666"></a>01666     }
<a name="l01667"></a>01667 
<a name="l01668"></a>01668     <span class="keywordflow">return</span> result;
<a name="l01669"></a>01669 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a902261563ea0bd130700a148a062781c"></a><!-- doxytag: member="IPv6NeighbourDiscovery::validateRAPacket" ref="a902261563ea0bd130700a148a062781c" args="(IPv6RouterAdvertisement *ra, IPv6ControlInfo *raCtrlInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IPv6NeighbourDiscovery::validateRAPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_router_advertisement.html">IPv6RouterAdvertisement</a> *&nbsp;</td>
          <td class="paramname"> <em>ra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>raCtrlInfo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01529">1529</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01116">processRAPacket()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01531"></a>01531 {
<a name="l01532"></a>01532     <span class="keywordtype">bool</span> result = <span class="keyword">true</span>;
<a name="l01533"></a>01533 
<a name="l01534"></a>01534     <span class="comment">//RFC 2461: Section 6.1.2 Validation of Router Advertisement Messages</span>
<a name="l01535"></a>01535     <span class="comment">/*A node MUST silently discard any received Router Advertisement</span>
<a name="l01536"></a>01536 <span class="comment">    messages that do not satisfy all of the following validity checks:*/</span>
<a name="l01537"></a>01537     raCtrlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a8980bdcd6051ae3fe071bf2c18a0215e">getSrcAddr</a>();
<a name="l01538"></a>01538     <span class="comment">//- IP Source Address is a link-local address.  Routers must use</span>
<a name="l01539"></a>01539     <span class="comment">//  their link-local address as the source for Router Advertisement</span>
<a name="l01540"></a>01540     <span class="comment">//  and Redirect messages so that hosts can uniquely identify</span>
<a name="l01541"></a>01541     <span class="comment">//  routers.</span>
<a name="l01542"></a>01542     <span class="keywordflow">if</span> (raCtrlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a8980bdcd6051ae3fe071bf2c18a0215e">getSrcAddr</a>().<a class="code" href="class_i_pv6_address.html#a304edc5014ff3c991ae531aca21d2260">isLinkLocal</a>() == <span class="keyword">false</span>)
<a name="l01543"></a>01543     {
<a name="l01544"></a>01544         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;RA source address is not link-local. RA validation failed!\n&quot;</span>;
<a name="l01545"></a>01545         result = <span class="keyword">false</span>;
<a name="l01546"></a>01546     }
<a name="l01547"></a>01547 
<a name="l01548"></a>01548     <span class="comment">//- The IP Hop Limit field has a value of 255, i.e., the packet</span>
<a name="l01549"></a>01549     <span class="comment">//  could not possibly have been forwarded by a router.</span>
<a name="l01550"></a>01550     <span class="keywordflow">if</span> (raCtrlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a2eea197980c0c35518b3285ab9c123da">getHopLimit</a>() != 255)
<a name="l01551"></a>01551     {
<a name="l01552"></a>01552         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Hop limit is not 255! RA validation failed!\n&quot;</span>;
<a name="l01553"></a>01553         result = <span class="keyword">false</span>;
<a name="l01554"></a>01554     }
<a name="l01555"></a>01555 
<a name="l01556"></a>01556     <span class="comment">//- ICMP Code is 0.</span>
<a name="l01557"></a>01557     <span class="keywordflow">if</span> (raCtrlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a6ddd9db30da22159c80f34a5512f9833">getProtocol</a>() != <a class="code" href="_i_p_protocol_id__m_8h.html#a4297c2f400ba53cf6866e6d45bc81b70a3f40fb193e9edf4e297fcd7952acb024">IP_PROT_IPv6_ICMP</a>)
<a name="l01558"></a>01558     {
<a name="l01559"></a>01559         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;ICMP Code is not 0! RA validation failed!\n&quot;</span>;
<a name="l01560"></a>01560         result = <span class="keyword">false</span>;
<a name="l01561"></a>01561     }
<a name="l01562"></a>01562 
<a name="l01563"></a>01563     <span class="keywordflow">return</span> result;
<a name="l01564"></a>01564 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a09f8b6d13b8546d9c3d735589df9e37f"></a><!-- doxytag: member="IPv6NeighbourDiscovery::validateRSPacket" ref="a09f8b6d13b8546d9c3d735589df9e37f" args="(IPv6RouterSolicitation *rs, IPv6ControlInfo *rsCtrlInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IPv6NeighbourDiscovery::validateRSPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv6_router_solicitation.html">IPv6RouterSolicitation</a> *&nbsp;</td>
          <td class="paramname"> <em>rs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv6_control_info.html">IPv6ControlInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>rsCtrlInfo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01010">1010</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00935">processRSPacket()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01012"></a>01012 {
<a name="l01013"></a>01013     <span class="keywordtype">bool</span> result = <span class="keyword">true</span>;
<a name="l01014"></a>01014     <span class="comment">/*6.1.1.  Validation of Router Solicitation Messages</span>
<a name="l01015"></a>01015 <span class="comment">    A router MUST silently discard any received Router Solicitation</span>
<a name="l01016"></a>01016 <span class="comment">    messages that do not satisfy all of the following validity checks:</span>
<a name="l01017"></a>01017 <span class="comment"></span>
<a name="l01018"></a>01018 <span class="comment">    - The IP Hop Limit field has a value of 255, i.e., the packet</span>
<a name="l01019"></a>01019 <span class="comment">    could not possibly have been forwarded by a router.*/</span>
<a name="l01020"></a>01020     <span class="keywordflow">if</span> (rsCtrlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a2eea197980c0c35518b3285ab9c123da">getHopLimit</a>() != 255)
<a name="l01021"></a>01021     {
<a name="l01022"></a>01022         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;Hop limit is not 255! RS validation failed!\n&quot;</span>;
<a name="l01023"></a>01023         result = <span class="keyword">false</span>;
<a name="l01024"></a>01024     }
<a name="l01025"></a>01025     <span class="comment">//- ICMP Code is 0.</span>
<a name="l01026"></a>01026     <span class="keywordflow">if</span> (rsCtrlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a6ddd9db30da22159c80f34a5512f9833">getProtocol</a>() != <a class="code" href="_i_p_protocol_id__m_8h.html#a4297c2f400ba53cf6866e6d45bc81b70a3f40fb193e9edf4e297fcd7952acb024">IP_PROT_IPv6_ICMP</a>)
<a name="l01027"></a>01027     {
<a name="l01028"></a>01028         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;ICMP Code is not 0! RS validation failed!\n&quot;</span>;
<a name="l01029"></a>01029         result = <span class="keyword">false</span>;
<a name="l01030"></a>01030     }
<a name="l01031"></a>01031     <span class="comment">//- If the IP source address is the unspecified address, there is no</span>
<a name="l01032"></a>01032     <span class="comment">//source link-layer address option in the message.</span>
<a name="l01033"></a>01033     <span class="keywordflow">if</span> (rsCtrlInfo-&gt;<a class="code" href="class_i_pv6_control_info___base.html#a8980bdcd6051ae3fe071bf2c18a0215e">getSrcAddr</a>().<a class="code" href="class_i_pv6_address.html#af526cffcc3a4aa5bb96d307de6e8d448">isUnspecified</a>())
<a name="l01034"></a>01034     {
<a name="l01035"></a>01035         <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot;IP source address is unspecified\n&quot;</span>;
<a name="l01036"></a>01036         <span class="keywordflow">if</span> (rs-&gt;<a class="code" href="class_i_pv6_router_solicitation.html#ac27e5211d09ebbfe316b4c2b28e3a232">getSourceLinkLayerAddress</a>().<a class="code" href="class_m_a_c_address.html#ae41af013d782b46483e7d0c84f0ed107">isUnspecified</a>() == <span class="keyword">false</span>)
<a name="l01037"></a>01037         {
<a name="l01038"></a>01038             <a class="code" href="_basic_module_8h.html#a650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">&quot; but source link layer address is provided. RS validation failed!\n&quot;</span>;
<a name="l01039"></a>01039         }
<a name="l01040"></a>01040     }
<a name="l01041"></a>01041     <span class="keywordflow">return</span> result;
<a name="l01042"></a>01042 }
</pre></div></p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a868ef2afa69950bd536b1fb5cd10569a"></a><!-- doxytag: member="IPv6NeighbourDiscovery::advIfList" ref="a868ef2afa69950bd536b1fb5cd10569a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_pv6_neighbour_discovery.html#a74d1e81840eb6742f1f595691e43ac29">AdvIfList</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a868ef2afa69950bd536b1fb5cd10569a">IPv6NeighbourDiscovery::advIfList</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8h_source.html#l00130">130</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8h_source.html">IPv6NeighbourDiscovery.h</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01440">createRATimer()</a>, and <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00260">fetchAdvIfEntry()</a>.</p>

</div>
</div>
<a class="anchor" id="a750d70366700481befd66c567d420a7e"></a><!-- doxytag: member="IPv6NeighbourDiscovery::dadList" ref="a750d70366700481befd66c567d420a7e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_pv6_neighbour_discovery.html#a516186e680ba4eaf87de697019421987">DADList</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a750d70366700481befd66c567d420a7e">IPv6NeighbourDiscovery::dadList</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8h_source.html#l00126">126</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8h_source.html">IPv6NeighbourDiscovery.h</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00756">initiateDAD()</a>, and <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00783">processDADTimeout()</a>.</p>

</div>
</div>
<a class="anchor" id="a78cfa038ef771566c18a2eec28fd740b"></a><!-- doxytag: member="IPv6NeighbourDiscovery::icmpv6" ref="a78cfa038ef771566c18a2eec28fd740b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_c_m_pv6.html">ICMPv6</a>* <a class="el" href="class_i_pv6_neighbour_discovery.html#a78cfa038ef771566c18a2eec28fd740b">IPv6NeighbourDiscovery::icmpv6</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8h_source.html#l00092">92</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8h_source.html">IPv6NeighbourDiscovery.h</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00670">dropQueuedPacketsAwaitingAR()</a>, <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00049">initialize()</a>, and <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00185">processIPv6Datagram()</a>.</p>

</div>
</div>
<a class="anchor" id="a4b4f35b761b93c397e2a5a36c1e08d38"></a><!-- doxytag: member="IPv6NeighbourDiscovery::ift" ref="a4b4f35b761b93c397e2a5a36c1e08d38" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_interface_table.html">IInterfaceTable</a>* <a class="el" href="class_i_pv6_neighbour_discovery.html#a4b4f35b761b93c397e2a5a36c1e08d38">IPv6NeighbourDiscovery::ift</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8h_source.html#l00090">90</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8h_source.html">IPv6NeighbourDiscovery.h</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00730">assignLinkLocalAddress()</a>, <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00049">initialize()</a>, <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00593">initiateAddressResolution()</a>, <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00430">initiateNeighbourUnreachabilityDetection()</a>, <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00646">processARTimeout()</a>, <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00783">processDADTimeout()</a>, <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01974">processNAForIncompleteNCEState()</a>, <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l02022">processNAForOtherNCEStates()</a>, <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01891">processNAPacket()</a>, <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01591">processNSPacket()</a>, <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00449">processNUDTimeout()</a>, <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01153">processRAForRouterUpdates()</a>, <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01116">processRAPacket()</a>, and <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00935">processRSPacket()</a>.</p>

</div>
</div>
<a class="anchor" id="a2034aa8fe938bda7f5e032d95892cf84"></a><!-- doxytag: member="IPv6NeighbourDiscovery::neighbourCache" ref="a2034aa8fe938bda7f5e032d95892cf84" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_pv6_neighbour_cache.html">IPv6NeighbourCache</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a2034aa8fe938bda7f5e032d95892cf84">IPv6NeighbourDiscovery::neighbourCache</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8h_source.html#l00093">93</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8h_source.html">IPv6NeighbourDiscovery.h</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00670">dropQueuedPacketsAwaitingAR()</a>, <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00185">processIPv6Datagram()</a>, <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01891">processNAPacket()</a>, <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01720">processNSWithSpecifiedSrcAddr()</a>, <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00449">processNUDTimeout()</a>, <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01153">processRAForRouterUpdates()</a>, <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00314">reachabilityConfirmed()</a>, <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00286">resolveNeighbour()</a>, <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00491">selectDefaultRouter()</a>, and <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00578">timeoutDefaultRouter()</a>.</p>

</div>
</div>
<a class="anchor" id="a8cebccf199f96d0903c4663b203199ca"></a><!-- doxytag: member="IPv6NeighbourDiscovery::pendingQueue" ref="a8cebccf199f96d0903c4663b203199ca" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cQueue <a class="el" href="class_i_pv6_neighbour_discovery.html#a8cebccf199f96d0903c4663b203199ca">IPv6NeighbourDiscovery::pendingQueue</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8h_source.html#l00088">88</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8h_source.html">IPv6NeighbourDiscovery.h</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00670">dropQueuedPacketsAwaitingAR()</a>, <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00049">initialize()</a>, <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00185">processIPv6Datagram()</a>, and <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00716">sendQueuedPacketsToIPv6Module()</a>.</p>

</div>
</div>
<a class="anchor" id="ad8d41d97624aa9ba4878adea476018d0"></a><!-- doxytag: member="IPv6NeighbourDiscovery::raTimerList" ref="ad8d41d97624aa9ba4878adea476018d0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_pv6_neighbour_discovery.html#af7b0af85c2810acc01d715305818f59b">RATimerList</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#ad8d41d97624aa9ba4878adea476018d0">IPv6NeighbourDiscovery::raTimerList</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8h_source.html#l00124">124</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8h_source.html">IPv6NeighbourDiscovery.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7f075a086f580756337ef6f59223727c"></a><!-- doxytag: member="IPv6NeighbourDiscovery::rdList" ref="a7f075a086f580756337ef6f59223727c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_pv6_neighbour_discovery.html#a99d6acdeeccceb22d5b199a46c1a0e78">RDList</a> <a class="el" href="class_i_pv6_neighbour_discovery.html#a7f075a086f580756337ef6f59223727c">IPv6NeighbourDiscovery::rdList</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8h_source.html#l00128">128</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8h_source.html">IPv6NeighbourDiscovery.h</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00889">cancelRouterDiscovery()</a>, <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00273">fetchRDEntry()</a>, and <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00854">initiateRouterDiscovery()</a>.</p>

</div>
</div>
<a class="anchor" id="a0f6a26512cd490f5a09e9bd7ec3bf61f"></a><!-- doxytag: member="IPv6NeighbourDiscovery::rt6" ref="a0f6a26512cd490f5a09e9bd7ec3bf61f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_routing_table6.html">RoutingTable6</a>* <a class="el" href="class_i_pv6_neighbour_discovery.html#a0f6a26512cd490f5a09e9bd7ec3bf61f">IPv6NeighbourDiscovery::rt6</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_pv6_neighbour_discovery_8h_source.html#l00091">91</a> of file <a class="el" href="_i_pv6_neighbour_discovery_8h_source.html">IPv6NeighbourDiscovery.h</a>.</p>

<p>Referenced by <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00381">determineNextHop()</a>, <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00049">initialize()</a>, <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01671">processNSForTentativeAddress()</a>, <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01153">processRAForRouterUpdates()</a>, <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01278">processRAPrefixInfo()</a>, <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l01761">sendSolicitedNA()</a>, <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00578">timeoutDefaultRouter()</a>, and <a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html#l00563">timeoutPrefixEntry()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_i_pv6_neighbour_discovery_8h_source.html">IPv6NeighbourDiscovery.h</a></li>
<li><a class="el" href="_i_pv6_neighbour_discovery_8cc_source.html">IPv6NeighbourDiscovery.cc</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Tue Mar 23 17:08:34 2010 for INET Framework for OMNeT++/OMNEST by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
