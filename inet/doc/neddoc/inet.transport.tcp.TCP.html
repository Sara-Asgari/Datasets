<html>
   <head>
      <link rel="stylesheet" type="text/css" href="style.css" />
   </head>
   <body onload="">
<h2 class="comptitle">Simple Module <i>TCP</i></h2>
<b>Package:</b> inet.transport.tcp<br/><b>File: <a href="src-transport-tcp-TCP.ned.html">src/transport/tcp/TCP.ned</a></b><br/><p><a href="../doxy/class_t_c_p.html" target="mainframe"><b>C++ definition</b></a></p>

<p>The TCPNewReno, TCPReno and TCPTahoe algorithms implement:</p>
  <ul><li>delayed acks, with 200ms timeout (optional)</li>
  <li>RFC 896 - Nagle's algorithm (optional)</li>
  <li>Jacobson's and Karn's algorithms for round-trip time measurement and
   adaptive retransmission</li>
  <li>TCPTahoe (Fast Retransmit), TCPReno (Fast Retransmit and Fast Recovery), TCPNewReno (Fast Retransmit and Fast Recovery)</li>
  <li>RFC 3390 - Increased Initial Window (optional) integrated to TCPBaseAlg
   (can be used for TCPNewReno, TCPReno, TCPTahoe and TCPNoCongestionControl but not
   for DumbTCP).</li>
  <li>RFC 3042 - Limited Transmit algorithm (optional) integrated to TCPBaseAlg
   (can be used for TCPNewReno, TCPReno, TCPTahoe and TCPNoCongestionControl but not
   for DumbTCP).</li></ul>
<p>Missing bits:</p>
  <ul><li>URG and PSH bits not handled. Receiver always acts as if PSH was set
   on all segments: always forwards data to the app as soon as possible.</li>
  <li>no RECEIVE command. Received data are always forwarded to the app as
   soon as possible, as if the app issued a very large RECEIVE request
   at the beginning. This means there's currently no flow control
   between <a href="inet.transport.tcp.TCP.html">TCP</a> and the app.</li>
  <li>all timeouts are precisely calculated: timer granularity (which is caused
   by "slow" and "fast" i.e. 500ms and 200ms timers found in many *nix TCP
   implementations) is not simulated</li>
  <li>new ECN flags (CWR and ECE). Need to be added to header by [RFC 3168].</li>
  <li>Re-starting Idle Connections (RFC 2581)
   RFC 2581, pages 7 and 8: "When <a href="inet.transport.tcp.TCP.html">TCP</a> has not received a segment for
   more than one retransmission timeout, cwnd is reduced to the value
   of the restart window (RW) before transmission begins.
   For the purposes of this standard, we define RW = IW."</li></ul>
<p>TCPNewReno/TCPReno/TCPTahoe issues and missing features:</p>
  <ul><li>KEEP-ALIVE not implemented (idle connections never time out)</li>
  <li>Nagle's algorithm (RFC 896) possibly not precisely implemented</li>
  <li>Re-starting Idle Connections (RFC 2581)
     RFC 2581, pages 7 and 8: "When <a href="inet.transport.tcp.TCP.html">TCP</a> has not received a segment for
     more than one retransmission timeout, cwnd is reduced to the value
     of the restart window (RW) before transmission begins.
     For the purposes of this standard, we define RW = IW."</li></ul>
<p>The above problems are relatively easy to fix, and will be resolved in the
next iteration. Also, other TCPAlgorithms will be added.</p>
<p><b>Tests</b></p>
<p>There are automated test cases (*.test files) for <a href="inet.transport.tcp.TCP.html">TCP</a> -- see the Test
directory in the source distribution.</p>
<p>Please also see ChangeLog.</p>
<img src="inet.transport.tcp.TCP-type.png" ismap="yes" usemap="#type-diagram"/><map name="type-diagram">
<area shape="rect" href="inet.transport.tcp.TCP.html" title="TCP" alt="TCP" coords="0,0,67,40">
</map>
<h3 class="subtitle">Usage diagram:</h3>
<p>The following diagram shows usage relationships between types.
Unresolved types are missing from the diagram.
Click <a href="full-ned-usage-diagram.html">here</a> to see the full picture.</p>
<img src="inet.transport.tcp.TCP-usage.png" ismap="yes" usemap="#usage-diagram"/><map name="usage-diagram"><area shape="rect" href="inet.transport.tcp.TCP.html" title="Simple Module TCP" alt="" coords="292,80,364,107">
<area shape="rect" href="inet.nodes.mpls.LDP_LSR.html" title="Compound Module LDP_LSR" alt="" coords="5,5,83,32">
<area shape="rect" href="inet.nodes.adhoc.MFMobileHost.html" title="Compound Module MFMobileHost" alt="" coords="107,5,211,32">
<area shape="rect" href="inet.nodes.adhoc.MobileHost.html" title="Compound Module MobileHost" alt="" coords="235,5,320,32">
<area shape="rect" href="inet.examples.labeltest.MyHost.html" title="Compound Module MyHost" alt="" coords="344,5,416,32">
<area shape="rect" href="inet.nodes.wireless.WirelessHost.html" title="Compound Module WirelessHost" alt="" coords="440,5,539,32">
<area shape="rect" href="inet.nodes.wireless.WirelessHostSimplified.html" title="Compound Module WirelessHostSimplified" alt="" coords="563,5,717,32">
</map>
<h3 class="subtitle">Inheritance diagram:</h3>
<p>The following diagram shows inheritance relationships for this type.
Unresolved types are missing from the diagram.
Click <a href="full-ned-inheritance-diagram.html">here</a> to see the full picture.</p>
<img src="inet.transport.tcp.TCP-inheritance.png" ismap="yes" usemap="#inheritance-diagram"/><map name="inheritance-diagram"><area shape="rect" href="inet.transport.tcp.TCP.html" title="Simple Module TCP" alt="" coords="5,80,77,107">
<area shape="rect" href="inet.transport.tcp.ITCP.html" title="Module Interface ITCP" alt="" coords="5,5,77,32">
</map>
<h3 class="subtitle">Used in compound modules:</h3>
<p>If a module type shows up more than once, that means it has been defined in more than one NED file.</p>
<table>
<tr>
   <td>
      <a href="inet.nodes.mpls.LDP_LSR.html">LDP_LSR</a>
      <i> (compound&nbsp;module)</i>
   </td>
   <td>

<p>An <a href="inet.networklayer.ldp.LDP.html">LDP</a>-capable router.</p>
   </td>
</tr>
<tr>
   <td>
      <a href="inet.nodes.adhoc.MFMobileHost.html">MFMobileHost</a>
      <i> (compound&nbsp;module)</i>
   </td>
   <td>

<p>Models a mobile host with a wireless (802.11b) card in ad-hoc mode.
This model contains the Mobility Framework's 802.11 implementation, <a href="inet.linklayer.mf80211.Nic80211.html">Nic80211</a>,
and <a href="inet.networklayer.ipv4.IP.html">IP</a>, <a href="inet.transport.tcp.TCP.html">TCP</a> and <a href="inet.transport.udp.UDP.html">UDP</a> protocols. The mobility model can be dynamically
specified with the mobilityType parameter.</p>
   </td>
</tr>
<tr>
   <td>
      <a href="inet.nodes.adhoc.MobileHost.html">MobileHost</a>
      <i> (compound&nbsp;module)</i>
   </td>
   <td>

<p>Models a mobile host with a wireless (802.11b) card in ad-hoc mode.
This model contains the new IEEE 802.11 implementation, <a href="inet.linklayer.ieee80211.Ieee80211Nic.html">Ieee80211Nic</a>,
and <a href="inet.networklayer.ipv4.IP.html">IP</a>, <a href="inet.transport.tcp.TCP.html">TCP</a> and <a href="inet.transport.udp.UDP.html">UDP</a> protocols. The mobility model can be
dynamically specified with the mobilityType parameter.</p>
   </td>
</tr>
<tr>
   <td>
      <a href="inet.examples.labeltest.MyHost.html">MyHost</a>
      <i> (compound&nbsp;module)</i>
   </td>
   <td>
<i>(no description)</i>
   </td>
</tr>
<tr>
   <td>
      <a href="inet.nodes.wireless.WirelessHost.html">WirelessHost</a>
      <i> (compound&nbsp;module)</i>
   </td>
   <td>

<p>Models a host with one wireless (802.11b) card in infrastructure mode.
This module is basically a <a href="inet.nodes.inet.StandardHost.html">StandardHost</a> with an <a href="inet.linklayer.ieee80211.Ieee80211NicSTA.html">Ieee80211NicSTA</a> added.
It should be used in conjunction with <a href="inet.nodes.wireless.WirelessAP.html">WirelessAP</a>, or any other AP model
which contains <a href="inet.linklayer.ieee80211.Ieee80211NicAP.html">Ieee80211NicAP</a>.</p>
   </td>
</tr>
<tr>
   <td>
      <a href="inet.nodes.wireless.WirelessHostSimplified.html">WirelessHostSimplified</a>
      <i> (compound&nbsp;module)</i>
   </td>
   <td>

<p>Models a host with one wireless (802.11b) card in infrastructure mode,
but using a simplified NIC that does not support handovers.
This module is basically a <a href="inet.nodes.inet.StandardHost.html">StandardHost</a> with an <a href="inet.linklayer.ieee80211.Ieee80211NicSTASimplified.html">Ieee80211NicSTASimplified</a>
added. It should be used in conjunction with <a href="inet.nodes.wireless.WirelessAPSimplified.html">WirelessAPSimplified</a>,
or any other AP model which contains <a href="inet.linklayer.ieee80211.Ieee80211NicAPSimplified.html">Ieee80211NicAPSimplified</a>.</p>
   </td>
</tr>
</table>
<h3 class="subtitle">Parameters:</h3>
<table class="paramtable">
   <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default value</th>
      <th>Description</th>
   </tr>
<tr class="local">
   <td width="150">advertisedWindow</td>
   <td width="100">
      <i>int</i>
   </td>
   <td width="120">14*this.mss</td>
   <td>
<p>in bytes, corresponds with the maximal receiver buffer capacity (Note: normally, NIC queues should be at least this size)</p>
   </td>
</tr>
<tr class="local">
   <td width="150">delayedAcksEnabled</td>
   <td width="100">
      <i>bool</i>
   </td>
   <td width="120">false</td>
   <td>
<p>delayed ACKs enabled/disabled</p>
   </td>
</tr>
<tr class="local">
   <td width="150">nagleEnabled</td>
   <td width="100">
      <i>bool</i>
   </td>
   <td width="120">true</td>
   <td>
<p>Nagle's algorithm (RFC 896) enabled/disabled</p>
   </td>
</tr>
<tr class="local">
   <td width="150">limitedTransmitEnabled</td>
   <td width="100">
      <i>bool</i>
   </td>
   <td width="120">false</td>
   <td>
<p>Limited Transmit algorithm (RFC 3042) enabled/disabled (can be used for TCPReno/TCPTahoe/TCPNewReno/TCPNoCongestionControl)</p>
   </td>
</tr>
<tr class="local">
   <td width="150">increasedIWEnabled</td>
   <td width="100">
      <i>bool</i>
   </td>
   <td width="120">false</td>
   <td>
<p>Increased Initial Window (RFC 3390) enabled/disabled</p>
   </td>
</tr>
<tr class="local">
   <td width="150">sackSupport</td>
   <td width="100">
      <i>bool</i>
   </td>
   <td width="120">false</td>
   <td>
<p>Selective Acknowledgment (RFC 2018, 2883, 3517) support (header option) (SACK will be enabled for a connection if both endpoints support it)</p>
   </td>
</tr>
<tr class="local">
   <td width="150">mss</td>
   <td width="100">
      <i>int</i>
   </td>
   <td width="120">536</td>
   <td>
<p>maximum segment size (header option)</p>
   </td>
</tr>
<tr class="local">
   <td width="150">tcpAlgorithmClass</td>
   <td width="100">
      <i>string</i>
   </td>
   <td width="120">"TCPReno"</td>
   <td>
<p>TCPReno/TCPTahoe/TCPNewReno/TCPNoCongestionControl/DumbTCP</p>
   </td>
</tr>
<tr class="local">
   <td width="150">sendQueueClass</td>
   <td width="100">
      <i>string</i>
   </td>
   <td width="120">"TCPVirtualDataSendQueue"</td>
   <td>
<p>TCPVirtualDataSendQueue/TCPMsgBasedSendQueue</p>
   </td>
</tr>
<tr class="local">
   <td width="150">receiveQueueClass</td>
   <td width="100">
      <i>string</i>
   </td>
   <td width="120">"TCPVirtualDataRcvQueue"</td>
   <td>
<p>TCPVirtualDataRcvQueue/TCPMsgBasedRcvQueue</p>
   </td>
</tr>
<tr class="local">
   <td width="150">recordStats</td>
   <td width="100">
      <i>bool</i>
   </td>
   <td width="120">true</td>
   <td>
<p>recording of seqNum etc. into output vectors enabled/disabled</p>
   </td>
</tr>
</table>
<h3 class="subtitle">Properties:</h3>
<table class="paramtable">
   <tr>
      <th>Name</th>
      <th>Value</th>
      <th>Description</th>
   </tr>
<tr>
   <td width="150">display</td>
   <td width="100"><i>i=block/wheelbarrow</i></td>
   <td></td>
</tr>
</table>
<h3 class="subtitle">Gates:</h3>
<table class="paramtable">
   <tr>
      <th>Name</th>
      <th>Direction</th>
      <th>Size</th>
      <th>Description</th>
   </tr>
<tr class="local">
   <td width="150">appIn [ ]</xsl:if></td>
   <td width="100"><i>input</i></td>
   <td width="50"></td>   <td></td>
</tr>
<tr class="local">
   <td width="150">ipIn</xsl:if></td>
   <td width="100"><i>input</i></td>
   <td width="50"></td>   <td></td>
</tr>
<tr class="local">
   <td width="150">ipv6In</xsl:if></td>
   <td width="100"><i>input</i></td>
   <td width="50"></td>   <td></td>
</tr>
<tr class="local">
   <td width="150">appOut [ ]</xsl:if></td>
   <td width="100"><i>output</i></td>
   <td width="50"></td>   <td></td>
</tr>
<tr class="local">
   <td width="150">ipOut</xsl:if></td>
   <td width="100"><i>output</i></td>
   <td width="50"></td>   <td></td>
</tr>
<tr class="local">
   <td width="150">ipv6Out</xsl:if></td>
   <td width="100"><i>output</i></td>
   <td width="50"></td>   <td></td>
</tr>
</table>
<h3 class="subtitle">Source code:</h3>
<pre class="src"><span style="color: #808080; font-style: italic; ">// The TCPNewReno, TCPReno and TCPTahoe algorithms implement:
//  - delayed acks, with 200ms timeout (optional)
//  - RFC 896 - Nagle's algorithm (optional)
//  - Jacobson's and Karn's algorithms for round-trip time measurement and
//    adaptive retransmission
//  - \TCPTahoe (Fast Retransmit), \TCPReno (Fast Retransmit and Fast Recovery), \TCPNewReno (Fast Retransmit and Fast Recovery)
//  - RFC 3390 - Increased Initial Window (optional) integrated to TCPBaseAlg
//    (can be used for TCPNewReno, TCPReno, TCPTahoe and TCPNoCongestionControl but not
//    for DumbTCP).
//  - RFC 3042 - Limited Transmit algorithm (optional) integrated to TCPBaseAlg
//    (can be used for TCPNewReno, TCPReno, TCPTahoe and TCPNoCongestionControl but not
//    for DumbTCP).
//
// Missing bits:
//  - URG and PSH bits not handled. Receiver always acts as if PSH was set
//    on all segments: always forwards data to the app as soon as possible.
//  - no RECEIVE command. Received data are always forwarded to the app as
//    soon as possible, as if the app issued a very large RECEIVE request
//    at the beginning. This means there's currently no flow control
//    between TCP and the app.
//  - all timeouts are precisely calculated: timer granularity (which is caused
//    by &quot;slow&quot; and &quot;fast&quot; i.e. 500ms and 200ms timers found in many *nix \TCP
//    implementations) is not simulated
//  - new ECN flags (CWR and ECE). Need to be added to header by [RFC 3168].
//  - Re-starting Idle Connections (RFC 2581)
//    RFC 2581, pages 7 and 8: &quot;When TCP has not received a segment for
//    more than one retransmission timeout, cwnd is reduced to the value
//    of the restart window (RW) before transmission begins.
//    For the purposes of this standard, we define RW = IW.&quot;
//
// TCPNewReno/TCPReno/TCPTahoe issues and missing features:
//  - KEEP-ALIVE not implemented (idle connections never time out)
//  - Nagle's algorithm (RFC 896) possibly not precisely implemented
//  - Re-starting Idle Connections (RFC 2581)
//      RFC 2581, pages 7 and 8: &quot;When TCP has not received a segment for
//      more than one retransmission timeout, cwnd is reduced to the value
//      of the restart window (RW) before transmission begins.
//      For the purposes of this standard, we define RW = IW.&quot;
//
// The above problems are relatively easy to fix, and will be resolved in the
// next iteration. Also, other TCPAlgorithms will be added.
//
// </span><span style="color: #800000; ">&lt;b&gt;</span><span style="color: #808080; font-style: italic; ">Tests</span><span style="color: #800000; ">&lt;/b&gt;</span><span style="color: #808080; font-style: italic; ">
//
// There are automated test cases (*.test files) for TCP -- see the Test
// directory in the source distribution.
//
// Please also see ChangeLog.
//
</span><span style="color: #800000; font-weight: bold; ">simple</span><span style="color: #000000; "> </span><span style="color: #000000; ">TCP</span><span style="color: #000000; "> </span><span style="color: #800000; font-weight: bold; ">like</span><span style="color: #000000; "> </span><span style="color: #000000; ">ITCP</span><span style="color: #000000; ">
{
    </span><span style="color: #800000; font-weight: bold; ">parameters</span><span style="color: #000000; ">:
        </span><span style="color: #000080; font-weight: bold; ">int</span><span style="color: #000000; "> </span><span style="color: #000000; ">advertisedWindow</span><span style="color: #000000; "> = </span><span style="color: #800000; font-weight: bold; ">default</span><span style="color: #000000; ">(</span><span style="color: #008000; ">14</span><span style="color: #000000; ">*</span><span style="color: #800000; font-weight: bold; ">this</span><span style="color: #000000; ">.</span><span style="color: #000000; ">mss</span><span style="color: #000000; ">); </span><span style="color: #808080; font-style: italic; ">// in bytes, corresponds with the maximal receiver buffer capacity (Note: normally, NIC queues should be at least this size)
</span><span style="color: #000000; ">        </span><span style="color: #000080; font-weight: bold; ">bool</span><span style="color: #000000; "> </span><span style="color: #000000; ">delayedAcksEnabled</span><span style="color: #000000; "> = </span><span style="color: #800000; font-weight: bold; ">default</span><span style="color: #000000; ">(</span><span style="color: #008000; ">false</span><span style="color: #000000; ">); </span><span style="color: #808080; font-style: italic; ">// delayed ACKs enabled/disabled
</span><span style="color: #000000; ">        </span><span style="color: #000080; font-weight: bold; ">bool</span><span style="color: #000000; "> </span><span style="color: #000000; ">nagleEnabled</span><span style="color: #000000; "> = </span><span style="color: #800000; font-weight: bold; ">default</span><span style="color: #000000; ">(</span><span style="color: #008000; ">true</span><span style="color: #000000; ">); </span><span style="color: #808080; font-style: italic; ">// Nagle's algorithm (RFC 896) enabled/disabled
</span><span style="color: #000000; ">        </span><span style="color: #000080; font-weight: bold; ">bool</span><span style="color: #000000; "> </span><span style="color: #000000; ">limitedTransmitEnabled</span><span style="color: #000000; "> = </span><span style="color: #800000; font-weight: bold; ">default</span><span style="color: #000000; ">(</span><span style="color: #008000; ">false</span><span style="color: #000000; ">); </span><span style="color: #808080; font-style: italic; ">// Limited Transmit algorithm (RFC 3042) enabled/disabled (can be used for TCPReno/TCPTahoe/TCPNewReno/TCPNoCongestionControl)
</span><span style="color: #000000; ">        </span><span style="color: #000080; font-weight: bold; ">bool</span><span style="color: #000000; "> </span><span style="color: #000000; ">increasedIWEnabled</span><span style="color: #000000; "> = </span><span style="color: #800000; font-weight: bold; ">default</span><span style="color: #000000; ">(</span><span style="color: #008000; ">false</span><span style="color: #000000; ">); </span><span style="color: #808080; font-style: italic; ">// Increased Initial Window (RFC 3390) enabled/disabled
</span><span style="color: #000000; ">        </span><span style="color: #000080; font-weight: bold; ">bool</span><span style="color: #000000; "> </span><span style="color: #000000; ">sackSupport</span><span style="color: #000000; "> = </span><span style="color: #800000; font-weight: bold; ">default</span><span style="color: #000000; ">(</span><span style="color: #008000; ">false</span><span style="color: #000000; ">); </span><span style="color: #808080; font-style: italic; ">// Selective Acknowledgment (RFC 2018, 2883, 3517) support (header option) (SACK will be enabled for a connection if both endpoints support it)
</span><span style="color: #000000; ">        </span><span style="color: #000080; font-weight: bold; ">int</span><span style="color: #000000; "> </span><span style="color: #000000; ">mss</span><span style="color: #000000; "> = </span><span style="color: #800000; font-weight: bold; ">default</span><span style="color: #000000; ">(</span><span style="color: #008000; ">536</span><span style="color: #000000; ">); </span><span style="color: #808080; font-style: italic; ">// maximum segment size (header option)
</span><span style="color: #000000; ">        </span><span style="color: #000080; font-weight: bold; ">string</span><span style="color: #000000; "> </span><span style="color: #000000; ">tcpAlgorithmClass</span><span style="color: #000000; "> = </span><span style="color: #800000; font-weight: bold; ">default</span><span style="color: #000000; ">(</span><span style="color: #008000; ">&quot;TCPReno&quot;</span><span style="color: #000000; ">); </span><span style="color: #808080; font-style: italic; ">// TCPReno/TCPTahoe/TCPNewReno/TCPNoCongestionControl/DumbTCP
</span><span style="color: #000000; ">        </span><span style="color: #000080; font-weight: bold; ">string</span><span style="color: #000000; "> </span><span style="color: #000000; ">sendQueueClass</span><span style="color: #000000; "> = </span><span style="color: #800000; font-weight: bold; ">default</span><span style="color: #000000; ">(</span><span style="color: #008000; ">&quot;TCPVirtualDataSendQueue&quot;</span><span style="color: #000000; ">); </span><span style="color: #808080; font-style: italic; ">// TCPVirtualDataSendQueue/TCPMsgBasedSendQueue
</span><span style="color: #000000; ">        </span><span style="color: #000080; font-weight: bold; ">string</span><span style="color: #000000; "> </span><span style="color: #000000; ">receiveQueueClass</span><span style="color: #000000; "> = </span><span style="color: #800000; font-weight: bold; ">default</span><span style="color: #000000; ">(</span><span style="color: #008000; ">&quot;TCPVirtualDataRcvQueue&quot;</span><span style="color: #000000; ">); </span><span style="color: #808080; font-style: italic; ">// TCPVirtualDataRcvQueue/TCPMsgBasedRcvQueue
</span><span style="color: #000000; ">        </span><span style="color: #000080; font-weight: bold; ">bool</span><span style="color: #000000; "> </span><span style="color: #000000; ">recordStats</span><span style="color: #000000; "> = </span><span style="color: #800000; font-weight: bold; ">default</span><span style="color: #000000; ">(</span><span style="color: #008000; ">true</span><span style="color: #000000; ">); </span><span style="color: #808080; font-style: italic; ">// recording of seqNum etc. into output vectors enabled/disabled
</span><span style="color: #000000; ">        </span><span style="color: #000000; font-weight: bold; ">@display</span><span style="color: #000000; ">(</span><span style="color: #008000; ">&quot;i=block/wheelbarrow&quot;</span><span style="color: #000000; ">);
    </span><span style="color: #800000; font-weight: bold; ">gates</span><span style="color: #000000; ">:
        </span><span style="color: #000080; font-weight: bold; ">input</span><span style="color: #000000; "> </span><span style="color: #000000; ">appIn</span><span style="color: #000000; ">[] </span><span style="color: #000000; font-weight: bold; ">@labels</span><span style="color: #000000; ">(</span><span style="color: #000000; ">TCPCommand</span><span style="color: #000000; ">/</span><span style="color: #000000; ">down</span><span style="color: #000000; ">);
        </span><span style="color: #000080; font-weight: bold; ">input</span><span style="color: #000000; "> </span><span style="color: #000000; ">ipIn</span><span style="color: #000000; "> </span><span style="color: #000000; font-weight: bold; ">@labels</span><span style="color: #000000; ">(</span><span style="color: #000000; ">TCPSegment</span><span style="color: #000000; ">,</span><span style="color: #000000; ">IPControlInfo</span><span style="color: #000000; ">/</span><span style="color: #000000; ">up</span><span style="color: #000000; ">);
        </span><span style="color: #000080; font-weight: bold; ">input</span><span style="color: #000000; "> </span><span style="color: #000000; ">ipv6In</span><span style="color: #000000; "> </span><span style="color: #000000; font-weight: bold; ">@labels</span><span style="color: #000000; ">(</span><span style="color: #000000; ">TCPSegment</span><span style="color: #000000; ">,</span><span style="color: #000000; ">IPv6ControlInfo</span><span style="color: #000000; ">/</span><span style="color: #000000; ">up</span><span style="color: #000000; ">);
        </span><span style="color: #000080; font-weight: bold; ">output</span><span style="color: #000000; "> </span><span style="color: #000000; ">appOut</span><span style="color: #000000; ">[] </span><span style="color: #000000; font-weight: bold; ">@labels</span><span style="color: #000000; ">(</span><span style="color: #000000; ">TCPCommand</span><span style="color: #000000; ">/</span><span style="color: #000000; ">up</span><span style="color: #000000; ">);
        </span><span style="color: #000080; font-weight: bold; ">output</span><span style="color: #000000; "> </span><span style="color: #000000; ">ipOut</span><span style="color: #000000; "> </span><span style="color: #000000; font-weight: bold; ">@labels</span><span style="color: #000000; ">(</span><span style="color: #000000; ">TCPSegment</span><span style="color: #000000; ">,</span><span style="color: #000000; ">IPControlInfo</span><span style="color: #000000; ">/</span><span style="color: #000000; ">down</span><span style="color: #000000; ">);
        </span><span style="color: #000080; font-weight: bold; ">output</span><span style="color: #000000; "> </span><span style="color: #000000; ">ipv6Out</span><span style="color: #000000; "> </span><span style="color: #000000; font-weight: bold; ">@labels</span><span style="color: #000000; ">(</span><span style="color: #000000; ">TCPSegment</span><span style="color: #000000; ">,</span><span style="color: #000000; ">IPv6ControlInfo</span><span style="color: #000000; ">/</span><span style="color: #000000; ">down</span><span style="color: #000000; ">);
}
</span></pre>
   </body>
</html>
